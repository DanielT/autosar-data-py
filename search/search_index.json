{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Autosar Data for Python \u00b6 The autosar_data package provides a way to create or modify autosar data (ARXML files) in Python. There are two ways to interact with the autosar data model: The basic API allows access to any valid element in the autosar data model. This API guarantees that all modifications are valid: The element hierarchy and content data types are enforced. API description wioth usage examples: Basic API The abstraction API builds on the basic API to provide a high-level view many autosar concepts API description wioth usage examples: Abstraction API autosar_data for Python is a wrapper around the Rust crates autosar-data and autosar-data-abstraction .","title":"Home"},{"location":"#autosar-data-for-python","text":"The autosar_data package provides a way to create or modify autosar data (ARXML files) in Python. There are two ways to interact with the autosar data model: The basic API allows access to any valid element in the autosar data model. This API guarantees that all modifications are valid: The element hierarchy and content data types are enforced. API description wioth usage examples: Basic API The abstraction API builds on the basic API to provide a high-level view many autosar concepts API description wioth usage examples: Abstraction API autosar_data for Python is a wrapper around the Rust crates autosar-data and autosar-data-abstraction .","title":"Autosar Data for Python"},{"location":"abstraction_api/","text":"API Documentation: autosar_data.abstraction \u00b6 Description \u00b6 The base package of the abstraction API provides a small number of classes shared by it's sub-packages. it would usually only be used in combination with one of these: autosar_data.abstraction.communication : Communication over various busses autosar_data.abstraction.datatype : data types used in the definition of software components and signals autosar_data.abstraction.ecu_configuration : Access to the definition and values of an ECU configuration autosar_data.abstraction.software_component : Modeling of software components Example \u00b6 from autosar_data.abstraction import * from autosar_data.abstraction.communication import * from autosar_data.abstraction.datatype import * model = AutosarModelAbstraction.create(\"kitchen_comms.arxml\") system_package = model.get_or_create_package(\"/System\") ecu_package = model.get_or_create_package(\"/Ecus\") swc_package = model.get_or_create_package(\"/SoftwareComponentTypes\") comm_package = model.get_or_create_package(\"/Communication\") frames_package = model.get_or_create_package(\"/Frames\") pdus_package = model.get_or_create_package(\"/Pdus\") signals_package = model.get_or_create_package(\"/Signals\") datatypes_package = model.get_or_create_package(\"/DataTypes\") interfaces_package = model.get_or_create_package(\"/Interfaces\") # basic model elements system = system_package.create_system(\"system\", SystemCategory.EcuExtract) toaster_ecu = system.create_ecu_instance(\"ToasterEcu\", ecu_package) fridge_ecu = system.create_ecu_instance(\"FridgeEcu\", ecu_package) # software component types: The system root contains two software components, one for a toaster and one for a fridge. root_composition_type = swc_package.create_composition_sw_component_type( \"RootCompositionType\" ) toaster_app_swc_type = swc_package.create_application_sw_component_type( \"ToasterAppSwcType\" ) toaster_app_swc = root_composition_type.create_component( \"ToasterAppSwc\", toaster_app_swc_type ) fridge_app_swc_type = swc_package.create_application_sw_component_type( \"FridgeAppSwcType\" ) fridge_app_swc = root_composition_type.create_component( \"FridgeAppSwc\", fridge_app_swc_type ) # map the software components to the ECUs root_composition = system.set_root_sw_composition( \"RootComposition\", root_composition_type ) system_mapping = system.get_or_create_mapping(\"SystemMapping\") system_mapping.map_swc_to_ecu(\"ToasterEcuMapping\", toaster_app_swc, toaster_ecu) system_mapping.map_swc_to_ecu(\"FridgeEcuMapping\", fridge_app_swc, fridge_ecu) # communication over can can_cluster = system.create_can_cluster(\"CanBus\", comm_package) can_channel = can_cluster.create_physical_channel(\"CanChannel\") # both ECUs participate in the same CAN cluster toaster_can_ctrl = toaster_ecu.create_can_communication_controller(\"ToasterCanCtrl\") toaster_can_ctrl.connect_physical_channel(\"Connection\", can_channel) fridge_can_ctrl = fridge_ecu.create_can_communication_controller(\"FridgeCanCtrl\") fridge_can_ctrl.connect_physical_channel(\"Connection\", can_channel) # create CAN frames, each containing a PDU and some signals # Toaster to Fridge communication: Create a frame and trigger it in the channel on id 0x101. toaster_to_fridge_frame = system.create_can_frame( \"ToasterToFridgeFrame\", frames_package, 8 ) can_channel.trigger_frame( toaster_to_fridge_frame, 0x101, CanAddressingMode.Standard, CanFrameType.Can20 ) toaster_to_fridge_pdu = system.create_isignal_ipdu( \"ToasterToFridgePdu\", pdus_package, 8 ) # Create a PDU and trigger it in the frame at byte offset 0. CAN Frames do not allow multiple PDUs toaster_to_fridge_frame.map_pdu( toaster_to_fridge_pdu, 0, ByteOrder.MostSignificantByteLast ) # Signal \"beep\" is sent from the toaster to the fridge. It is a 32-bit signal. toaster_to_fridge_beep_syssignal = system_package.create_system_signal( \"ToasterToFridgeBeepSysSignal\" ) beep_type = datatypes_package.create_sw_base_type( \"BeepType\", 32, BaseTypeEncoding.TwosComplement, byte_order=ByteOrder.MostSignificantByteLast, native_declaration=\"uint32\", ) toaster_to_fridge_beep_signal = system.create_isignal( \"ToasterToFridgeBeep\", signals_package, 32, toaster_to_fridge_beep_syssignal, datatype=beep_type, ) toaster_to_fridge_pdu.map_signal( toaster_to_fridge_beep_signal, 0, ByteOrder.MostSignificantByteLast, transfer_property=TransferProperty.Triggered, ) toaster_to_fridge_beep_signal.init_value = 1 # Fridge to Toaster communication: Create a frame and trigger it in the channel on id 0x102. fridge_to_toaster_frame = system.create_can_frame( \"FridgeToToasterFrame\", frames_package, 8 ) can_channel.trigger_frame( fridge_to_toaster_frame, 0x102, CanAddressingMode.Standard, CanFrameType.Can20 ) # Create a PDU and trigger it in the frame at byte offset 0. CAN Frames do not allow multiple PDUs fridge_to_toaster_pdu = system.create_isignal_ipdu( \"FridgeToToasterPdu\", pdus_package, 8 ) fridge_to_toaster_frame.map_pdu( fridge_to_toaster_pdu, 0, ByteOrder.MostSignificantByteLast ) # Signal \"toot\" is sent from the fridge to the toaster. It is a 16-bit signal. fridge_to_toaster_toot_syssignal = system_package.create_system_signal( \"FridgeToToasterTootSysSignal\" ) toot_type = datatypes_package.create_sw_base_type( \"TootType\", 16, BaseTypeEncoding.TwosComplement, byte_order=ByteOrder.MostSignificantByteLast, native_declaration=\"uint16\", ) fridge_to_toaster_toot_signal = system.create_isignal( \"FridgeToToasterToot\", signals_package, 16, fridge_to_toaster_toot_syssignal, datatype=toot_type, ) fridge_to_toaster_pdu.map_signal( fridge_to_toaster_toot_signal, 0, ByteOrder.MostSignificantByteLast, transfer_property=TransferProperty.Triggered, ) fridge_to_toaster_toot_signal.init_value = 0 # create Sender/Receiver interfaces for the PDUs toaster_to_fridge_interface = interfaces_package.create_sender_receiver_interface( \"ToasterToFridgeInterface\" ) beep_impl_datatype = datatypes_package.create_implementation_data_type( ImplementationDataTypeSettings.Value(\"beep_impl\", base_type=beep_type) ) toaster_to_fridge_interface_beep = toaster_to_fridge_interface.create_data_element( \"beep\", beep_impl_datatype ) fridge_to_toaster_interface = interfaces_package.create_sender_receiver_interface( \"FridgeToToasterInterface\" ) toot_impl_datatype = datatypes_package.create_implementation_data_type( ImplementationDataTypeSettings.Value(\"toot_impl\", base_type=toot_type) ) fridge_to_toaster_interface_toot = fridge_to_toaster_interface.create_data_element( \"toot\", toot_impl_datatype ) # create ports in the software components # provide the ToasterToFridge message in the toaster (p-port) and require it in the fridge (r-port) toaster_p_port = toaster_app_swc_type.create_p_port( \"ToasterToFridgePort\", toaster_to_fridge_interface ) fridge_r_port = fridge_app_swc_type.create_r_port( \"ToasterToFridgePort\", toaster_to_fridge_interface ) root_composition_type.create_assembly_connector( \"ToasterToFridgeConnector\", toaster_p_port, toaster_app_swc, fridge_r_port, fridge_app_swc, ) # provide the FridgeToToaster message in the fridge (p-port) and require it in the toaster (r-port) fridge_p_port = fridge_app_swc_type.create_p_port( \"FridgeToToasterPort\", fridge_to_toaster_interface ) toaster_r_port = toaster_app_swc_type.create_r_port( \"FridgeToToasterPort\", fridge_to_toaster_interface ) root_composition_type.create_assembly_connector( \"FridgeToToasterConnector\", fridge_p_port, fridge_app_swc, toaster_r_port, toaster_app_swc, ) # map the ports to the PDUs system_mapping.map_sender_receiver_to_signal( toaster_to_fridge_beep_syssignal, # the system signal toaster_to_fridge_interface_beep, # is mapped to a data element in the interface toaster_p_port, # using the port in the software component [ toaster_app_swc ], # hierarchy of the software component including any non-root composition root_composition_prototype=root_composition, # the root composition prototype ) system_mapping.map_sender_receiver_to_signal( toaster_to_fridge_beep_syssignal, toaster_to_fridge_interface_beep, fridge_r_port, [fridge_app_swc], root_composition_prototype=root_composition, ) system_mapping.map_sender_receiver_to_signal( fridge_to_toaster_toot_syssignal, fridge_to_toaster_interface_toot, fridge_p_port, [fridge_app_swc], root_composition_prototype=root_composition, ) system_mapping.map_sender_receiver_to_signal( fridge_to_toaster_toot_syssignal, fridge_to_toaster_interface_toot, toaster_r_port, [toaster_app_swc], root_composition_prototype=root_composition, ) # save the model to the filename that we specified at the beginning model.write() API \u00b6 abstraction \u00b6 ArPackage \u00b6 ArPackage(element: Element) An ArPackage is an Autosar package, which can contain other packages or elements element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_application_array_data_type \u00b6 create_application_array_data_type( name: str, element_type: ApplicationDataType, size: ApplicationArraySize, ) -> ApplicationArrayDataType create a new ApplicationArrayDataType in the package create_application_primitive_data_type \u00b6 create_application_primitive_data_type( name: str, category: ApplicationPrimitiveCategory, /, *, compu_method: CompuMethod = None, unit: Unit = None, data_constraint: DataConstr = None, ) -> ApplicationPrimitiveDataType create a new ApplicationPrimitiveDataType in the package create_application_record_data_type \u00b6 create_application_record_data_type( name: str, ) -> ApplicationRecordDataType create a new ApplicationRecordDataType in the package create_application_sw_component_type \u00b6 create_application_sw_component_type( name: str, ) -> ApplicationSwComponentType create a new ApplicationSwComponentType in the package create_client_server_interface \u00b6 create_client_server_interface( name: str, ) -> ClientServerInterface create a new ClientServerInterface in the package create_complex_device_driver_sw_component_type \u00b6 create_complex_device_driver_sw_component_type( name: str, ) -> ComplexDeviceDriverSwComponentType create a new ComplexDeviceDriverSwComponentType in the package create_composition_sw_component_type \u00b6 create_composition_sw_component_type( name: str, ) -> CompositionSwComponentType create a new CompositionSwComponentType in the package create_compu_method \u00b6 create_compu_method( name: str, content: CompuMethodContent ) -> CompuMethod create a new CompuMethod in the package create_constant_specification \u00b6 create_constant_specification( name: str, value: ValueSpecification ) -> ConstantSpecification create a new ConstantSpecification in the package create_data_constr \u00b6 create_data_constr(name: str) -> DataConstr create a new DataConstr in the package create_data_transformation_set \u00b6 create_data_transformation_set( name: str, ) -> DataTransformationSet create a new DataTransformationSet in the package create_data_type_mapping_set \u00b6 create_data_type_mapping_set( name: str, ) -> DataTypeMappingSet create a new DataTypeMappingSet in the package create_ecu_abstraction_sw_component_type \u00b6 create_ecu_abstraction_sw_component_type( name: str, ) -> EcuAbstractionSwComponentType create a new EcuAbstractionSwComponentType in the package create_ecuc_definition_collection \u00b6 create_ecuc_definition_collection( name: str, ) -> EcucDefinitionCollection create a new EcucDefinitionCollection in the package create_ecuc_destination_uri_def_set \u00b6 create_ecuc_destination_uri_def_set( name: str, ) -> EcucDestinationUriDefSet create a new EcucDestinationUriDefSet in the package create_ecuc_module_configuration_values \u00b6 create_ecuc_module_configuration_values( name: str, definition: EcucModuleDef ) -> EcucModuleConfigurationValues create a new EcucModuleConfigurationValues in the package create_ecuc_module_def \u00b6 create_ecuc_module_def(name: str) -> EcucModuleDef create a new EcucModuleDef in the package create_ecuc_value_collection \u00b6 create_ecuc_value_collection( name: str, ) -> EcucValueCollection create a new EcucValueCollection in the package create_implementation_data_type \u00b6 create_implementation_data_type( settings: ImplementationDataTypeSettings, ) -> ImplementationDataType create a new ImplementationDataType in the package create_mode_declaration_group \u00b6 create_mode_declaration_group( name: str, *, category: Optional[ModeDeclarationGroupCategory] = None, ) -> ModeDeclarationGroup create a new ModeDeclarationGroup in the package create_mode_switch_interface \u00b6 create_mode_switch_interface( name: str, ) -> ModeSwitchInterface create a new ModeSwitchInterface in the package create_nv_data_interface \u00b6 create_nv_data_interface(name: str) -> NvDataInterface create a new NvDataInterface in the package create_parameter_interface \u00b6 create_parameter_interface(name: str) -> ParameterInterface create a new ParameterInterface in the package create_sender_receiver_interface \u00b6 create_sender_receiver_interface( name: str, ) -> SenderReceiverInterface create a new SenderReceiverInterface in the package create_sensor_actuator_sw_component_type \u00b6 create_sensor_actuator_sw_component_type( name: str, ) -> SensorActuatorSwComponentType create a new SensorActuatorSwComponentType in the package create_service_sw_component_type \u00b6 create_service_sw_component_type( name: str, ) -> ServiceSwComponentType create a new ServiceSwComponentType in the package create_someip_sd_client_event_group_timing_config \u00b6 create_someip_sd_client_event_group_timing_config( name: str, time_to_live: int ) -> SomeipSdClientEventGroupTimingConfig create a new SomeipSdClientEventGroupTimingConfig in the package create_someip_sd_client_service_instance_config \u00b6 create_someip_sd_client_service_instance_config( name: str, ) -> SomeipSdClientServiceInstanceConfig create a new SomeipSdClientServiceInstanceConfig in the package create_someip_sd_server_event_group_timing_config \u00b6 create_someip_sd_server_event_group_timing_config( name: str, request_response_delay: RequestResponseDelay ) -> SomeipSdServerEventGroupTimingConfig create a new SomeipSdServerEventGroupTimingConfig in the package create_someip_sd_server_service_instance_config \u00b6 create_someip_sd_server_service_instance_config( name: str, ttl: int ) -> SomeipSdServerServiceInstanceConfig create a new SomeipSdServerServiceInstanceConfig in the package create_sub_package \u00b6 create_sub_package(name: str) -> ArPackage create a new sub-package in the package create_sw_base_type \u00b6 create_sw_base_type( name: str, bit_length: int, base_type_encoding: BaseTypeEncoding, /, *, byte_order: Optional[ByteOrder] = None, mem_alignment: Optional[int] = None, native_declaration: Optional[str] = None, ) -> SwBaseType create a new SwBaseType in the package create_system \u00b6 create_system( name: str, category: SystemCategory ) -> System create a new System in the package Note that an Autosar model should ony contain one SYSTEM. This is not checked here. create_system_signal \u00b6 create_system_signal(name: str) -> SystemSignal create a new SystemSignal in the package create_system_signal_group \u00b6 create_system_signal_group(name: str) -> SystemSignalGroup create a new SystemSignalGroup in the package create_trigger_interface \u00b6 create_trigger_interface(name: str) -> TriggerInterface create a new TriggerInterface in the package create_unit \u00b6 create_unit( name: str, /, *, display_name: Optional[str] = None ) -> Unit create a new Unit in the package elements \u00b6 elements() -> Iterator[Element] iterate over all elements in the package sub_packages \u00b6 sub_packages() -> Iterator[ArPackage] iterate over all sub-packages in the package AutosarModelAbstraction \u00b6 AutosarModelAbstraction(model: AutosarModel) model instance-attribute \u00b6 model: AutosarModel Get the underlying AutosarModel from the abstraction model root_element instance-attribute \u00b6 root_element: Element Get the root element of the model create classmethod \u00b6 create( filename: str, /, *, version: Optional[AutosarVersion] = None, ) -> AutosarModelAbstraction create a new AutosarModelAbstraction with an empty AutosarModel create_file \u00b6 create_file( filename: str, /, *, version: Optional[AutosarVersion] = None, ) -> ArxmlFile Create a new file in the model files \u00b6 files() -> Iterator[ArxmlFile] iterate over all files in the model find_system \u00b6 find_system() -> Optional[System] find an existing SYSTEM in the model, if it exists from_file classmethod \u00b6 from_file(filename: str) -> AutosarModelAbstraction create an AutosarModelAbstraction from a file on disk get_element_by_path \u00b6 get_element_by_path(path: str) -> Optional[Element] Get an element by its path get_or_create_package \u00b6 get_or_create_package(path: str) -> ArPackage Get a package by its path or create it if it does not exist load_file \u00b6 load_file( filename: str, /, *, strict: bool = False ) -> Tuple[ArxmlFile, List[str]] Load a file into the model packages \u00b6 packages() -> Iterator[ArPackage] iterate over all top-level packages write \u00b6 write() -> None write the model to disk, creating or updating all files in the model ByteOrder \u00b6 The ByteOrder is used to define the order of bytes in a multi-byte value MostSignificantByteFirst instance-attribute \u00b6 MostSignificantByteFirst: ByteOrder MostSignificantByteLast instance-attribute \u00b6 MostSignificantByteLast: ByteOrder Opaque instance-attribute \u00b6 Opaque: ByteOrder EcuInstance \u00b6 EcuInstance(element: Element) The EcuInstance represents one ECU in a System Union[ element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str communication_controllers \u00b6 communication_controllers() -> Iterator[ CommunicationController ] return an interator over all communication controllers in this EcuInstance create_can_communication_controller \u00b6 create_can_communication_controller( name: str, ) -> CanCommunicationController Create a CAN-COMMUNICATION-CONTROLLER for this ECU-INSTANCE The ECU must have one controller per bus it communicates on. For example, if it communicates on two CAN buses, then two CAN-COMMUNICATION-CONTROLLERs are needed. create_ethernet_communication_controller \u00b6 create_ethernet_communication_controller( name: str, /, *, mac_address: Optional[str] = None ) -> EthernetCommunicationController Create an ETHERNET-COMMUNICATION-CONTROLLER for this ECU-INSTANCE The ECU must have one controller per bus it communicates on. For example, if it communicates on two CAN buses, then two CAN-COMMUNICATION-CONTROLLERs are needed. create_flexray_communication_controller \u00b6 create_flexray_communication_controller( name: str, ) -> FlexrayCommunicationController Create a FLEXRAY-COMMUNICATION-CONTROLLER for this ECU-INSTANCE The ECU must have one controller per bus it communicates on. For example, if it communicates on two CAN buses, then two CAN-COMMUNICATION-CONTROLLERs are needed. SwcToEcuMapping \u00b6 SwcToEcuMapping(element: Element) A SwcToEcuMapping contains a mapping between a SwComponentPrototype and an EcuInstance ecu_instance instance-attribute \u00b6 ecu_instance: Optional[EcuInstance] get the ECU instance which is the target of this mapping element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str target_component instance-attribute \u00b6 target_component: Optional[SwComponentPrototype] get the component prototype that is mapped here System \u00b6 System(element: Element) The System is the top level of a system template It defines how ECUs communicate with each other over various networks. It also contains the mapping of software components to ECUs. category instance-attribute \u00b6 category: Optional[SystemCategory] category of the system element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str pnc_vector_length instance-attribute \u00b6 pnc_vector_length: Optional[int] set the pncVectorLength of the system pnc_vector_offset instance-attribute \u00b6 pnc_vector_offset: Optional[int] set the pncVectorOffset of the system root_sw_composition instance-attribute \u00b6 root_sw_composition: Optional[RootSwCompositionPrototype] get the root software composition of the system clusters \u00b6 clusters() -> Iterator[Cluster] Create an iterator over all clusters connected to the SYSTEM create_can_cluster \u00b6 create_can_cluster( cluster_name: str, package: ArPackage, /, *, can_baudrate: Optional[int] = 500000, ) -> CanCluster create a new CAN-CLUSTER The cluster must have a channel to be valid, but this channel is not created automatically. Call [ CanCluster::create_physical_channel ] to create it. create_can_frame \u00b6 create_can_frame( name: str, package: ArPackage, byte_length: int ) -> CanFrame create a new [ CanFrame ] This new frame needs to be linked to a CanPhysicalChannel create_can_tp_config \u00b6 create_can_tp_config( name: str, package: ArPackage, can_cluster: CanCluster ) -> CanTpConfig Create a CanTpConfig in the SYSTEM CanTpConfig s contain the configuration how to segment or reassemble diagnostic messages on a CAN bus. create_container_ipdu \u00b6 create_container_ipdu( name: str, package: ArPackage, length: int, header_type: ContainerIPduHeaderType, rx_accept: RxAcceptContainedIPdu, ) -> ContainerIPdu create a [ ContainerIPdu ] in the [ System ] create_dcm_ipdu \u00b6 create_dcm_ipdu( name: str, package: ArPackage, length: int ) -> DcmIPdu create a [ DcmIPdu ] in the [ System ] create_doip_tp_config \u00b6 create_doip_tp_config( name: str, package: ArPackage, eth_cluster: EthernetCluster, ) -> DoIpTpConfig Create a DoIpTpConfig in the SYSTEM DoIpTpConfig s contain the configuration how to transmit diagnostic messages over IP networks. create_ecu_instance \u00b6 create_ecu_instance( name: str, package: ArPackage ) -> EcuInstance create an EcuInstance that is connected to this System create_ethernet_cluster \u00b6 create_ethernet_cluster( cluster_name: str, package: ArPackage ) -> EthernetCluster create a new ETHERNET-CLUSTER and connect it to the SYSTEM The cluster must have at least one channel to be valid. Call [ EthernetCluster.create_physical_channel ] to create it. create_fibex_element_ref \u00b6 create_fibex_element_ref(elem: Element) -> None connect an element to the SYSTEM by creating a FIBEX-ELEMENT-REF If there is already a FIBEX-ELEMENT-REF, this function does nothing, successfully. create_flexray_ar_tp_config \u00b6 create_flexray_ar_tp_config( name: str, package: ArPackage, flexray_cluster: FlexrayCluster, ) -> FlexrayArTpConfig Create a FlexrayArTpConfig in the SYSTEM FlexrayArTpConfig s describe how to segment or reassemble diagnostic messages on a Flexray bus. This configuration type is used for Flexray AUTOSAR TP communication. create_flexray_cluster \u00b6 create_flexray_cluster( cluster_name: str, package: ArPackage, settings: FlexrayClusterSettings, ) -> FlexrayCluster create a new FLEXRAY-CLUSTER and connect it to the SYSTEM A FlexrayClusterSettings structure containing the timings and parameters for the Flexray cluster must be provided. The cluster must have at least one channel to be valid. Call [ FlexrayCluster.create_physical_channel ] to create it. create_flexray_frame \u00b6 create_flexray_frame( name: str, package: ArPackage, byte_length: int ) -> FlexrayFrame create a new [ FlexrayFrame ] This new frame needs to be linked to a FlexrayPhysicalChannel create_flexray_tp_config \u00b6 create_flexray_tp_config( name: str, package: ArPackage, flexray_cluster: FlexrayCluster, ) -> FlexrayTpConfig Create a FlexrayTpConfig in the SYSTEM FlexrayTpConfig s describe how to segment or reassemble diagnostic messages on a Flexray bus. This configuration type is used for Flexray ISO TP communication. create_general_purpose_ipdu \u00b6 create_general_purpose_ipdu( name: str, package: ArPackage, length: int, category: GeneralPurposeIPduCategory, ) -> GeneralPurposeIPdu create a [ GeneralPurposeIPdu ] in the [ System ] create_general_purpose_pdu \u00b6 create_general_purpose_pdu( name: str, package: ArPackage, length: int, category: GeneralPurposePduCategory, ) -> GeneralPurposePdu create a [ GeneralPurposePdu ] in the [ System ] create_isignal \u00b6 create_isignal( name: str, package: ArPackage, bit_length: int, syssignal: SystemSignal, /, *, datatype: Optional[SwBaseType] = None, ) -> ISignal create a new isignal in the [ System ] create_isignal_group \u00b6 create_isignal_group( name: str, package: ArPackage, system_signal_group: SystemSignalGroup, ) -> ISignalGroup create a new signal group in the [ System ] I-SIGNAL-GROUP and SYSTEM-SIGNAL-GROUP are created using the same name; therefore they must be placed in different packages: sig_package and sys_package may not be identical. create_isignal_ipdu \u00b6 create_isignal_ipdu( name: str, package: ArPackage, length: int ) -> ISignalIPdu create an [ ISignalIPdu ] in the [ System ] create_multiplexed_ipdu \u00b6 create_multiplexed_ipdu( name: str, package: ArPackage, length: int ) -> MultiplexedIPdu create a [ MultiplexedIPdu ] in the [ System ] create_n_pdu \u00b6 create_n_pdu( name: str, package: ArPackage, length: int ) -> NPdu create an [ NPdu ] in the [ System ] create_nm_config \u00b6 create_nm_config(name: str, package: ArPackage) -> NmConfig Create a new NmConfig in the SYSTEM NmConfig s contain the configuration for network management. The System may contain zero or one NmConfig s. create_nm_pdu \u00b6 create_nm_pdu( name: str, package: ArPackage, length: int ) -> NmPdu create an [ NmPdu ] in the [ System ] create_secured_ipdu \u00b6 create_secured_ipdu( name: str, package: ArPackage, length: int, secure_props: SecureCommunicationProps, ) -> SecuredIPdu create a [ SecuredIPdu ] in the [ System ] create_service_instance_collection_set \u00b6 create_service_instance_collection_set( name: str, package: ArPackage ) -> ServiceInstanceCollectionSet Create a ServiceInstanceCollectionSet in the SYSTEM ServiceInstanceCollectionSet s are part of the new ethernet modeling that was introduced in Autosar 4.5.0 ( AUTOSAR_00048 ). create_so_ad_routing_group \u00b6 create_so_ad_routing_group( name: str, package: ArPackage, /, *, control_type: Optional[EventGroupControlType] = None, ) -> SoAdRoutingGroup Create a SoAdRoutingGroup in the SYSTEM SoAdRoutingGroup are part of the old ethernet modeling that was used prior to Autosar 4.5.0 ( AUTOSAR_00048 ). The elements are still present (but obsolete) in newer versions of the standard. Old and new elements may not be mixed in the same model. create_socket_connection_ipdu_identifier_set \u00b6 create_socket_connection_ipdu_identifier_set( name: str, package: ArPackage ) -> SocketConnectionIpduIdentifierSet Create a SocketConnectionIpduIdentifierSet in the SYSTEM SocketConnectionIpduIdentifierSet are part of the new ethernet modeling that was introduced in Autosar 4.5.0 ( AUTOSAR_00048 ). create_someip_tp_config \u00b6 create_someip_tp_config( name: str, package: ArPackage, cluster: Cluster ) -> SomeipTpConfig Create a SomeipTpConfig in the SYSTEM SomeipTpConfig s contain the configuration how to segment or reassemble large SomeipTp PDUs. ecu_instances \u00b6 ecu_instances() -> Iterator[EcuInstance] get an iterator over all ECU-INSTANCEs in this SYSTEM frames \u00b6 frames() -> Iterator[Frame] iterate over all Frames in the System get_or_create_mapping \u00b6 get_or_create_mapping(name: str) -> SystemMapping get or create a mapping for this system There does not seem to be any benefit to having multiple mappings for a single system, so this function will return the first mapping if it exists. Otherwise a new mapping will be created with the provided name. isignal_groups \u00b6 isignal_groups() -> Iterator[ISignalGroup] iterate over all ISignalGroups in the System isignals \u00b6 isignals() -> Iterator[ISignal] iterate over all ISignals in the System This iterator returns all ISignals that are connected to the System using a FibexElementRef. nm_config \u00b6 nm_config() -> Optional[NmConfig] Get the NmConfig of the SYSTEM, if any The System may contain zero or one NmConfig s. pdus \u00b6 pdus() -> Iterator[Pdu] iterate over all PDUs in the System This iterator returns all PDUs that are connected to the System using a FibexElementRef. set_root_sw_composition \u00b6 set_root_sw_composition( name: str, composition_type: CompositionSwComponentType ) -> RootSwCompositionPrototype set the root software composition of the system This function will remove any existing root software composition SystemCategory \u00b6 The category of a System AbstractSystemDescription instance-attribute \u00b6 AbstractSystemDescription: SystemCategory EcuExtract instance-attribute \u00b6 EcuExtract: SystemCategory EcuSystemDescription instance-attribute \u00b6 EcuSystemDescription: SystemCategory RptSystem instance-attribute \u00b6 RptSystem: SystemCategory SwClusterSystemDescription instance-attribute \u00b6 SwClusterSystemDescription: SystemCategory SystemConstraints instance-attribute \u00b6 SystemConstraints: SystemCategory SystemDescription instance-attribute \u00b6 SystemDescription: SystemCategory SystemExtract instance-attribute \u00b6 SystemExtract: SystemCategory SystemMapping \u00b6 SystemMapping(element: Element) A SystemMapping contains mappings in the System it contains mappings between SWCs and ECUs, as well as between ports and signals element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str system instance-attribute \u00b6 system: Optional[System] get the system that contains this mapping map_sender_receiver_to_signal \u00b6 map_sender_receiver_to_signal( signal: SystemSignal, data_element: VariableDataPrototype, port_prototype: PortPrototype, context_components: List[SwComponentPrototype], /, *, root_composition_prototype: Optional[ RootSwCompositionPrototype ] = None, ) -> None create a new mapping between a sender/receiver port and a signal signal : the system signal that the port is mapped to data_element : the data element that is mapped to the signal port_prototype : the port prototype that contains the data element context_components : a list of component prototypes from the root up to the component that directly contains the port. This list may be empty, or it could only contain the final application component prototype containing the port. root_composition_prototype : the root composition prototype that contains the swc_prototype . Rarely required, but may be needed if multiple root compositions use the same composition/component hierarchy. map_swc_to_ecu \u00b6 map_swc_to_ecu( name: str, component_prototype: SwComponentPrototype, ecu: EcuInstance, ) -> SwcToEcuMapping create a new mapping between a SWC and an ECU","title":"API Documentation: autosar_data.abstraction"},{"location":"abstraction_api/#api-documentation-autosar_dataabstraction","text":"","title":"API Documentation: autosar_data.abstraction"},{"location":"abstraction_api/#description","text":"The base package of the abstraction API provides a small number of classes shared by it's sub-packages. it would usually only be used in combination with one of these: autosar_data.abstraction.communication : Communication over various busses autosar_data.abstraction.datatype : data types used in the definition of software components and signals autosar_data.abstraction.ecu_configuration : Access to the definition and values of an ECU configuration autosar_data.abstraction.software_component : Modeling of software components","title":"Description"},{"location":"abstraction_api/#example","text":"from autosar_data.abstraction import * from autosar_data.abstraction.communication import * from autosar_data.abstraction.datatype import * model = AutosarModelAbstraction.create(\"kitchen_comms.arxml\") system_package = model.get_or_create_package(\"/System\") ecu_package = model.get_or_create_package(\"/Ecus\") swc_package = model.get_or_create_package(\"/SoftwareComponentTypes\") comm_package = model.get_or_create_package(\"/Communication\") frames_package = model.get_or_create_package(\"/Frames\") pdus_package = model.get_or_create_package(\"/Pdus\") signals_package = model.get_or_create_package(\"/Signals\") datatypes_package = model.get_or_create_package(\"/DataTypes\") interfaces_package = model.get_or_create_package(\"/Interfaces\") # basic model elements system = system_package.create_system(\"system\", SystemCategory.EcuExtract) toaster_ecu = system.create_ecu_instance(\"ToasterEcu\", ecu_package) fridge_ecu = system.create_ecu_instance(\"FridgeEcu\", ecu_package) # software component types: The system root contains two software components, one for a toaster and one for a fridge. root_composition_type = swc_package.create_composition_sw_component_type( \"RootCompositionType\" ) toaster_app_swc_type = swc_package.create_application_sw_component_type( \"ToasterAppSwcType\" ) toaster_app_swc = root_composition_type.create_component( \"ToasterAppSwc\", toaster_app_swc_type ) fridge_app_swc_type = swc_package.create_application_sw_component_type( \"FridgeAppSwcType\" ) fridge_app_swc = root_composition_type.create_component( \"FridgeAppSwc\", fridge_app_swc_type ) # map the software components to the ECUs root_composition = system.set_root_sw_composition( \"RootComposition\", root_composition_type ) system_mapping = system.get_or_create_mapping(\"SystemMapping\") system_mapping.map_swc_to_ecu(\"ToasterEcuMapping\", toaster_app_swc, toaster_ecu) system_mapping.map_swc_to_ecu(\"FridgeEcuMapping\", fridge_app_swc, fridge_ecu) # communication over can can_cluster = system.create_can_cluster(\"CanBus\", comm_package) can_channel = can_cluster.create_physical_channel(\"CanChannel\") # both ECUs participate in the same CAN cluster toaster_can_ctrl = toaster_ecu.create_can_communication_controller(\"ToasterCanCtrl\") toaster_can_ctrl.connect_physical_channel(\"Connection\", can_channel) fridge_can_ctrl = fridge_ecu.create_can_communication_controller(\"FridgeCanCtrl\") fridge_can_ctrl.connect_physical_channel(\"Connection\", can_channel) # create CAN frames, each containing a PDU and some signals # Toaster to Fridge communication: Create a frame and trigger it in the channel on id 0x101. toaster_to_fridge_frame = system.create_can_frame( \"ToasterToFridgeFrame\", frames_package, 8 ) can_channel.trigger_frame( toaster_to_fridge_frame, 0x101, CanAddressingMode.Standard, CanFrameType.Can20 ) toaster_to_fridge_pdu = system.create_isignal_ipdu( \"ToasterToFridgePdu\", pdus_package, 8 ) # Create a PDU and trigger it in the frame at byte offset 0. CAN Frames do not allow multiple PDUs toaster_to_fridge_frame.map_pdu( toaster_to_fridge_pdu, 0, ByteOrder.MostSignificantByteLast ) # Signal \"beep\" is sent from the toaster to the fridge. It is a 32-bit signal. toaster_to_fridge_beep_syssignal = system_package.create_system_signal( \"ToasterToFridgeBeepSysSignal\" ) beep_type = datatypes_package.create_sw_base_type( \"BeepType\", 32, BaseTypeEncoding.TwosComplement, byte_order=ByteOrder.MostSignificantByteLast, native_declaration=\"uint32\", ) toaster_to_fridge_beep_signal = system.create_isignal( \"ToasterToFridgeBeep\", signals_package, 32, toaster_to_fridge_beep_syssignal, datatype=beep_type, ) toaster_to_fridge_pdu.map_signal( toaster_to_fridge_beep_signal, 0, ByteOrder.MostSignificantByteLast, transfer_property=TransferProperty.Triggered, ) toaster_to_fridge_beep_signal.init_value = 1 # Fridge to Toaster communication: Create a frame and trigger it in the channel on id 0x102. fridge_to_toaster_frame = system.create_can_frame( \"FridgeToToasterFrame\", frames_package, 8 ) can_channel.trigger_frame( fridge_to_toaster_frame, 0x102, CanAddressingMode.Standard, CanFrameType.Can20 ) # Create a PDU and trigger it in the frame at byte offset 0. CAN Frames do not allow multiple PDUs fridge_to_toaster_pdu = system.create_isignal_ipdu( \"FridgeToToasterPdu\", pdus_package, 8 ) fridge_to_toaster_frame.map_pdu( fridge_to_toaster_pdu, 0, ByteOrder.MostSignificantByteLast ) # Signal \"toot\" is sent from the fridge to the toaster. It is a 16-bit signal. fridge_to_toaster_toot_syssignal = system_package.create_system_signal( \"FridgeToToasterTootSysSignal\" ) toot_type = datatypes_package.create_sw_base_type( \"TootType\", 16, BaseTypeEncoding.TwosComplement, byte_order=ByteOrder.MostSignificantByteLast, native_declaration=\"uint16\", ) fridge_to_toaster_toot_signal = system.create_isignal( \"FridgeToToasterToot\", signals_package, 16, fridge_to_toaster_toot_syssignal, datatype=toot_type, ) fridge_to_toaster_pdu.map_signal( fridge_to_toaster_toot_signal, 0, ByteOrder.MostSignificantByteLast, transfer_property=TransferProperty.Triggered, ) fridge_to_toaster_toot_signal.init_value = 0 # create Sender/Receiver interfaces for the PDUs toaster_to_fridge_interface = interfaces_package.create_sender_receiver_interface( \"ToasterToFridgeInterface\" ) beep_impl_datatype = datatypes_package.create_implementation_data_type( ImplementationDataTypeSettings.Value(\"beep_impl\", base_type=beep_type) ) toaster_to_fridge_interface_beep = toaster_to_fridge_interface.create_data_element( \"beep\", beep_impl_datatype ) fridge_to_toaster_interface = interfaces_package.create_sender_receiver_interface( \"FridgeToToasterInterface\" ) toot_impl_datatype = datatypes_package.create_implementation_data_type( ImplementationDataTypeSettings.Value(\"toot_impl\", base_type=toot_type) ) fridge_to_toaster_interface_toot = fridge_to_toaster_interface.create_data_element( \"toot\", toot_impl_datatype ) # create ports in the software components # provide the ToasterToFridge message in the toaster (p-port) and require it in the fridge (r-port) toaster_p_port = toaster_app_swc_type.create_p_port( \"ToasterToFridgePort\", toaster_to_fridge_interface ) fridge_r_port = fridge_app_swc_type.create_r_port( \"ToasterToFridgePort\", toaster_to_fridge_interface ) root_composition_type.create_assembly_connector( \"ToasterToFridgeConnector\", toaster_p_port, toaster_app_swc, fridge_r_port, fridge_app_swc, ) # provide the FridgeToToaster message in the fridge (p-port) and require it in the toaster (r-port) fridge_p_port = fridge_app_swc_type.create_p_port( \"FridgeToToasterPort\", fridge_to_toaster_interface ) toaster_r_port = toaster_app_swc_type.create_r_port( \"FridgeToToasterPort\", fridge_to_toaster_interface ) root_composition_type.create_assembly_connector( \"FridgeToToasterConnector\", fridge_p_port, fridge_app_swc, toaster_r_port, toaster_app_swc, ) # map the ports to the PDUs system_mapping.map_sender_receiver_to_signal( toaster_to_fridge_beep_syssignal, # the system signal toaster_to_fridge_interface_beep, # is mapped to a data element in the interface toaster_p_port, # using the port in the software component [ toaster_app_swc ], # hierarchy of the software component including any non-root composition root_composition_prototype=root_composition, # the root composition prototype ) system_mapping.map_sender_receiver_to_signal( toaster_to_fridge_beep_syssignal, toaster_to_fridge_interface_beep, fridge_r_port, [fridge_app_swc], root_composition_prototype=root_composition, ) system_mapping.map_sender_receiver_to_signal( fridge_to_toaster_toot_syssignal, fridge_to_toaster_interface_toot, fridge_p_port, [fridge_app_swc], root_composition_prototype=root_composition, ) system_mapping.map_sender_receiver_to_signal( fridge_to_toaster_toot_syssignal, fridge_to_toaster_interface_toot, toaster_r_port, [toaster_app_swc], root_composition_prototype=root_composition, ) # save the model to the filename that we specified at the beginning model.write()","title":"Example"},{"location":"abstraction_api/#api","text":"","title":"API"},{"location":"abstraction_api/#autosar_data.abstraction","text":"","title":"abstraction"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage","text":"ArPackage(element: Element) An ArPackage is an Autosar package, which can contain other packages or elements","title":"ArPackage"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.element","text":"element: Element","title":"element"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.name","text":"name: str","title":"name"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_application_array_data_type","text":"create_application_array_data_type( name: str, element_type: ApplicationDataType, size: ApplicationArraySize, ) -> ApplicationArrayDataType create a new ApplicationArrayDataType in the package","title":"create_application_array_data_type"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_application_primitive_data_type","text":"create_application_primitive_data_type( name: str, category: ApplicationPrimitiveCategory, /, *, compu_method: CompuMethod = None, unit: Unit = None, data_constraint: DataConstr = None, ) -> ApplicationPrimitiveDataType create a new ApplicationPrimitiveDataType in the package","title":"create_application_primitive_data_type"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_application_record_data_type","text":"create_application_record_data_type( name: str, ) -> ApplicationRecordDataType create a new ApplicationRecordDataType in the package","title":"create_application_record_data_type"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_application_sw_component_type","text":"create_application_sw_component_type( name: str, ) -> ApplicationSwComponentType create a new ApplicationSwComponentType in the package","title":"create_application_sw_component_type"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_client_server_interface","text":"create_client_server_interface( name: str, ) -> ClientServerInterface create a new ClientServerInterface in the package","title":"create_client_server_interface"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_complex_device_driver_sw_component_type","text":"create_complex_device_driver_sw_component_type( name: str, ) -> ComplexDeviceDriverSwComponentType create a new ComplexDeviceDriverSwComponentType in the package","title":"create_complex_device_driver_sw_component_type"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_composition_sw_component_type","text":"create_composition_sw_component_type( name: str, ) -> CompositionSwComponentType create a new CompositionSwComponentType in the package","title":"create_composition_sw_component_type"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_compu_method","text":"create_compu_method( name: str, content: CompuMethodContent ) -> CompuMethod create a new CompuMethod in the package","title":"create_compu_method"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_constant_specification","text":"create_constant_specification( name: str, value: ValueSpecification ) -> ConstantSpecification create a new ConstantSpecification in the package","title":"create_constant_specification"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_data_constr","text":"create_data_constr(name: str) -> DataConstr create a new DataConstr in the package","title":"create_data_constr"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_data_transformation_set","text":"create_data_transformation_set( name: str, ) -> DataTransformationSet create a new DataTransformationSet in the package","title":"create_data_transformation_set"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_data_type_mapping_set","text":"create_data_type_mapping_set( name: str, ) -> DataTypeMappingSet create a new DataTypeMappingSet in the package","title":"create_data_type_mapping_set"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_ecu_abstraction_sw_component_type","text":"create_ecu_abstraction_sw_component_type( name: str, ) -> EcuAbstractionSwComponentType create a new EcuAbstractionSwComponentType in the package","title":"create_ecu_abstraction_sw_component_type"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_ecuc_definition_collection","text":"create_ecuc_definition_collection( name: str, ) -> EcucDefinitionCollection create a new EcucDefinitionCollection in the package","title":"create_ecuc_definition_collection"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_ecuc_destination_uri_def_set","text":"create_ecuc_destination_uri_def_set( name: str, ) -> EcucDestinationUriDefSet create a new EcucDestinationUriDefSet in the package","title":"create_ecuc_destination_uri_def_set"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_ecuc_module_configuration_values","text":"create_ecuc_module_configuration_values( name: str, definition: EcucModuleDef ) -> EcucModuleConfigurationValues create a new EcucModuleConfigurationValues in the package","title":"create_ecuc_module_configuration_values"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_ecuc_module_def","text":"create_ecuc_module_def(name: str) -> EcucModuleDef create a new EcucModuleDef in the package","title":"create_ecuc_module_def"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_ecuc_value_collection","text":"create_ecuc_value_collection( name: str, ) -> EcucValueCollection create a new EcucValueCollection in the package","title":"create_ecuc_value_collection"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_implementation_data_type","text":"create_implementation_data_type( settings: ImplementationDataTypeSettings, ) -> ImplementationDataType create a new ImplementationDataType in the package","title":"create_implementation_data_type"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_mode_declaration_group","text":"create_mode_declaration_group( name: str, *, category: Optional[ModeDeclarationGroupCategory] = None, ) -> ModeDeclarationGroup create a new ModeDeclarationGroup in the package","title":"create_mode_declaration_group"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_mode_switch_interface","text":"create_mode_switch_interface( name: str, ) -> ModeSwitchInterface create a new ModeSwitchInterface in the package","title":"create_mode_switch_interface"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_nv_data_interface","text":"create_nv_data_interface(name: str) -> NvDataInterface create a new NvDataInterface in the package","title":"create_nv_data_interface"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_parameter_interface","text":"create_parameter_interface(name: str) -> ParameterInterface create a new ParameterInterface in the package","title":"create_parameter_interface"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_sender_receiver_interface","text":"create_sender_receiver_interface( name: str, ) -> SenderReceiverInterface create a new SenderReceiverInterface in the package","title":"create_sender_receiver_interface"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_sensor_actuator_sw_component_type","text":"create_sensor_actuator_sw_component_type( name: str, ) -> SensorActuatorSwComponentType create a new SensorActuatorSwComponentType in the package","title":"create_sensor_actuator_sw_component_type"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_service_sw_component_type","text":"create_service_sw_component_type( name: str, ) -> ServiceSwComponentType create a new ServiceSwComponentType in the package","title":"create_service_sw_component_type"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_someip_sd_client_event_group_timing_config","text":"create_someip_sd_client_event_group_timing_config( name: str, time_to_live: int ) -> SomeipSdClientEventGroupTimingConfig create a new SomeipSdClientEventGroupTimingConfig in the package","title":"create_someip_sd_client_event_group_timing_config"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_someip_sd_client_service_instance_config","text":"create_someip_sd_client_service_instance_config( name: str, ) -> SomeipSdClientServiceInstanceConfig create a new SomeipSdClientServiceInstanceConfig in the package","title":"create_someip_sd_client_service_instance_config"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_someip_sd_server_event_group_timing_config","text":"create_someip_sd_server_event_group_timing_config( name: str, request_response_delay: RequestResponseDelay ) -> SomeipSdServerEventGroupTimingConfig create a new SomeipSdServerEventGroupTimingConfig in the package","title":"create_someip_sd_server_event_group_timing_config"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_someip_sd_server_service_instance_config","text":"create_someip_sd_server_service_instance_config( name: str, ttl: int ) -> SomeipSdServerServiceInstanceConfig create a new SomeipSdServerServiceInstanceConfig in the package","title":"create_someip_sd_server_service_instance_config"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_sub_package","text":"create_sub_package(name: str) -> ArPackage create a new sub-package in the package","title":"create_sub_package"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_sw_base_type","text":"create_sw_base_type( name: str, bit_length: int, base_type_encoding: BaseTypeEncoding, /, *, byte_order: Optional[ByteOrder] = None, mem_alignment: Optional[int] = None, native_declaration: Optional[str] = None, ) -> SwBaseType create a new SwBaseType in the package","title":"create_sw_base_type"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_system","text":"create_system( name: str, category: SystemCategory ) -> System create a new System in the package Note that an Autosar model should ony contain one SYSTEM. This is not checked here.","title":"create_system"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_system_signal","text":"create_system_signal(name: str) -> SystemSignal create a new SystemSignal in the package","title":"create_system_signal"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_system_signal_group","text":"create_system_signal_group(name: str) -> SystemSignalGroup create a new SystemSignalGroup in the package","title":"create_system_signal_group"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_trigger_interface","text":"create_trigger_interface(name: str) -> TriggerInterface create a new TriggerInterface in the package","title":"create_trigger_interface"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.create_unit","text":"create_unit( name: str, /, *, display_name: Optional[str] = None ) -> Unit create a new Unit in the package","title":"create_unit"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.elements","text":"elements() -> Iterator[Element] iterate over all elements in the package","title":"elements"},{"location":"abstraction_api/#autosar_data.abstraction.ArPackage.sub_packages","text":"sub_packages() -> Iterator[ArPackage] iterate over all sub-packages in the package","title":"sub_packages"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction","text":"AutosarModelAbstraction(model: AutosarModel)","title":"AutosarModelAbstraction"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction.model","text":"model: AutosarModel Get the underlying AutosarModel from the abstraction model","title":"model"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction.root_element","text":"root_element: Element Get the root element of the model","title":"root_element"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction.create","text":"create( filename: str, /, *, version: Optional[AutosarVersion] = None, ) -> AutosarModelAbstraction create a new AutosarModelAbstraction with an empty AutosarModel","title":"create"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction.create_file","text":"create_file( filename: str, /, *, version: Optional[AutosarVersion] = None, ) -> ArxmlFile Create a new file in the model","title":"create_file"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction.files","text":"files() -> Iterator[ArxmlFile] iterate over all files in the model","title":"files"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction.find_system","text":"find_system() -> Optional[System] find an existing SYSTEM in the model, if it exists","title":"find_system"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction.from_file","text":"from_file(filename: str) -> AutosarModelAbstraction create an AutosarModelAbstraction from a file on disk","title":"from_file"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction.get_element_by_path","text":"get_element_by_path(path: str) -> Optional[Element] Get an element by its path","title":"get_element_by_path"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction.get_or_create_package","text":"get_or_create_package(path: str) -> ArPackage Get a package by its path or create it if it does not exist","title":"get_or_create_package"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction.load_file","text":"load_file( filename: str, /, *, strict: bool = False ) -> Tuple[ArxmlFile, List[str]] Load a file into the model","title":"load_file"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction.packages","text":"packages() -> Iterator[ArPackage] iterate over all top-level packages","title":"packages"},{"location":"abstraction_api/#autosar_data.abstraction.AutosarModelAbstraction.write","text":"write() -> None write the model to disk, creating or updating all files in the model","title":"write"},{"location":"abstraction_api/#autosar_data.abstraction.ByteOrder","text":"The ByteOrder is used to define the order of bytes in a multi-byte value","title":"ByteOrder"},{"location":"abstraction_api/#autosar_data.abstraction.ByteOrder.MostSignificantByteFirst","text":"MostSignificantByteFirst: ByteOrder","title":"MostSignificantByteFirst"},{"location":"abstraction_api/#autosar_data.abstraction.ByteOrder.MostSignificantByteLast","text":"MostSignificantByteLast: ByteOrder","title":"MostSignificantByteLast"},{"location":"abstraction_api/#autosar_data.abstraction.ByteOrder.Opaque","text":"Opaque: ByteOrder","title":"Opaque"},{"location":"abstraction_api/#autosar_data.abstraction.EcuInstance","text":"EcuInstance(element: Element) The EcuInstance represents one ECU in a System Union[","title":"EcuInstance"},{"location":"abstraction_api/#autosar_data.abstraction.EcuInstance.element","text":"element: Element","title":"element"},{"location":"abstraction_api/#autosar_data.abstraction.EcuInstance.name","text":"name: str","title":"name"},{"location":"abstraction_api/#autosar_data.abstraction.EcuInstance.communication_controllers","text":"communication_controllers() -> Iterator[ CommunicationController ] return an interator over all communication controllers in this EcuInstance","title":"communication_controllers"},{"location":"abstraction_api/#autosar_data.abstraction.EcuInstance.create_can_communication_controller","text":"create_can_communication_controller( name: str, ) -> CanCommunicationController Create a CAN-COMMUNICATION-CONTROLLER for this ECU-INSTANCE The ECU must have one controller per bus it communicates on. For example, if it communicates on two CAN buses, then two CAN-COMMUNICATION-CONTROLLERs are needed.","title":"create_can_communication_controller"},{"location":"abstraction_api/#autosar_data.abstraction.EcuInstance.create_ethernet_communication_controller","text":"create_ethernet_communication_controller( name: str, /, *, mac_address: Optional[str] = None ) -> EthernetCommunicationController Create an ETHERNET-COMMUNICATION-CONTROLLER for this ECU-INSTANCE The ECU must have one controller per bus it communicates on. For example, if it communicates on two CAN buses, then two CAN-COMMUNICATION-CONTROLLERs are needed.","title":"create_ethernet_communication_controller"},{"location":"abstraction_api/#autosar_data.abstraction.EcuInstance.create_flexray_communication_controller","text":"create_flexray_communication_controller( name: str, ) -> FlexrayCommunicationController Create a FLEXRAY-COMMUNICATION-CONTROLLER for this ECU-INSTANCE The ECU must have one controller per bus it communicates on. For example, if it communicates on two CAN buses, then two CAN-COMMUNICATION-CONTROLLERs are needed.","title":"create_flexray_communication_controller"},{"location":"abstraction_api/#autosar_data.abstraction.SwcToEcuMapping","text":"SwcToEcuMapping(element: Element) A SwcToEcuMapping contains a mapping between a SwComponentPrototype and an EcuInstance","title":"SwcToEcuMapping"},{"location":"abstraction_api/#autosar_data.abstraction.SwcToEcuMapping.ecu_instance","text":"ecu_instance: Optional[EcuInstance] get the ECU instance which is the target of this mapping","title":"ecu_instance"},{"location":"abstraction_api/#autosar_data.abstraction.SwcToEcuMapping.element","text":"element: Element","title":"element"},{"location":"abstraction_api/#autosar_data.abstraction.SwcToEcuMapping.name","text":"name: str","title":"name"},{"location":"abstraction_api/#autosar_data.abstraction.SwcToEcuMapping.target_component","text":"target_component: Optional[SwComponentPrototype] get the component prototype that is mapped here","title":"target_component"},{"location":"abstraction_api/#autosar_data.abstraction.System","text":"System(element: Element) The System is the top level of a system template It defines how ECUs communicate with each other over various networks. It also contains the mapping of software components to ECUs.","title":"System"},{"location":"abstraction_api/#autosar_data.abstraction.System.category","text":"category: Optional[SystemCategory] category of the system","title":"category"},{"location":"abstraction_api/#autosar_data.abstraction.System.element","text":"element: Element","title":"element"},{"location":"abstraction_api/#autosar_data.abstraction.System.name","text":"name: str","title":"name"},{"location":"abstraction_api/#autosar_data.abstraction.System.pnc_vector_length","text":"pnc_vector_length: Optional[int] set the pncVectorLength of the system","title":"pnc_vector_length"},{"location":"abstraction_api/#autosar_data.abstraction.System.pnc_vector_offset","text":"pnc_vector_offset: Optional[int] set the pncVectorOffset of the system","title":"pnc_vector_offset"},{"location":"abstraction_api/#autosar_data.abstraction.System.root_sw_composition","text":"root_sw_composition: Optional[RootSwCompositionPrototype] get the root software composition of the system","title":"root_sw_composition"},{"location":"abstraction_api/#autosar_data.abstraction.System.clusters","text":"clusters() -> Iterator[Cluster] Create an iterator over all clusters connected to the SYSTEM","title":"clusters"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_can_cluster","text":"create_can_cluster( cluster_name: str, package: ArPackage, /, *, can_baudrate: Optional[int] = 500000, ) -> CanCluster create a new CAN-CLUSTER The cluster must have a channel to be valid, but this channel is not created automatically. Call [ CanCluster::create_physical_channel ] to create it.","title":"create_can_cluster"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_can_frame","text":"create_can_frame( name: str, package: ArPackage, byte_length: int ) -> CanFrame create a new [ CanFrame ] This new frame needs to be linked to a CanPhysicalChannel","title":"create_can_frame"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_can_tp_config","text":"create_can_tp_config( name: str, package: ArPackage, can_cluster: CanCluster ) -> CanTpConfig Create a CanTpConfig in the SYSTEM CanTpConfig s contain the configuration how to segment or reassemble diagnostic messages on a CAN bus.","title":"create_can_tp_config"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_container_ipdu","text":"create_container_ipdu( name: str, package: ArPackage, length: int, header_type: ContainerIPduHeaderType, rx_accept: RxAcceptContainedIPdu, ) -> ContainerIPdu create a [ ContainerIPdu ] in the [ System ]","title":"create_container_ipdu"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_dcm_ipdu","text":"create_dcm_ipdu( name: str, package: ArPackage, length: int ) -> DcmIPdu create a [ DcmIPdu ] in the [ System ]","title":"create_dcm_ipdu"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_doip_tp_config","text":"create_doip_tp_config( name: str, package: ArPackage, eth_cluster: EthernetCluster, ) -> DoIpTpConfig Create a DoIpTpConfig in the SYSTEM DoIpTpConfig s contain the configuration how to transmit diagnostic messages over IP networks.","title":"create_doip_tp_config"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_ecu_instance","text":"create_ecu_instance( name: str, package: ArPackage ) -> EcuInstance create an EcuInstance that is connected to this System","title":"create_ecu_instance"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_ethernet_cluster","text":"create_ethernet_cluster( cluster_name: str, package: ArPackage ) -> EthernetCluster create a new ETHERNET-CLUSTER and connect it to the SYSTEM The cluster must have at least one channel to be valid. Call [ EthernetCluster.create_physical_channel ] to create it.","title":"create_ethernet_cluster"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_fibex_element_ref","text":"create_fibex_element_ref(elem: Element) -> None connect an element to the SYSTEM by creating a FIBEX-ELEMENT-REF If there is already a FIBEX-ELEMENT-REF, this function does nothing, successfully.","title":"create_fibex_element_ref"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_flexray_ar_tp_config","text":"create_flexray_ar_tp_config( name: str, package: ArPackage, flexray_cluster: FlexrayCluster, ) -> FlexrayArTpConfig Create a FlexrayArTpConfig in the SYSTEM FlexrayArTpConfig s describe how to segment or reassemble diagnostic messages on a Flexray bus. This configuration type is used for Flexray AUTOSAR TP communication.","title":"create_flexray_ar_tp_config"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_flexray_cluster","text":"create_flexray_cluster( cluster_name: str, package: ArPackage, settings: FlexrayClusterSettings, ) -> FlexrayCluster create a new FLEXRAY-CLUSTER and connect it to the SYSTEM A FlexrayClusterSettings structure containing the timings and parameters for the Flexray cluster must be provided. The cluster must have at least one channel to be valid. Call [ FlexrayCluster.create_physical_channel ] to create it.","title":"create_flexray_cluster"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_flexray_frame","text":"create_flexray_frame( name: str, package: ArPackage, byte_length: int ) -> FlexrayFrame create a new [ FlexrayFrame ] This new frame needs to be linked to a FlexrayPhysicalChannel","title":"create_flexray_frame"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_flexray_tp_config","text":"create_flexray_tp_config( name: str, package: ArPackage, flexray_cluster: FlexrayCluster, ) -> FlexrayTpConfig Create a FlexrayTpConfig in the SYSTEM FlexrayTpConfig s describe how to segment or reassemble diagnostic messages on a Flexray bus. This configuration type is used for Flexray ISO TP communication.","title":"create_flexray_tp_config"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_general_purpose_ipdu","text":"create_general_purpose_ipdu( name: str, package: ArPackage, length: int, category: GeneralPurposeIPduCategory, ) -> GeneralPurposeIPdu create a [ GeneralPurposeIPdu ] in the [ System ]","title":"create_general_purpose_ipdu"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_general_purpose_pdu","text":"create_general_purpose_pdu( name: str, package: ArPackage, length: int, category: GeneralPurposePduCategory, ) -> GeneralPurposePdu create a [ GeneralPurposePdu ] in the [ System ]","title":"create_general_purpose_pdu"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_isignal","text":"create_isignal( name: str, package: ArPackage, bit_length: int, syssignal: SystemSignal, /, *, datatype: Optional[SwBaseType] = None, ) -> ISignal create a new isignal in the [ System ]","title":"create_isignal"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_isignal_group","text":"create_isignal_group( name: str, package: ArPackage, system_signal_group: SystemSignalGroup, ) -> ISignalGroup create a new signal group in the [ System ] I-SIGNAL-GROUP and SYSTEM-SIGNAL-GROUP are created using the same name; therefore they must be placed in different packages: sig_package and sys_package may not be identical.","title":"create_isignal_group"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_isignal_ipdu","text":"create_isignal_ipdu( name: str, package: ArPackage, length: int ) -> ISignalIPdu create an [ ISignalIPdu ] in the [ System ]","title":"create_isignal_ipdu"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_multiplexed_ipdu","text":"create_multiplexed_ipdu( name: str, package: ArPackage, length: int ) -> MultiplexedIPdu create a [ MultiplexedIPdu ] in the [ System ]","title":"create_multiplexed_ipdu"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_n_pdu","text":"create_n_pdu( name: str, package: ArPackage, length: int ) -> NPdu create an [ NPdu ] in the [ System ]","title":"create_n_pdu"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_nm_config","text":"create_nm_config(name: str, package: ArPackage) -> NmConfig Create a new NmConfig in the SYSTEM NmConfig s contain the configuration for network management. The System may contain zero or one NmConfig s.","title":"create_nm_config"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_nm_pdu","text":"create_nm_pdu( name: str, package: ArPackage, length: int ) -> NmPdu create an [ NmPdu ] in the [ System ]","title":"create_nm_pdu"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_secured_ipdu","text":"create_secured_ipdu( name: str, package: ArPackage, length: int, secure_props: SecureCommunicationProps, ) -> SecuredIPdu create a [ SecuredIPdu ] in the [ System ]","title":"create_secured_ipdu"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_service_instance_collection_set","text":"create_service_instance_collection_set( name: str, package: ArPackage ) -> ServiceInstanceCollectionSet Create a ServiceInstanceCollectionSet in the SYSTEM ServiceInstanceCollectionSet s are part of the new ethernet modeling that was introduced in Autosar 4.5.0 ( AUTOSAR_00048 ).","title":"create_service_instance_collection_set"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_so_ad_routing_group","text":"create_so_ad_routing_group( name: str, package: ArPackage, /, *, control_type: Optional[EventGroupControlType] = None, ) -> SoAdRoutingGroup Create a SoAdRoutingGroup in the SYSTEM SoAdRoutingGroup are part of the old ethernet modeling that was used prior to Autosar 4.5.0 ( AUTOSAR_00048 ). The elements are still present (but obsolete) in newer versions of the standard. Old and new elements may not be mixed in the same model.","title":"create_so_ad_routing_group"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_socket_connection_ipdu_identifier_set","text":"create_socket_connection_ipdu_identifier_set( name: str, package: ArPackage ) -> SocketConnectionIpduIdentifierSet Create a SocketConnectionIpduIdentifierSet in the SYSTEM SocketConnectionIpduIdentifierSet are part of the new ethernet modeling that was introduced in Autosar 4.5.0 ( AUTOSAR_00048 ).","title":"create_socket_connection_ipdu_identifier_set"},{"location":"abstraction_api/#autosar_data.abstraction.System.create_someip_tp_config","text":"create_someip_tp_config( name: str, package: ArPackage, cluster: Cluster ) -> SomeipTpConfig Create a SomeipTpConfig in the SYSTEM SomeipTpConfig s contain the configuration how to segment or reassemble large SomeipTp PDUs.","title":"create_someip_tp_config"},{"location":"abstraction_api/#autosar_data.abstraction.System.ecu_instances","text":"ecu_instances() -> Iterator[EcuInstance] get an iterator over all ECU-INSTANCEs in this SYSTEM","title":"ecu_instances"},{"location":"abstraction_api/#autosar_data.abstraction.System.frames","text":"frames() -> Iterator[Frame] iterate over all Frames in the System","title":"frames"},{"location":"abstraction_api/#autosar_data.abstraction.System.get_or_create_mapping","text":"get_or_create_mapping(name: str) -> SystemMapping get or create a mapping for this system There does not seem to be any benefit to having multiple mappings for a single system, so this function will return the first mapping if it exists. Otherwise a new mapping will be created with the provided name.","title":"get_or_create_mapping"},{"location":"abstraction_api/#autosar_data.abstraction.System.isignal_groups","text":"isignal_groups() -> Iterator[ISignalGroup] iterate over all ISignalGroups in the System","title":"isignal_groups"},{"location":"abstraction_api/#autosar_data.abstraction.System.isignals","text":"isignals() -> Iterator[ISignal] iterate over all ISignals in the System This iterator returns all ISignals that are connected to the System using a FibexElementRef.","title":"isignals"},{"location":"abstraction_api/#autosar_data.abstraction.System.nm_config","text":"nm_config() -> Optional[NmConfig] Get the NmConfig of the SYSTEM, if any The System may contain zero or one NmConfig s.","title":"nm_config"},{"location":"abstraction_api/#autosar_data.abstraction.System.pdus","text":"pdus() -> Iterator[Pdu] iterate over all PDUs in the System This iterator returns all PDUs that are connected to the System using a FibexElementRef.","title":"pdus"},{"location":"abstraction_api/#autosar_data.abstraction.System.set_root_sw_composition","text":"set_root_sw_composition( name: str, composition_type: CompositionSwComponentType ) -> RootSwCompositionPrototype set the root software composition of the system This function will remove any existing root software composition","title":"set_root_sw_composition"},{"location":"abstraction_api/#autosar_data.abstraction.SystemCategory","text":"The category of a System","title":"SystemCategory"},{"location":"abstraction_api/#autosar_data.abstraction.SystemCategory.AbstractSystemDescription","text":"AbstractSystemDescription: SystemCategory","title":"AbstractSystemDescription"},{"location":"abstraction_api/#autosar_data.abstraction.SystemCategory.EcuExtract","text":"EcuExtract: SystemCategory","title":"EcuExtract"},{"location":"abstraction_api/#autosar_data.abstraction.SystemCategory.EcuSystemDescription","text":"EcuSystemDescription: SystemCategory","title":"EcuSystemDescription"},{"location":"abstraction_api/#autosar_data.abstraction.SystemCategory.RptSystem","text":"RptSystem: SystemCategory","title":"RptSystem"},{"location":"abstraction_api/#autosar_data.abstraction.SystemCategory.SwClusterSystemDescription","text":"SwClusterSystemDescription: SystemCategory","title":"SwClusterSystemDescription"},{"location":"abstraction_api/#autosar_data.abstraction.SystemCategory.SystemConstraints","text":"SystemConstraints: SystemCategory","title":"SystemConstraints"},{"location":"abstraction_api/#autosar_data.abstraction.SystemCategory.SystemDescription","text":"SystemDescription: SystemCategory","title":"SystemDescription"},{"location":"abstraction_api/#autosar_data.abstraction.SystemCategory.SystemExtract","text":"SystemExtract: SystemCategory","title":"SystemExtract"},{"location":"abstraction_api/#autosar_data.abstraction.SystemMapping","text":"SystemMapping(element: Element) A SystemMapping contains mappings in the System it contains mappings between SWCs and ECUs, as well as between ports and signals","title":"SystemMapping"},{"location":"abstraction_api/#autosar_data.abstraction.SystemMapping.element","text":"element: Element","title":"element"},{"location":"abstraction_api/#autosar_data.abstraction.SystemMapping.name","text":"name: str","title":"name"},{"location":"abstraction_api/#autosar_data.abstraction.SystemMapping.system","text":"system: Optional[System] get the system that contains this mapping","title":"system"},{"location":"abstraction_api/#autosar_data.abstraction.SystemMapping.map_sender_receiver_to_signal","text":"map_sender_receiver_to_signal( signal: SystemSignal, data_element: VariableDataPrototype, port_prototype: PortPrototype, context_components: List[SwComponentPrototype], /, *, root_composition_prototype: Optional[ RootSwCompositionPrototype ] = None, ) -> None create a new mapping between a sender/receiver port and a signal signal : the system signal that the port is mapped to data_element : the data element that is mapped to the signal port_prototype : the port prototype that contains the data element context_components : a list of component prototypes from the root up to the component that directly contains the port. This list may be empty, or it could only contain the final application component prototype containing the port. root_composition_prototype : the root composition prototype that contains the swc_prototype . Rarely required, but may be needed if multiple root compositions use the same composition/component hierarchy.","title":"map_sender_receiver_to_signal"},{"location":"abstraction_api/#autosar_data.abstraction.SystemMapping.map_swc_to_ecu","text":"map_swc_to_ecu( name: str, component_prototype: SwComponentPrototype, ecu: EcuInstance, ) -> SwcToEcuMapping create a new mapping between a SWC and an ECU","title":"map_swc_to_ecu"},{"location":"api/","text":"API Documentation: autosar_data \u00b6 Example \u00b6 from autosar_data import * # alternatively: create a new data model from scratch model = AutosarModel() # create a file in the model file1 = model.create_file(\"filename.arxml\", AutosarVersion.AUTOSAR_4_3_0) # a model can consist of multiple files - elements appear in all of them by default, unless restrictions are set file2 = model.create_file(\"filename2.arxml\", AutosarVersion.AUTOSAR_00051) # initially the model only has its root element, <AUTOSAR>. Create some elements el_elements = model.root_element \\ .create_sub_element(\"AR-PACKAGES\") \\ .create_named_sub_element(\"AR-PACKAGE\", \"Pkg\") \\ .create_sub_element(\"ELEMENTS\") # create some more elements el_fibex_element_ref = el_elements \\ .create_named_sub_element(\"SYSTEM\", \"System\") \\ .create_sub_element(\"FIBEX-ELEMENTS\") \\ .create_sub_element(\"FIBEX-ELEMENT-REF-CONDITIONAL\") \\ .create_sub_element(\"FIBEX-ELEMENT-REF\") el_can_cluster = model.root_element \\ .get_sub_element(\"AR-PACKAGES\") \\ .create_named_sub_element(\"AR-PACKAGE\", \"Pkg2\") \\ .create_sub_element(\"ELEMENTS\") \\ .create_named_sub_element(\"CAN-CLUSTER\", \"CanCluster\") # set a cross reference el_fibex_element_ref.reference_target = el_can_cluster # check the cross reference el_fibex_element_ref.character_data # '/Pkg2/CanCluster' el_fibex_element_ref.reference_target == el_can_cluster # True # get an attribute el_fibex_element_ref.attribute_value(\"DEST\") # EnumItem.CanCluster model.root_element.attribute_value(\"xmlns\") # 'http://autosar.org/schema/r4.0' # set an attribute value el_fibex_element_ref.set_attribute(\"DEST\", \"I-SIGNAL\") # setting the DEST of the reference to an invalid value has invalidated the # reference, so accessing el_fibex_element_ref.reference_target will now cause an exception el_can_cluster.set_attribute(\"UUID\", \"1234567890abcdefg\") # get the current xml text of the model: print(file1.serialize()) # this prints \"<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<AUTOSAR ...\" # write all the files in the model - this will create filename.arxml and filename2.arxml with identical content model.write() # get the autosar paths of all elements in the model paths = model.identifiable_elements # paths = ['/Pkg', '/Pkg/System', '/Pkg2', '/Pkg2/CanCluster'] # get an element by its path el_ar_package1 = model.get_element_by_path(\"/Pkg\") el_ar_package2 = model.get_element_by_path(\"/Pkg2\") el_system = model.get_element_by_path(\"/Pkg/System\") # restrict the packages to only appear in one file each el_ar_package1.remove_from_file(file2) el_ar_package2.remove_from_file(file1) # write all the files in the model - now the content is different model.write() API \u00b6 autosar_data \u00b6 Provides functionality to read, modify and write Autosar arxml files, both separately and in projects consisting of multiple files. Classes: ArxmlFile AutosarModel AutosarVersion Element ElementType ValidSubElementInfo Variables: version AttributeName module-attribute \u00b6 AttributeName: TypeAlias = Literal[ \"ACCESSKEY\", \"ALIGN\", \"ALLOW-BREAK\", \"ALT\", \"BASE\", \"BGCOLOR\", \"BINDING-TIME\", \"BLUEPRINT-VALUE\", \"BREAK\", \"CLASS\", \"COLNAME\", \"COLNUM\", \"COLOR\", \"COLS\", \"COLSEP\", \"COLWIDTH\", \"COORDS\", \"DEST\", \"EDIT-HEIGHT\", \"EDIT-WIDTH\", \"EDITFIT\", \"EDITSCALE\", \"ENUM-TABLE\", \"FILENAME\", \"FIT\", \"FLOAT\", \"FONT\", \"FRAME\", \"GENERATOR\", \"GID\", \"HEIGHT\", \"HELP-ENTRY\", \"HREF\", \"HTML-FIT\", \"HTML-HEIGHT\", \"HTML-SCALE\", \"HTML-WIDTH\", \"INDEX\", \"INTERVAL-TYPE\", \"ITEM-LABEL-POS\", \"KEEP-WITH-PREVIOUS\", \"L\", \"LEVEL\", \"MIME-TYPE\", \"MOREROWS\", \"NAME\", \"NAME-PATTERN\", \"NAMEEND\", \"NAMEST\", \"NOHREF\", \"NOTATION\", \"NOTE-TYPE\", \"ONBLUR\", \"ONCLICK\", \"ONDBLCLICK\", \"ONFOCUS\", \"ONKEYDOWN\", \"ONKEYPRESS\", \"ONKEYUP\", \"ONMOUSEDOWN\", \"ONMOUSEMOVE\", \"ONMOUSEOUT\", \"ONMOUSEOVER\", \"ONMOUSEUP\", \"ORIENT\", \"PGWIDE\", \"RESOLUTION-POLICY\", \"ROTATE\", \"ROWSEP\", \"S\", \"SCALE\", \"SD\", \"SHAPE\", \"SHORT-LABEL\", \"SHOW-CONTENT\", \"SHOW-RESOURCE-ALIAS-NAME\", \"SHOW-RESOURCE-CATEGORY\", \"SHOW-RESOURCE-LONG-NAME\", \"SHOW-RESOURCE-NUMBER\", \"SHOW-RESOURCE-PAGE\", \"SHOW-RESOURCE-SHORT-NAME\", \"SHOW-RESOURCE-TYPE\", \"SHOW-SEE\", \"SI\", \"SPANNAME\", \"STYLE\", \"T\", \"TABINDEX\", \"TABSTYLE\", \"TEX-RENDER\", \"TITLE\", \"TYPE\", \"UUID\", \"VALIDITY\", \"VALIGN\", \"VIEW\", \"WIDTH\", \"xml:space\", \"xmlns\", \"xmlns:xsi\", \"xsi:schemaLocation\", ] CharacterData module-attribute \u00b6 CharacterData: TypeAlias = Union[EnumItem, str, int, float] CharacterDataType module-attribute \u00b6 CharacterDataType: TypeAlias = Union[ CharacterDataTypeEnum, CharacterDataTypeFloat, CharacterDataTypeRestrictedString, CharacterDataTypeString, CharacterDataTypeUnsignedInt, ] ElementContent module-attribute \u00b6 ElementContent: TypeAlias = Union[Element, CharacterData] ElementName module-attribute \u00b6 ElementName: TypeAlias = str EnumItem module-attribute \u00b6 EnumItem: TypeAlias = str IncompatibleItemError module-attribute \u00b6 IncompatibleItemError: TypeAlias = Union[ IncompatibleAttributeError, IncompatibleAttributeValueError, IncompatibleElementError, ] VersionSpecification module-attribute \u00b6 VersionSpecification: TypeAlias = Union[ AutosarVersion, List[AutosarVersion] ] ArxmlFile \u00b6 Represents a file that is part of an AutosarModel elements_dfs property \u00b6 elements_dfs: Iterator[Tuple[int, Element]] filename property \u00b6 filename: str model property \u00b6 model: AutosarModel Get the autosar model that is built from the ARXML files version property \u00b6 version: AutosarVersion xml_standalone property \u00b6 xml_standalone: bool get the \"xml_standalone\" attribute from the header of the ARXML file check_version_compatibility method descriptor \u00b6 check_version_compatibility() -> List[ IncompatibleItemError ] Check if the data in the ARXML file is compatible with the given target version elements_dfs_with_max_depth method descriptor \u00b6 elements_dfs_with_max_depth( max_depth: int, ) -> Iterator[Tuple[int, Element]] dfs iterator over all elements in this file, with a maximum depth serialize method descriptor \u00b6 serialize() -> str Serialize the ARXML file to a string Attribute \u00b6 An attribute on an element attrname property \u00b6 attrname: AttributeName content class \u00b6 content: CharacterData = <member 'content' of 'autosar_data._autosar_data.Attribute' objects> AttributeSpec \u00b6 Specification of an attribute attribute_name property \u00b6 attribute_name: str name of the attribute required property \u00b6 required: bool is the attribute required or optional value_spec property \u00b6 value_spec: CharacterDataType AutosarDataError \u00b6 Bases: builtins.Exception AutosarModel \u00b6 Autosar data model. It contains all elements. elements_dfs property \u00b6 elements_dfs: Iterator[int, Element] depth first dearch iterator over all elements in the model, regardless of their association with a file files property \u00b6 files: List[ArxmlFile] a list of ArxmlFile objects containing all files in the model identifiable_elements property \u00b6 identifiable_elements: Iterator[Tuple[str, Element]] Iterate over pairs of (path, element) for all identifiable elements in the model root_element property \u00b6 root_element: Element The root element of the model, check_references method descriptor \u00b6 check_references() -> List[Element] check all references in the model and return a list of elements containing invalid references create_file method descriptor \u00b6 create_file( filename: str, /, version: AutosarVersion = Ellipsis ) -> ArxmlFile create a new file in the model duplicate method descriptor \u00b6 duplicate() -> AutosarModel duplicate the model, creating a new independent copy get_element_by_path method descriptor \u00b6 get_element_by_path(path) -> Element get an identifiable element in the model by its Autosar path get_references_to method descriptor \u00b6 get_references_to(target_path: str) -> List[Element] get all reference elements which refer to the given Autosar path load_buffer method descriptor \u00b6 load_buffer( buffer: str, filename: str, /, strict: bool = False ) -> Tuple[ArxmlFile, List[str]] load a buffer (string) as arxml load_file method descriptor \u00b6 load_file( filename: str, /, strict: bool = False ) -> Tuple[ArxmlFile, List[str]] load a file as arxml remove_file method descriptor \u00b6 remove_file(file) -> None remove a file from the model. Any elements belonging exclusively to that file will also be removed. serialize_files method descriptor \u00b6 serialize_files() -> Dict[str, str] serialize all files individually, to generate a dict(filename, serialized content), sort method descriptor \u00b6 sort() -> None sort the entire model in place. Takes all ordering constraints into account. write method descriptor \u00b6 write() -> None write all files in the model to disk AutosarVersion \u00b6 AUTOSAR_00042 class \u00b6 AUTOSAR_00042: AutosarVersion = AutosarVersion.AUTOSAR_00042 AUTOSAR_00043 class \u00b6 AUTOSAR_00043: AutosarVersion = AutosarVersion.AUTOSAR_00043 AUTOSAR_00044 class \u00b6 AUTOSAR_00044: AutosarVersion = AutosarVersion.AUTOSAR_00044 AUTOSAR_00045 class \u00b6 AUTOSAR_00045: AutosarVersion = AutosarVersion.AUTOSAR_00045 AUTOSAR_00046 class \u00b6 AUTOSAR_00046: AutosarVersion = AutosarVersion.AUTOSAR_00046 AUTOSAR_00047 class \u00b6 AUTOSAR_00047: AutosarVersion = AutosarVersion.AUTOSAR_00047 AUTOSAR_00048 class \u00b6 AUTOSAR_00048: AutosarVersion = AutosarVersion.AUTOSAR_00048 AUTOSAR_00049 class \u00b6 AUTOSAR_00049: AutosarVersion = AutosarVersion.AUTOSAR_00049 AUTOSAR_00050 class \u00b6 AUTOSAR_00050: AutosarVersion = AutosarVersion.AUTOSAR_00050 AUTOSAR_00051 class \u00b6 AUTOSAR_00051: AutosarVersion = AutosarVersion.AUTOSAR_00051 AUTOSAR_00052 class \u00b6 AUTOSAR_00052: AutosarVersion = AutosarVersion.AUTOSAR_00052 AUTOSAR_00053 class \u00b6 AUTOSAR_00053: AutosarVersion = AutosarVersion.AUTOSAR_00053 AUTOSAR_4_0_1 class \u00b6 AUTOSAR_4_0_1: AutosarVersion = AutosarVersion.AUTOSAR_4_0_1 AUTOSAR_4_0_2 class \u00b6 AUTOSAR_4_0_2: AutosarVersion = AutosarVersion.AUTOSAR_4_0_2 AUTOSAR_4_0_3 class \u00b6 AUTOSAR_4_0_3: AutosarVersion = AutosarVersion.AUTOSAR_4_0_3 AUTOSAR_4_1_1 class \u00b6 AUTOSAR_4_1_1: AutosarVersion = AutosarVersion.AUTOSAR_4_1_1 AUTOSAR_4_1_2 class \u00b6 AUTOSAR_4_1_2: AutosarVersion = AutosarVersion.AUTOSAR_4_1_2 AUTOSAR_4_1_3 class \u00b6 AUTOSAR_4_1_3: AutosarVersion = AutosarVersion.AUTOSAR_4_1_3 AUTOSAR_4_2_1 class \u00b6 AUTOSAR_4_2_1: AutosarVersion = AutosarVersion.AUTOSAR_4_2_1 AUTOSAR_4_2_2 class \u00b6 AUTOSAR_4_2_2: AutosarVersion = AutosarVersion.AUTOSAR_4_2_2 AUTOSAR_4_3_0 class \u00b6 AUTOSAR_4_3_0: AutosarVersion = AutosarVersion.AUTOSAR_4_3_0 LATEST class \u00b6 LATEST: AutosarVersion = AutosarVersion.LATEST CharacterDataTypeEnum \u00b6 The character data in an element or attribute is an enum value values property \u00b6 values: List[str] list of permitted enum values CharacterDataTypeFloat \u00b6 The character data in an element or attribute is a float CharacterDataTypeRestrictedString \u00b6 The character data in an element or attribute is a string that must match a regex max_length property \u00b6 max_length max length (if any) regex property \u00b6 regex: str validation regex CharacterDataTypeString \u00b6 The character data in an element or attribute is a string max_length property \u00b6 max_length max length (if any) preserve_whitespace property \u00b6 preserve_whitespace does this element preserve whitespace in its character data CharacterDataTypeUnsignedInt \u00b6 The character data in an element or attribute is an unsigned integer ContentMode \u00b6 The content mode of an element type Bag class \u00b6 Bag: ContentMode = Bag The content mode of an element type Characters class \u00b6 Characters: ContentMode = Characters The content mode of an element type Choice class \u00b6 Choice: ContentMode = Choice The content mode of an element type Mixed class \u00b6 Mixed: ContentMode = Mixed The content mode of an element type Sequence class \u00b6 Sequence: ContentMode = Sequence The content mode of an element type ContentType \u00b6 The content type of an element CharacterData class \u00b6 CharacterData: ContentType = CharacterData The content type of an element Elements class \u00b6 Elements: ContentType = Elements The content type of an element Mixed class \u00b6 Mixed: ContentType = Mixed The content type of an element Element \u00b6 An element in the Autosar data model attributes property \u00b6 attributes: Iterator[Attribute] character_data property \u00b6 character_data: CharacterData comment property \u00b6 comment: str content property \u00b6 content: Iterator[Union[Element, CharacterData]] content_item_count property \u00b6 content_item_count: int content_type property \u00b6 content_type: ContentType element_name property \u00b6 element_name: ElementName element_type property \u00b6 element_type: ElementType elements_dfs property \u00b6 elements_dfs: Iterator[Tuple[int, Element]] file_membership property \u00b6 file_membership: Tuple[bool, FrozenSet[ArxmlFile]] is_identifiable property \u00b6 is_identifiable: bool is_reference property \u00b6 is_reference: bool item_name property \u00b6 item_name: str min_version property \u00b6 min_version: AutosarVersion model property \u00b6 model: AutosarModel named_parent property \u00b6 named_parent: Element parent property \u00b6 parent: Element path property \u00b6 path: str position property \u00b6 position: int reference_target property \u00b6 reference_target: Element Set the reference target of a reference element This is only valid for elements with a reference content type. sub_elements property \u00b6 sub_elements: Iterator[Element] xml_path property \u00b6 xml_path: str add_to_file method descriptor \u00b6 add_to_file(file: ArxmlFile) -> None add the element to a file. if necessary all parent elements of this element also become part of the file attribute_value method descriptor \u00b6 attribute_value(attrname_str) -> CharacterData get the attribute value of a specific attribute. Returns None if that attribute is not set create_copied_sub_element method descriptor \u00b6 create_copied_sub_element() -> Element Create a new sub-element by copying the given element and all its children This creates a fully-independen copy. The function can copy elements between different models. create_named_sub_element method descriptor \u00b6 create_named_sub_element() -> Element Create a new sub-element with the given element name and item name create_sub_element method descriptor \u00b6 create_sub_element() -> Element Create a new sub-element with the given element name elements_dfs_with_max_depth method descriptor \u00b6 elements_dfs_with_max_depth( max_depth: int, ) -> Iterator[Tuple[int, Element]] depth first search iterator for this element and all of its sub elements, with a maximum depth get_bsw_sub_element method descriptor \u00b6 get_bsw_sub_element() -> Element get the sub element with the given definition ref. It is possible to specify either the full definition ref, or only the last part after the final '/' get_named_sub_element method descriptor \u00b6 get_named_sub_element() -> Element Get the sub-element with the given item name, if it exists get_or_create_named_sub_element method descriptor \u00b6 get_or_create_named_sub_element() -> Element Get or create a sub-element with the given element name and item name get_or_create_sub_element method descriptor \u00b6 get_or_create_sub_element() -> Element Get or create a sub-element with the given element name This is used to ensure that a sub-element with the given name exists. get_sub_element method descriptor \u00b6 get_sub_element() -> Element Get a sub-element with the given element name If multiple sub-elements with the same name exist, only the first one is returned. get_sub_element_at method descriptor \u00b6 get_sub_element_at() -> Element Get a sub-element at the given position The position is 0-based, and must be less than the number of sub-elements. insert_character_content_item method descriptor \u00b6 insert_character_content_item() -> None for elements with ElementType mixed, this allows character data to be inserted at any point in the content of this element list_valid_sub_elements method descriptor \u00b6 list_valid_sub_elements() -> List[ValidSubElementInfo] provide information about valid sub elements as a list of ValidSubElementInfo move_element_here method descriptor \u00b6 move_element_here() -> Element Move the given element to become a sub-element of this element remove_attribute method descriptor \u00b6 remove_attribute() -> None remove an attribute from the element remove_character_content_item method descriptor \u00b6 remove_character_content_item() -> None remove one character content item from the given position remove_character_data method descriptor \u00b6 remove_character_data() -> None Remove the character data from the element remove_from_file method descriptor \u00b6 remove_from_file(file: ArxmlFile) -> None remove this element from a file. Does not affect parent elements. When an element is no longer part of any file it is deleted. remove_sub_element method descriptor \u00b6 remove_sub_element() -> None Remove the given sub-element from this element Removing the element invalidates it, and causes all of the removed elements children to be removed as well. remove_sub_element_kind method descriptor \u00b6 remove_sub_element_kind() -> None Remove a sub-element with the given element name If multiple sub-elements with the same name exist, only the first one is removed. serialize method descriptor \u00b6 serialize() -> str Serialize the element to a string in XML format set_attribute method descriptor \u00b6 set_attribute(attrname_str, value) -> None set the given attribute to the provided value. If the attribute is valid for this element it will be created or modified as needed. sort method descriptor \u00b6 sort() -> None sort this element and all of its sub elements ElementType \u00b6 Type of an Element in the specification attributes_spec property \u00b6 attributes_spec: List[AttributeSpec] chardata_spec property \u00b6 chardata_spec: CharacterDataType content_mode property \u00b6 content_mode: ContentMode is_named property \u00b6 is_named: bool is_ordered property \u00b6 is_ordered: bool is_ref property \u00b6 is_ref: bool splittable property \u00b6 splittable: List[AutosarVersion] std_restriction property \u00b6 std_restriction: str sub_elements_spec property \u00b6 sub_elements_spec: List[SubElementSpec] find_attribute_spec method descriptor \u00b6 find_attribute_spec(attrname_str) -> AttributeSpec find the specification for the given attribute name find_sub_element method descriptor \u00b6 find_sub_element( target_name: ElementName, version_obj ) -> ElementType find the ElementType of the named sub element in the specification of this ElementType reference_dest_value method descriptor \u00b6 reference_dest_value(target: ElementType) -> EnumItem helper to determine the correct value for the DEST attribute when setting a reference splittable_in method descriptor \u00b6 splittable_in(version: AutosarVersion) -> bool is this element splittable in a particular AutosarVersion IncompatibleAttributeError \u00b6 Information about an attribute that is incompatible with a given target version allowed_versions property \u00b6 allowed_versions: List[AutosarVersion] attribute property \u00b6 attribute: AttributeName element property \u00b6 element: Element IncompatibleAttributeValueError \u00b6 Information about an attribute value that is incompatible with a given target version allowed_versions property \u00b6 allowed_versions: List[AutosarVersion] attribute property \u00b6 attribute: AttributeName attribute_value property \u00b6 attribute_value: str element property \u00b6 element: Element IncompatibleElementError \u00b6 Information about an element that is incompatible with a given target version allowed_versions property \u00b6 allowed_versions: List[AutosarVersion] element property \u00b6 element: Element SubElementSpec \u00b6 Specification of a sub element allowed_versions property \u00b6 allowed_versions: List[AutosarVersion] list of versions in which this sub element is compatible element_name property \u00b6 element_name: str name of the sub element element_type property \u00b6 element_type: ElementType element type of the sub element ValidSubElementInfo \u00b6 Details about a particular sub element element_name property \u00b6 element_name: str is_allowed property \u00b6 is_allowed: bool is_named property \u00b6 is_named: bool check_buffer builtin \u00b6 check_buffer() Check if the given buffer contains valid Autosar data The function returns true if the buffer starts with a valid arxml header (after skipping whitespace and comments). This function does not check anything after the header. check_file builtin \u00b6 check_file(filename: str) Check if the file contains arxml data. Returns true if an arxml file header is found and does not parse anything after it.","title":"API Documentation: autosar_data"},{"location":"api/#api-documentation-autosar_data","text":"","title":"API Documentation: autosar_data"},{"location":"api/#example","text":"from autosar_data import * # alternatively: create a new data model from scratch model = AutosarModel() # create a file in the model file1 = model.create_file(\"filename.arxml\", AutosarVersion.AUTOSAR_4_3_0) # a model can consist of multiple files - elements appear in all of them by default, unless restrictions are set file2 = model.create_file(\"filename2.arxml\", AutosarVersion.AUTOSAR_00051) # initially the model only has its root element, <AUTOSAR>. Create some elements el_elements = model.root_element \\ .create_sub_element(\"AR-PACKAGES\") \\ .create_named_sub_element(\"AR-PACKAGE\", \"Pkg\") \\ .create_sub_element(\"ELEMENTS\") # create some more elements el_fibex_element_ref = el_elements \\ .create_named_sub_element(\"SYSTEM\", \"System\") \\ .create_sub_element(\"FIBEX-ELEMENTS\") \\ .create_sub_element(\"FIBEX-ELEMENT-REF-CONDITIONAL\") \\ .create_sub_element(\"FIBEX-ELEMENT-REF\") el_can_cluster = model.root_element \\ .get_sub_element(\"AR-PACKAGES\") \\ .create_named_sub_element(\"AR-PACKAGE\", \"Pkg2\") \\ .create_sub_element(\"ELEMENTS\") \\ .create_named_sub_element(\"CAN-CLUSTER\", \"CanCluster\") # set a cross reference el_fibex_element_ref.reference_target = el_can_cluster # check the cross reference el_fibex_element_ref.character_data # '/Pkg2/CanCluster' el_fibex_element_ref.reference_target == el_can_cluster # True # get an attribute el_fibex_element_ref.attribute_value(\"DEST\") # EnumItem.CanCluster model.root_element.attribute_value(\"xmlns\") # 'http://autosar.org/schema/r4.0' # set an attribute value el_fibex_element_ref.set_attribute(\"DEST\", \"I-SIGNAL\") # setting the DEST of the reference to an invalid value has invalidated the # reference, so accessing el_fibex_element_ref.reference_target will now cause an exception el_can_cluster.set_attribute(\"UUID\", \"1234567890abcdefg\") # get the current xml text of the model: print(file1.serialize()) # this prints \"<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<AUTOSAR ...\" # write all the files in the model - this will create filename.arxml and filename2.arxml with identical content model.write() # get the autosar paths of all elements in the model paths = model.identifiable_elements # paths = ['/Pkg', '/Pkg/System', '/Pkg2', '/Pkg2/CanCluster'] # get an element by its path el_ar_package1 = model.get_element_by_path(\"/Pkg\") el_ar_package2 = model.get_element_by_path(\"/Pkg2\") el_system = model.get_element_by_path(\"/Pkg/System\") # restrict the packages to only appear in one file each el_ar_package1.remove_from_file(file2) el_ar_package2.remove_from_file(file1) # write all the files in the model - now the content is different model.write()","title":"Example"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#autosar_data","text":"Provides functionality to read, modify and write Autosar arxml files, both separately and in projects consisting of multiple files. Classes: ArxmlFile AutosarModel AutosarVersion Element ElementType ValidSubElementInfo Variables: version","title":"autosar_data"},{"location":"api/#autosar_data.AttributeName","text":"AttributeName: TypeAlias = Literal[ \"ACCESSKEY\", \"ALIGN\", \"ALLOW-BREAK\", \"ALT\", \"BASE\", \"BGCOLOR\", \"BINDING-TIME\", \"BLUEPRINT-VALUE\", \"BREAK\", \"CLASS\", \"COLNAME\", \"COLNUM\", \"COLOR\", \"COLS\", \"COLSEP\", \"COLWIDTH\", \"COORDS\", \"DEST\", \"EDIT-HEIGHT\", \"EDIT-WIDTH\", \"EDITFIT\", \"EDITSCALE\", \"ENUM-TABLE\", \"FILENAME\", \"FIT\", \"FLOAT\", \"FONT\", \"FRAME\", \"GENERATOR\", \"GID\", \"HEIGHT\", \"HELP-ENTRY\", \"HREF\", \"HTML-FIT\", \"HTML-HEIGHT\", \"HTML-SCALE\", \"HTML-WIDTH\", \"INDEX\", \"INTERVAL-TYPE\", \"ITEM-LABEL-POS\", \"KEEP-WITH-PREVIOUS\", \"L\", \"LEVEL\", \"MIME-TYPE\", \"MOREROWS\", \"NAME\", \"NAME-PATTERN\", \"NAMEEND\", \"NAMEST\", \"NOHREF\", \"NOTATION\", \"NOTE-TYPE\", \"ONBLUR\", \"ONCLICK\", \"ONDBLCLICK\", \"ONFOCUS\", \"ONKEYDOWN\", \"ONKEYPRESS\", \"ONKEYUP\", \"ONMOUSEDOWN\", \"ONMOUSEMOVE\", \"ONMOUSEOUT\", \"ONMOUSEOVER\", \"ONMOUSEUP\", \"ORIENT\", \"PGWIDE\", \"RESOLUTION-POLICY\", \"ROTATE\", \"ROWSEP\", \"S\", \"SCALE\", \"SD\", \"SHAPE\", \"SHORT-LABEL\", \"SHOW-CONTENT\", \"SHOW-RESOURCE-ALIAS-NAME\", \"SHOW-RESOURCE-CATEGORY\", \"SHOW-RESOURCE-LONG-NAME\", \"SHOW-RESOURCE-NUMBER\", \"SHOW-RESOURCE-PAGE\", \"SHOW-RESOURCE-SHORT-NAME\", \"SHOW-RESOURCE-TYPE\", \"SHOW-SEE\", \"SI\", \"SPANNAME\", \"STYLE\", \"T\", \"TABINDEX\", \"TABSTYLE\", \"TEX-RENDER\", \"TITLE\", \"TYPE\", \"UUID\", \"VALIDITY\", \"VALIGN\", \"VIEW\", \"WIDTH\", \"xml:space\", \"xmlns\", \"xmlns:xsi\", \"xsi:schemaLocation\", ]","title":"AttributeName"},{"location":"api/#autosar_data.CharacterData","text":"CharacterData: TypeAlias = Union[EnumItem, str, int, float]","title":"CharacterData"},{"location":"api/#autosar_data.CharacterDataType","text":"CharacterDataType: TypeAlias = Union[ CharacterDataTypeEnum, CharacterDataTypeFloat, CharacterDataTypeRestrictedString, CharacterDataTypeString, CharacterDataTypeUnsignedInt, ]","title":"CharacterDataType"},{"location":"api/#autosar_data.ElementContent","text":"ElementContent: TypeAlias = Union[Element, CharacterData]","title":"ElementContent"},{"location":"api/#autosar_data.ElementName","text":"ElementName: TypeAlias = str","title":"ElementName"},{"location":"api/#autosar_data.EnumItem","text":"EnumItem: TypeAlias = str","title":"EnumItem"},{"location":"api/#autosar_data.IncompatibleItemError","text":"IncompatibleItemError: TypeAlias = Union[ IncompatibleAttributeError, IncompatibleAttributeValueError, IncompatibleElementError, ]","title":"IncompatibleItemError"},{"location":"api/#autosar_data.VersionSpecification","text":"VersionSpecification: TypeAlias = Union[ AutosarVersion, List[AutosarVersion] ]","title":"VersionSpecification"},{"location":"api/#autosar_data.ArxmlFile","text":"Represents a file that is part of an AutosarModel","title":"ArxmlFile"},{"location":"api/#autosar_data.ArxmlFile.elements_dfs","text":"elements_dfs: Iterator[Tuple[int, Element]]","title":"elements_dfs"},{"location":"api/#autosar_data.ArxmlFile.filename","text":"filename: str","title":"filename"},{"location":"api/#autosar_data.ArxmlFile.model","text":"model: AutosarModel Get the autosar model that is built from the ARXML files","title":"model"},{"location":"api/#autosar_data.ArxmlFile.version","text":"version: AutosarVersion","title":"version"},{"location":"api/#autosar_data.ArxmlFile.xml_standalone","text":"xml_standalone: bool get the \"xml_standalone\" attribute from the header of the ARXML file","title":"xml_standalone"},{"location":"api/#autosar_data.ArxmlFile.check_version_compatibility","text":"check_version_compatibility() -> List[ IncompatibleItemError ] Check if the data in the ARXML file is compatible with the given target version","title":"check_version_compatibility"},{"location":"api/#autosar_data.ArxmlFile.elements_dfs_with_max_depth","text":"elements_dfs_with_max_depth( max_depth: int, ) -> Iterator[Tuple[int, Element]] dfs iterator over all elements in this file, with a maximum depth","title":"elements_dfs_with_max_depth"},{"location":"api/#autosar_data.ArxmlFile.serialize","text":"serialize() -> str Serialize the ARXML file to a string","title":"serialize"},{"location":"api/#autosar_data.Attribute","text":"An attribute on an element","title":"Attribute"},{"location":"api/#autosar_data.Attribute.attrname","text":"attrname: AttributeName","title":"attrname"},{"location":"api/#autosar_data.Attribute.content","text":"content: CharacterData = <member 'content' of 'autosar_data._autosar_data.Attribute' objects>","title":"content"},{"location":"api/#autosar_data.AttributeSpec","text":"Specification of an attribute","title":"AttributeSpec"},{"location":"api/#autosar_data.AttributeSpec.attribute_name","text":"attribute_name: str name of the attribute","title":"attribute_name"},{"location":"api/#autosar_data.AttributeSpec.required","text":"required: bool is the attribute required or optional","title":"required"},{"location":"api/#autosar_data.AttributeSpec.value_spec","text":"value_spec: CharacterDataType","title":"value_spec"},{"location":"api/#autosar_data.AutosarDataError","text":"Bases: builtins.Exception","title":"AutosarDataError"},{"location":"api/#autosar_data.AutosarModel","text":"Autosar data model. It contains all elements.","title":"AutosarModel"},{"location":"api/#autosar_data.AutosarModel.elements_dfs","text":"elements_dfs: Iterator[int, Element] depth first dearch iterator over all elements in the model, regardless of their association with a file","title":"elements_dfs"},{"location":"api/#autosar_data.AutosarModel.files","text":"files: List[ArxmlFile] a list of ArxmlFile objects containing all files in the model","title":"files"},{"location":"api/#autosar_data.AutosarModel.identifiable_elements","text":"identifiable_elements: Iterator[Tuple[str, Element]] Iterate over pairs of (path, element) for all identifiable elements in the model","title":"identifiable_elements"},{"location":"api/#autosar_data.AutosarModel.root_element","text":"root_element: Element The root element of the model,","title":"root_element"},{"location":"api/#autosar_data.AutosarModel.check_references","text":"check_references() -> List[Element] check all references in the model and return a list of elements containing invalid references","title":"check_references"},{"location":"api/#autosar_data.AutosarModel.create_file","text":"create_file( filename: str, /, version: AutosarVersion = Ellipsis ) -> ArxmlFile create a new file in the model","title":"create_file"},{"location":"api/#autosar_data.AutosarModel.duplicate","text":"duplicate() -> AutosarModel duplicate the model, creating a new independent copy","title":"duplicate"},{"location":"api/#autosar_data.AutosarModel.get_element_by_path","text":"get_element_by_path(path) -> Element get an identifiable element in the model by its Autosar path","title":"get_element_by_path"},{"location":"api/#autosar_data.AutosarModel.get_references_to","text":"get_references_to(target_path: str) -> List[Element] get all reference elements which refer to the given Autosar path","title":"get_references_to"},{"location":"api/#autosar_data.AutosarModel.load_buffer","text":"load_buffer( buffer: str, filename: str, /, strict: bool = False ) -> Tuple[ArxmlFile, List[str]] load a buffer (string) as arxml","title":"load_buffer"},{"location":"api/#autosar_data.AutosarModel.load_file","text":"load_file( filename: str, /, strict: bool = False ) -> Tuple[ArxmlFile, List[str]] load a file as arxml","title":"load_file"},{"location":"api/#autosar_data.AutosarModel.remove_file","text":"remove_file(file) -> None remove a file from the model. Any elements belonging exclusively to that file will also be removed.","title":"remove_file"},{"location":"api/#autosar_data.AutosarModel.serialize_files","text":"serialize_files() -> Dict[str, str] serialize all files individually, to generate a dict(filename, serialized content),","title":"serialize_files"},{"location":"api/#autosar_data.AutosarModel.sort","text":"sort() -> None sort the entire model in place. Takes all ordering constraints into account.","title":"sort"},{"location":"api/#autosar_data.AutosarModel.write","text":"write() -> None write all files in the model to disk","title":"write"},{"location":"api/#autosar_data.AutosarVersion","text":"","title":"AutosarVersion"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_00042","text":"AUTOSAR_00042: AutosarVersion = AutosarVersion.AUTOSAR_00042","title":"AUTOSAR_00042"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_00043","text":"AUTOSAR_00043: AutosarVersion = AutosarVersion.AUTOSAR_00043","title":"AUTOSAR_00043"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_00044","text":"AUTOSAR_00044: AutosarVersion = AutosarVersion.AUTOSAR_00044","title":"AUTOSAR_00044"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_00045","text":"AUTOSAR_00045: AutosarVersion = AutosarVersion.AUTOSAR_00045","title":"AUTOSAR_00045"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_00046","text":"AUTOSAR_00046: AutosarVersion = AutosarVersion.AUTOSAR_00046","title":"AUTOSAR_00046"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_00047","text":"AUTOSAR_00047: AutosarVersion = AutosarVersion.AUTOSAR_00047","title":"AUTOSAR_00047"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_00048","text":"AUTOSAR_00048: AutosarVersion = AutosarVersion.AUTOSAR_00048","title":"AUTOSAR_00048"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_00049","text":"AUTOSAR_00049: AutosarVersion = AutosarVersion.AUTOSAR_00049","title":"AUTOSAR_00049"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_00050","text":"AUTOSAR_00050: AutosarVersion = AutosarVersion.AUTOSAR_00050","title":"AUTOSAR_00050"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_00051","text":"AUTOSAR_00051: AutosarVersion = AutosarVersion.AUTOSAR_00051","title":"AUTOSAR_00051"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_00052","text":"AUTOSAR_00052: AutosarVersion = AutosarVersion.AUTOSAR_00052","title":"AUTOSAR_00052"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_00053","text":"AUTOSAR_00053: AutosarVersion = AutosarVersion.AUTOSAR_00053","title":"AUTOSAR_00053"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_4_0_1","text":"AUTOSAR_4_0_1: AutosarVersion = AutosarVersion.AUTOSAR_4_0_1","title":"AUTOSAR_4_0_1"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_4_0_2","text":"AUTOSAR_4_0_2: AutosarVersion = AutosarVersion.AUTOSAR_4_0_2","title":"AUTOSAR_4_0_2"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_4_0_3","text":"AUTOSAR_4_0_3: AutosarVersion = AutosarVersion.AUTOSAR_4_0_3","title":"AUTOSAR_4_0_3"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_4_1_1","text":"AUTOSAR_4_1_1: AutosarVersion = AutosarVersion.AUTOSAR_4_1_1","title":"AUTOSAR_4_1_1"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_4_1_2","text":"AUTOSAR_4_1_2: AutosarVersion = AutosarVersion.AUTOSAR_4_1_2","title":"AUTOSAR_4_1_2"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_4_1_3","text":"AUTOSAR_4_1_3: AutosarVersion = AutosarVersion.AUTOSAR_4_1_3","title":"AUTOSAR_4_1_3"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_4_2_1","text":"AUTOSAR_4_2_1: AutosarVersion = AutosarVersion.AUTOSAR_4_2_1","title":"AUTOSAR_4_2_1"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_4_2_2","text":"AUTOSAR_4_2_2: AutosarVersion = AutosarVersion.AUTOSAR_4_2_2","title":"AUTOSAR_4_2_2"},{"location":"api/#autosar_data.AutosarVersion.AUTOSAR_4_3_0","text":"AUTOSAR_4_3_0: AutosarVersion = AutosarVersion.AUTOSAR_4_3_0","title":"AUTOSAR_4_3_0"},{"location":"api/#autosar_data.AutosarVersion.LATEST","text":"LATEST: AutosarVersion = AutosarVersion.LATEST","title":"LATEST"},{"location":"api/#autosar_data.CharacterDataTypeEnum","text":"The character data in an element or attribute is an enum value","title":"CharacterDataTypeEnum"},{"location":"api/#autosar_data.CharacterDataTypeEnum.values","text":"values: List[str] list of permitted enum values","title":"values"},{"location":"api/#autosar_data.CharacterDataTypeFloat","text":"The character data in an element or attribute is a float","title":"CharacterDataTypeFloat"},{"location":"api/#autosar_data.CharacterDataTypeRestrictedString","text":"The character data in an element or attribute is a string that must match a regex","title":"CharacterDataTypeRestrictedString"},{"location":"api/#autosar_data.CharacterDataTypeRestrictedString.max_length","text":"max_length max length (if any)","title":"max_length"},{"location":"api/#autosar_data.CharacterDataTypeRestrictedString.regex","text":"regex: str validation regex","title":"regex"},{"location":"api/#autosar_data.CharacterDataTypeString","text":"The character data in an element or attribute is a string","title":"CharacterDataTypeString"},{"location":"api/#autosar_data.CharacterDataTypeString.max_length","text":"max_length max length (if any)","title":"max_length"},{"location":"api/#autosar_data.CharacterDataTypeString.preserve_whitespace","text":"preserve_whitespace does this element preserve whitespace in its character data","title":"preserve_whitespace"},{"location":"api/#autosar_data.CharacterDataTypeUnsignedInt","text":"The character data in an element or attribute is an unsigned integer","title":"CharacterDataTypeUnsignedInt"},{"location":"api/#autosar_data.ContentMode","text":"The content mode of an element type","title":"ContentMode"},{"location":"api/#autosar_data.ContentMode.Bag","text":"Bag: ContentMode = Bag The content mode of an element type","title":"Bag"},{"location":"api/#autosar_data.ContentMode.Characters","text":"Characters: ContentMode = Characters The content mode of an element type","title":"Characters"},{"location":"api/#autosar_data.ContentMode.Choice","text":"Choice: ContentMode = Choice The content mode of an element type","title":"Choice"},{"location":"api/#autosar_data.ContentMode.Mixed","text":"Mixed: ContentMode = Mixed The content mode of an element type","title":"Mixed"},{"location":"api/#autosar_data.ContentMode.Sequence","text":"Sequence: ContentMode = Sequence The content mode of an element type","title":"Sequence"},{"location":"api/#autosar_data.ContentType","text":"The content type of an element","title":"ContentType"},{"location":"api/#autosar_data.ContentType.CharacterData","text":"CharacterData: ContentType = CharacterData The content type of an element","title":"CharacterData"},{"location":"api/#autosar_data.ContentType.Elements","text":"Elements: ContentType = Elements The content type of an element","title":"Elements"},{"location":"api/#autosar_data.ContentType.Mixed","text":"Mixed: ContentType = Mixed The content type of an element","title":"Mixed"},{"location":"api/#autosar_data.Element","text":"An element in the Autosar data model","title":"Element"},{"location":"api/#autosar_data.Element.attributes","text":"attributes: Iterator[Attribute]","title":"attributes"},{"location":"api/#autosar_data.Element.character_data","text":"character_data: CharacterData","title":"character_data"},{"location":"api/#autosar_data.Element.comment","text":"comment: str","title":"comment"},{"location":"api/#autosar_data.Element.content","text":"content: Iterator[Union[Element, CharacterData]]","title":"content"},{"location":"api/#autosar_data.Element.content_item_count","text":"content_item_count: int","title":"content_item_count"},{"location":"api/#autosar_data.Element.content_type","text":"content_type: ContentType","title":"content_type"},{"location":"api/#autosar_data.Element.element_name","text":"element_name: ElementName","title":"element_name"},{"location":"api/#autosar_data.Element.element_type","text":"element_type: ElementType","title":"element_type"},{"location":"api/#autosar_data.Element.elements_dfs","text":"elements_dfs: Iterator[Tuple[int, Element]]","title":"elements_dfs"},{"location":"api/#autosar_data.Element.file_membership","text":"file_membership: Tuple[bool, FrozenSet[ArxmlFile]]","title":"file_membership"},{"location":"api/#autosar_data.Element.is_identifiable","text":"is_identifiable: bool","title":"is_identifiable"},{"location":"api/#autosar_data.Element.is_reference","text":"is_reference: bool","title":"is_reference"},{"location":"api/#autosar_data.Element.item_name","text":"item_name: str","title":"item_name"},{"location":"api/#autosar_data.Element.min_version","text":"min_version: AutosarVersion","title":"min_version"},{"location":"api/#autosar_data.Element.model","text":"model: AutosarModel","title":"model"},{"location":"api/#autosar_data.Element.named_parent","text":"named_parent: Element","title":"named_parent"},{"location":"api/#autosar_data.Element.parent","text":"parent: Element","title":"parent"},{"location":"api/#autosar_data.Element.path","text":"path: str","title":"path"},{"location":"api/#autosar_data.Element.position","text":"position: int","title":"position"},{"location":"api/#autosar_data.Element.reference_target","text":"reference_target: Element Set the reference target of a reference element This is only valid for elements with a reference content type.","title":"reference_target"},{"location":"api/#autosar_data.Element.sub_elements","text":"sub_elements: Iterator[Element]","title":"sub_elements"},{"location":"api/#autosar_data.Element.xml_path","text":"xml_path: str","title":"xml_path"},{"location":"api/#autosar_data.Element.add_to_file","text":"add_to_file(file: ArxmlFile) -> None add the element to a file. if necessary all parent elements of this element also become part of the file","title":"add_to_file"},{"location":"api/#autosar_data.Element.attribute_value","text":"attribute_value(attrname_str) -> CharacterData get the attribute value of a specific attribute. Returns None if that attribute is not set","title":"attribute_value"},{"location":"api/#autosar_data.Element.create_copied_sub_element","text":"create_copied_sub_element() -> Element Create a new sub-element by copying the given element and all its children This creates a fully-independen copy. The function can copy elements between different models.","title":"create_copied_sub_element"},{"location":"api/#autosar_data.Element.create_named_sub_element","text":"create_named_sub_element() -> Element Create a new sub-element with the given element name and item name","title":"create_named_sub_element"},{"location":"api/#autosar_data.Element.create_sub_element","text":"create_sub_element() -> Element Create a new sub-element with the given element name","title":"create_sub_element"},{"location":"api/#autosar_data.Element.elements_dfs_with_max_depth","text":"elements_dfs_with_max_depth( max_depth: int, ) -> Iterator[Tuple[int, Element]] depth first search iterator for this element and all of its sub elements, with a maximum depth","title":"elements_dfs_with_max_depth"},{"location":"api/#autosar_data.Element.get_bsw_sub_element","text":"get_bsw_sub_element() -> Element get the sub element with the given definition ref. It is possible to specify either the full definition ref, or only the last part after the final '/'","title":"get_bsw_sub_element"},{"location":"api/#autosar_data.Element.get_named_sub_element","text":"get_named_sub_element() -> Element Get the sub-element with the given item name, if it exists","title":"get_named_sub_element"},{"location":"api/#autosar_data.Element.get_or_create_named_sub_element","text":"get_or_create_named_sub_element() -> Element Get or create a sub-element with the given element name and item name","title":"get_or_create_named_sub_element"},{"location":"api/#autosar_data.Element.get_or_create_sub_element","text":"get_or_create_sub_element() -> Element Get or create a sub-element with the given element name This is used to ensure that a sub-element with the given name exists.","title":"get_or_create_sub_element"},{"location":"api/#autosar_data.Element.get_sub_element","text":"get_sub_element() -> Element Get a sub-element with the given element name If multiple sub-elements with the same name exist, only the first one is returned.","title":"get_sub_element"},{"location":"api/#autosar_data.Element.get_sub_element_at","text":"get_sub_element_at() -> Element Get a sub-element at the given position The position is 0-based, and must be less than the number of sub-elements.","title":"get_sub_element_at"},{"location":"api/#autosar_data.Element.insert_character_content_item","text":"insert_character_content_item() -> None for elements with ElementType mixed, this allows character data to be inserted at any point in the content of this element","title":"insert_character_content_item"},{"location":"api/#autosar_data.Element.list_valid_sub_elements","text":"list_valid_sub_elements() -> List[ValidSubElementInfo] provide information about valid sub elements as a list of ValidSubElementInfo","title":"list_valid_sub_elements"},{"location":"api/#autosar_data.Element.move_element_here","text":"move_element_here() -> Element Move the given element to become a sub-element of this element","title":"move_element_here"},{"location":"api/#autosar_data.Element.remove_attribute","text":"remove_attribute() -> None remove an attribute from the element","title":"remove_attribute"},{"location":"api/#autosar_data.Element.remove_character_content_item","text":"remove_character_content_item() -> None remove one character content item from the given position","title":"remove_character_content_item"},{"location":"api/#autosar_data.Element.remove_character_data","text":"remove_character_data() -> None Remove the character data from the element","title":"remove_character_data"},{"location":"api/#autosar_data.Element.remove_from_file","text":"remove_from_file(file: ArxmlFile) -> None remove this element from a file. Does not affect parent elements. When an element is no longer part of any file it is deleted.","title":"remove_from_file"},{"location":"api/#autosar_data.Element.remove_sub_element","text":"remove_sub_element() -> None Remove the given sub-element from this element Removing the element invalidates it, and causes all of the removed elements children to be removed as well.","title":"remove_sub_element"},{"location":"api/#autosar_data.Element.remove_sub_element_kind","text":"remove_sub_element_kind() -> None Remove a sub-element with the given element name If multiple sub-elements with the same name exist, only the first one is removed.","title":"remove_sub_element_kind"},{"location":"api/#autosar_data.Element.serialize","text":"serialize() -> str Serialize the element to a string in XML format","title":"serialize"},{"location":"api/#autosar_data.Element.set_attribute","text":"set_attribute(attrname_str, value) -> None set the given attribute to the provided value. If the attribute is valid for this element it will be created or modified as needed.","title":"set_attribute"},{"location":"api/#autosar_data.Element.sort","text":"sort() -> None sort this element and all of its sub elements","title":"sort"},{"location":"api/#autosar_data.ElementType","text":"Type of an Element in the specification","title":"ElementType"},{"location":"api/#autosar_data.ElementType.attributes_spec","text":"attributes_spec: List[AttributeSpec]","title":"attributes_spec"},{"location":"api/#autosar_data.ElementType.chardata_spec","text":"chardata_spec: CharacterDataType","title":"chardata_spec"},{"location":"api/#autosar_data.ElementType.content_mode","text":"content_mode: ContentMode","title":"content_mode"},{"location":"api/#autosar_data.ElementType.is_named","text":"is_named: bool","title":"is_named"},{"location":"api/#autosar_data.ElementType.is_ordered","text":"is_ordered: bool","title":"is_ordered"},{"location":"api/#autosar_data.ElementType.is_ref","text":"is_ref: bool","title":"is_ref"},{"location":"api/#autosar_data.ElementType.splittable","text":"splittable: List[AutosarVersion]","title":"splittable"},{"location":"api/#autosar_data.ElementType.std_restriction","text":"std_restriction: str","title":"std_restriction"},{"location":"api/#autosar_data.ElementType.sub_elements_spec","text":"sub_elements_spec: List[SubElementSpec]","title":"sub_elements_spec"},{"location":"api/#autosar_data.ElementType.find_attribute_spec","text":"find_attribute_spec(attrname_str) -> AttributeSpec find the specification for the given attribute name","title":"find_attribute_spec"},{"location":"api/#autosar_data.ElementType.find_sub_element","text":"find_sub_element( target_name: ElementName, version_obj ) -> ElementType find the ElementType of the named sub element in the specification of this ElementType","title":"find_sub_element"},{"location":"api/#autosar_data.ElementType.reference_dest_value","text":"reference_dest_value(target: ElementType) -> EnumItem helper to determine the correct value for the DEST attribute when setting a reference","title":"reference_dest_value"},{"location":"api/#autosar_data.ElementType.splittable_in","text":"splittable_in(version: AutosarVersion) -> bool is this element splittable in a particular AutosarVersion","title":"splittable_in"},{"location":"api/#autosar_data.IncompatibleAttributeError","text":"Information about an attribute that is incompatible with a given target version","title":"IncompatibleAttributeError"},{"location":"api/#autosar_data.IncompatibleAttributeError.allowed_versions","text":"allowed_versions: List[AutosarVersion]","title":"allowed_versions"},{"location":"api/#autosar_data.IncompatibleAttributeError.attribute","text":"attribute: AttributeName","title":"attribute"},{"location":"api/#autosar_data.IncompatibleAttributeError.element","text":"element: Element","title":"element"},{"location":"api/#autosar_data.IncompatibleAttributeValueError","text":"Information about an attribute value that is incompatible with a given target version","title":"IncompatibleAttributeValueError"},{"location":"api/#autosar_data.IncompatibleAttributeValueError.allowed_versions","text":"allowed_versions: List[AutosarVersion]","title":"allowed_versions"},{"location":"api/#autosar_data.IncompatibleAttributeValueError.attribute","text":"attribute: AttributeName","title":"attribute"},{"location":"api/#autosar_data.IncompatibleAttributeValueError.attribute_value","text":"attribute_value: str","title":"attribute_value"},{"location":"api/#autosar_data.IncompatibleAttributeValueError.element","text":"element: Element","title":"element"},{"location":"api/#autosar_data.IncompatibleElementError","text":"Information about an element that is incompatible with a given target version","title":"IncompatibleElementError"},{"location":"api/#autosar_data.IncompatibleElementError.allowed_versions","text":"allowed_versions: List[AutosarVersion]","title":"allowed_versions"},{"location":"api/#autosar_data.IncompatibleElementError.element","text":"element: Element","title":"element"},{"location":"api/#autosar_data.SubElementSpec","text":"Specification of a sub element","title":"SubElementSpec"},{"location":"api/#autosar_data.SubElementSpec.allowed_versions","text":"allowed_versions: List[AutosarVersion] list of versions in which this sub element is compatible","title":"allowed_versions"},{"location":"api/#autosar_data.SubElementSpec.element_name","text":"element_name: str name of the sub element","title":"element_name"},{"location":"api/#autosar_data.SubElementSpec.element_type","text":"element_type: ElementType element type of the sub element","title":"element_type"},{"location":"api/#autosar_data.ValidSubElementInfo","text":"Details about a particular sub element","title":"ValidSubElementInfo"},{"location":"api/#autosar_data.ValidSubElementInfo.element_name","text":"element_name: str","title":"element_name"},{"location":"api/#autosar_data.ValidSubElementInfo.is_allowed","text":"is_allowed: bool","title":"is_allowed"},{"location":"api/#autosar_data.ValidSubElementInfo.is_named","text":"is_named: bool","title":"is_named"},{"location":"api/#autosar_data.check_buffer","text":"check_buffer() Check if the given buffer contains valid Autosar data The function returns true if the buffer starts with a valid arxml header (after skipping whitespace and comments). This function does not check anything after the header.","title":"check_buffer"},{"location":"api/#autosar_data.check_file","text":"check_file(filename: str) Check if the file contains arxml data. Returns true if an arxml file header is found and does not parse anything after it.","title":"check_file"},{"location":"communication_api/","text":"API Documentation: autosar_data.abstraction.communication \u00b6 Examples \u00b6 CAN \u00b6 from autosar_data.abstraction import * from autosar_data.abstraction.communication import * model = AutosarModelAbstraction.create(\"can_example.arxml\") package = model.get_or_create_package(\"/Package\") # basic model elements system = package.create_system(\"system\", SystemCategory.EcuExtract) ecu = system.create_ecu_instance(\"Ecu\", package) can_cluster = system.create_can_cluster(\"CanBus\", package) can_channel = can_cluster.create_physical_channel(\"CanChannel\") ecu_can_ctrl = ecu.create_can_communication_controller(\"CanController\") ecu_can_ctrl.connect_physical_channel(\"Connection\", can_channel) # communication elements frame = system.create_can_frame(\"Frame\", package, 8) can_channel.trigger_frame(frame, 0x101, CanAddressingMode.Standard, CanFrameType.Can20) isignal_ipdu = system.create_isignal_ipdu(\"Pdu\", package, 8) frame.map_pdu(isignal_ipdu, 0, ByteOrder.MostSignificantByteLast) syssignal = package.create_system_signal(\"SysSignal\") signal = system.create_isignal(\"Signal\", package, 12, syssignal) isignal_ipdu.map_signal(signal, 0, ByteOrder.MostSignificantByteLast) signal.init_value = 1 Ethernet (old) \u00b6 The way ethernet networks are modeled was changed substantially in Autosar 4.5.0 ( AUTOSAR_00048 ). This example shows the old way, which still exists but is deprecated. from autosar_data import AutosarVersion from autosar_data.abstraction import * from autosar_data.abstraction.communication import * model = AutosarModelAbstraction.create( \"ethernet_old.arxml\", version=AutosarVersion.AUTOSAR_00047 ) package = model.get_or_create_package(\"/Package\") # basic model elements system = package.create_system(\"system\", SystemCategory.EcuExtract) ecu = system.create_ecu_instance(\"Ecu\", package) eth_cluster = system.create_ethernet_cluster(\"EthCluster\", package) eth_channel = eth_cluster.create_physical_channel( \"EthChannel\", vlan_info=EthernetVlanInfo(vlan_name=\"VLAN_12\", vlan_id=12) ) ecu_eth_ctrl = ecu.create_ethernet_communication_controller(\"EthCtrl\") ecu_eth_ctrl.connect_physical_channel(\"Connection\", eth_channel) # network addresses ecu_address = eth_channel.create_network_endpoint( \"ecu_address\", NetworkEndpointAddress.IPv4(address=\"192.168.12.100\"), ecu=ecu ) remote_address = eth_channel.create_network_endpoint( \"remote_address\", NetworkEndpointAddress.IPv4(address=\"ANY\") ) # create network sockets ecu_socket = eth_channel.create_socket_address( \"ecu_socket\", ecu_address, TpConfig.UdpTp(port_number=1234), SocketAddressType.Unicast(ecu), ) remote_socket = eth_channel.create_socket_address( \"remote_socket\", remote_address, TpConfig.UdpTp(port_number=1234), SocketAddressType.Unicast(None), ) # socket connection bundles handle the connection between sockets socket_connection_bundle = eth_channel.create_socket_connection_bundle( \"SCB\", ecu_socket ) socket_connection = socket_connection_bundle.create_bundled_connection(remote_socket) # create a PDU and associate it with the socket connection idpu = system.create_isignal_ipdu(\"PDU\", package, 16) socket_connection.create_socket_connection_ipdu_identifier(idpu, 0xBEEF) # signals could be mapped to the PDU [...] Ethernet (new) \u00b6 This example shows the new way of modeling an ethernet network which was introduced in Autosar 4.5.0 ( AUTOSAR_00048 ). from autosar_data import AutosarVersion from autosar_data.abstraction import * from autosar_data.abstraction.communication import * model = AutosarModelAbstraction.create( \"ethernet_new.arxml\", version=AutosarVersion.LATEST ) package = model.get_or_create_package(\"/Package\") # basic model elements system = package.create_system(\"system\", SystemCategory.EcuExtract) ecu = system.create_ecu_instance(\"Ecu\", package) eth_cluster = system.create_ethernet_cluster(\"EthCluster\", package) eth_channel = eth_cluster.create_physical_channel( \"EthChannel\", vlan_info=EthernetVlanInfo(vlan_name=\"VLAN_12\", vlan_id=12) ) ecu_eth_ctrl = ecu.create_ethernet_communication_controller(\"EthCtrl\") ecu_eth_ctrl.connect_physical_channel(\"Connection\", eth_channel) # network addresses ecu_address = eth_channel.create_network_endpoint( \"ecu_address\", NetworkEndpointAddress.IPv4(address=\"192.168.12.100\"), ecu=ecu ) remote_address = eth_channel.create_network_endpoint( \"remote_address\", NetworkEndpointAddress.IPv4(address=\"ANY\") ) # create network sockets ecu_socket = eth_channel.create_socket_address( \"ecu_socket\", ecu_address, TpConfig.UdpTp(port_number=1234), SocketAddressType.Unicast(ecu), ) remote_socket = eth_channel.create_socket_address( \"remote_socket\", remote_address, TpConfig.UdpTp(port_number=1234), SocketAddressType.Unicast(None), ) # socket connection bundles handle the connection between sockets static_socket_connection = ecu_socket.create_static_socket_connection( \"StaticConnection\", remote_socket ) pdu = system.create_isignal_ipdu(\"Pdu\", package, 33) ipdu_identifier_set = system.create_socket_connection_ipdu_identifier_set( \"IpduIdentifierSet\", package ) ipdu_identifier = ipdu_identifier_set.create_socon_ipdu_identifier( \"IPduIdentifier\", pdu, eth_channel ) static_socket_connection.add_ipdu_identifier(ipdu_identifier) Flexray \u00b6 from autosar_data import AutosarVersion from autosar_data.abstraction import * from autosar_data.abstraction.communication import * model = AutosarModelAbstraction.create(\"flexray.arxml\") package = model.get_or_create_package(\"/Package\") # basic model elements system = package.create_system(\"system\", SystemCategory.EcuExtract) ecu = system.create_ecu_instance(\"Ecu\", package) flx_cluster_settings = FlexrayClusterSettings() flx_cluster_settings.baudrate = 10_000_000 # customize other cluster settings ... flx_cluster = system.create_flexray_cluster( \"FlexrayCluster\", package, flx_cluster_settings ) flx_channel = flx_cluster.create_physical_channel( \"FlexrayChannel\", FlexrayChannelName.A ) ecu_flx_ctrl = ecu.create_flexray_communication_controller(\"FlexrayController\") # communication elements frame = system.create_flexray_frame(\"Frame\", package, 32) flx_channel.trigger_frame( frame, 1, FlexrayCommunicationCycle.Repetition(1, CycleRepetition.C1) ) isignal_ipdu = system.create_isignal_ipdu(\"Pdu\", package, 32) frame.map_pdu(isignal_ipdu, 0, ByteOrder.MostSignificantByteLast) syssignal = package.create_system_signal(\"SysSignal\") signal = system.create_isignal(\"Signal\", package, 12, syssignal) isignal_ipdu.map_signal(signal, 0, ByteOrder.MostSignificantByteLast) signal.init_value = 1 API \u00b6 communication \u00b6 Cluster module-attribute \u00b6 Cluster: TypeAlias = Union[ CanCluster, FlexrayCluster, EthernetCluster ] CommunicationController module-attribute \u00b6 CommunicationController: TypeAlias = Union[ CanCommunicationController, FlexrayCommunicationController, EthernetCommunicationController, ] Frame module-attribute \u00b6 Frame: TypeAlias = Union[CanFrame, FlexrayFrame] IPdu module-attribute \u00b6 IPdu: TypeAlias = Union[ ContainerIPdu, DcmIPdu, GeneralPurposeIPdu, ISignalIPdu, SecuredIPdu, NPdu, MultiplexedIPdu, ] Pdu module-attribute \u00b6 Pdu: TypeAlias = Union[ ContainerIPdu, DcmIPdu, GeneralPurposePdu, GeneralPurposeIPdu, NPdu, ISignalIPdu, NmPdu, SecuredIPdu, MultiplexedIPdu, ] PhysicalChannel module-attribute \u00b6 PhysicalChannel: TypeAlias = Union[ CanPhysicalChannel, FlexrayPhysicalChannel, EthernetPhysicalChannel, ] TransformationTechnologyConfig module-attribute \u00b6 TransformationTechnologyConfig: TypeAlias = Union[ ComTransformationTechnologyConfig, E2ETransformationTechnologyConfig, SomeIpTransformationTechnologyConfig, GenericTransformationTechnologyConfig, ] CanAddressingMode \u00b6 The addressing mode for a CAN frame Extended instance-attribute \u00b6 Extended: CanAddressingMode Standard instance-attribute \u00b6 Standard: CanAddressingMode CanCluster \u00b6 CanCluster(element: Element) A CanCluster contains all configuration items associated with a CAN network. The cluster connects multiple ECUs. baudrate instance-attribute \u00b6 baudrate: int get or set the baudrate of the cluster can_fd_baudrate instance-attribute \u00b6 can_fd_baudrate: Optional[int] get or set the CAN FD baudrate of the cluster can_xl_baudrate instance-attribute \u00b6 can_xl_baudrate: Optional[int] get or set the CAN XL baudrate of the cluster element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str physical_channel instance-attribute \u00b6 physical_channel: Optional[CanPhysicalChannel] get or set the settings of this CanCluster with new values for the baudrates system instance-attribute \u00b6 system: Optional[System] get the System that contains this CanCluster create_physical_channel \u00b6 create_physical_channel( channel_name: str, ) -> CanPhysicalChannel Create a new physical channel for the cluster A can cluster must contain exactly one physical channel; trying to add a second one triggers an error. CanCommunicationConnector \u00b6 CanCommunicationConnector(element: Element) A connector between a [ CanCommunicationController ] in an ECU and a [ CanPhysicalChannel ] controller instance-attribute \u00b6 controller: CanCommunicationController Get the controller of the CommunicationConnector ecu_instance instance-attribute \u00b6 ecu_instance: EcuInstance EcuInstance that contains this CommunicationConnector element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str CanCommunicationController \u00b6 CanCommunicationController(element: Element) An EcuInstance needs a CanCommunicationController in order to connect to a CAN cluster. ecu_instance instance-attribute \u00b6 ecu_instance: EcuInstance Get the EcuInstance that contains this CanCommunicationController element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str connect_physical_channel \u00b6 connect_physical_channel( connection_name: str, can_channel: CanPhysicalChannel ) -> CanCommunicationConnector Connect this [ CanCommunicationController ] inside an [ EcuInstance ] to a [ CanPhysicalChannel ] in the [ crate::System ] Creates a [ CanCommunicationConnector ] in the [ EcuInstance ] that contains this [ CanCommunicationController ]. This function establishes the relationships [ CanPhysicalChannel ] -> [ CanCommunicationConnector ] [ CanCommunicationConnector ] -> [ CanCommunicationController ] connected_channels \u00b6 connected_channels() -> Iterator[CanPhysicalChannel] return an iterator over the [ CanPhysicalChannel ]s connected to this controller CanFrame \u00b6 CanFrame(element: Element) A frame on a CAN bus element instance-attribute \u00b6 element: Element length instance-attribute \u00b6 length: Optional[int] length of the frame name instance-attribute \u00b6 name: str frame_triggerings \u00b6 frame_triggerings() -> List[CanFrameTriggering] List all [ FrameTriggering ]s using this frame map_pdu \u00b6 map_pdu( pdu: Pdu, start_position: int, byte_order: ByteOrder, /, *, update_bit: Optional[int] = None, ) -> PduToFrameMapping map a PDU to the frame mapped_pdus \u00b6 mapped_pdus() -> Iterator[Pdu] returns an iterator over all PDUs in the frame CanFrameTriggering \u00b6 CanFrameTriggering(element: Element) The frame triggering connects a frame to a physical channel addressing_mode instance-attribute \u00b6 addressing_mode: Optional[CanAddressingMode] set the addressing mode for this frame triggering element instance-attribute \u00b6 element: Element frame instance-attribute \u00b6 frame: Optional[CanFrame] get the frame associated with this frame triggering frame_type instance-attribute \u00b6 frame_type: Optional[CanFrameType] frame type for this frame triggering identifier instance-attribute \u00b6 identifier: Optional[int] can id associated with this frame name instance-attribute \u00b6 name: str physical_channel instance-attribute \u00b6 physical_channel: CanPhysicalChannel get the physical channel that contains this frame triggering connect_to_ecu \u00b6 connect_to_ecu( ecu: EcuInstance, direction: CommunicationDirection ) -> FramePort connect this frame triggering to an ECU The direction parameter specifies if the communication is incoming or outgoing frame_ports \u00b6 frame_ports() -> Iterator[FramePort] iterate over all frame ports for this frame triggering pdu_triggerings \u00b6 pdu_triggerings() -> Iterator[PduTriggering] iterate over all PDU triggerings referenced by the frame triggering CanFrameType \u00b6 The type of a CAN frame Any instance-attribute \u00b6 Any: CanFrameType Can20 instance-attribute \u00b6 Can20: CanFrameType CanFd instance-attribute \u00b6 CanFd: CanFrameType CanNmCluster \u00b6 CanNmCluster(element: Element) Can specific NmCluster attributes channel_sleep_master instance-attribute \u00b6 channel_sleep_master: Optional[bool] set or remove the nmChannelSleepMaster flag communication_cluster instance-attribute \u00b6 communication_cluster: Optional[CanCluster] get or set the referenced CanCluster element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str nm_busload_reduction_active instance-attribute \u00b6 nm_busload_reduction_active: Optional[bool] nmBusloadReductionActive flag nm_immediate_nm_transmissions instance-attribute \u00b6 nm_immediate_nm_transmissions: Optional[int] nmImmediateNmTransmissions value nm_message_timeout_time instance-attribute \u00b6 nm_message_timeout_time: Optional[float] get or set the nmMessageTimeoutTime nm_msg_cycle_time instance-attribute \u00b6 nm_msg_cycle_time: Optional[float] get or set the nmMsgCycleTime nm_network_timeout instance-attribute \u00b6 nm_network_timeout: Optional[float] get or set the nmNetworkTimeout nm_remote_sleep_indication_time instance-attribute \u00b6 nm_remote_sleep_indication_time: Optional[float] get or set the nmRemoteSleepIndicationTime nm_repeat_message_time instance-attribute \u00b6 nm_repeat_message_time: Optional[float] get or set the nmRepeatMessageTime nm_wait_bus_sleep_time instance-attribute \u00b6 nm_wait_bus_sleep_time: Optional[float] get or set the nmWaitBusSleepTime node_detection_enabled instance-attribute \u00b6 node_detection_enabled: Optional[bool] get or set the nmNodeDetectionEnabled flag node_id_enabled instance-attribute \u00b6 node_id_enabled: Optional[bool] get or set the nmNodeIdEnabled flag pnc_cluster_vector_length instance-attribute \u00b6 pnc_cluster_vector_length: Optional[int] get or set the pncClusterVectorLength pnc_participation instance-attribute \u00b6 pnc_participation: Optional[bool] get or set the nmPncParticipation flag repeat_msg_ind_enabled instance-attribute \u00b6 repeat_msg_ind_enabled: Optional[bool] get or set the nmRepeatMsgIndEnabled flag synchronizing_network instance-attribute \u00b6 synchronizing_network: Optional[bool] get or set the nmSynchronizingNetwork flag create_can_nm_node \u00b6 create_can_nm_node( name: str, controller: CanCommunicationController, nm_ecu: NmEcu, ) -> CanNmNode add a CanNmNode to the cluster nm_nodes \u00b6 nm_nodes() -> Iterator[CanNmNode] iterate over all NmNodes in this cluster CanNmClusterCoupling \u00b6 CanNmClusterCoupling(element: Element) A CanNmClusterCoupling couples multiple CanNmCluster s, and contains CAN specific settings. element instance-attribute \u00b6 element: Element nm_busload_reduction_enabled instance-attribute \u00b6 nm_busload_reduction_enabled: Optional[bool] get or set the nmBusloadReductionEnabled flag nm_immediate_restart_enabled instance-attribute \u00b6 nm_immediate_restart_enabled: Optional[bool] get or set the nmImmediateRestartEnabled flag add_coupled_cluster \u00b6 add_coupled_cluster(cluster: CanNmCluster) -> None add a reference to a coupled NmCluster coupled_clusters \u00b6 coupled_clusters() -> Iterator[CanNmCluster] iterate over all coupled NmClusters CanNmClusterSettings \u00b6 CanNmClusterSettings( *, nm_busload_reduction_active: bool, nm_immediate_nm_transmissions: int, nm_message_timeout_time: float, nm_msg_cycle_time: float, nm_network_timeout: float, nm_remote_sleep_indication_time: float, nm_repeat_message_time: float, nm_wait_bus_sleep_time: float, ) Mandatory settings for a CanNmCluster These settings are mandatory for a CanNmCluster and must be set during creation. Additional optional settings can be set using the CanNmCluster methods. nm_busload_reduction_active instance-attribute \u00b6 nm_busload_reduction_active: bool nmBusloadReductionActive: Determines if bus load reduction for the respective CanNm channel is active. nm_immediate_nm_transmissions instance-attribute \u00b6 nm_immediate_nm_transmissions: int nmImmediateNmTransmissions: Defines the number of immediate NmPdus which shall be transmitted. If the value is zero no immediate NmPdus are transmitted. nm_message_timeout_time instance-attribute \u00b6 nm_message_timeout_time: float nmMessageTimeoutTime: Timeout of an NmPdu in seconds. nm_msg_cycle_time instance-attribute \u00b6 nm_msg_cycle_time: float nmMsgCycleTime: Period of a NmPdu in seconds nm_network_timeout instance-attribute \u00b6 nm_network_timeout: float nmNetworkTimeout: Network Timeout for NmPdus in seconds. nm_remote_sleep_indication_time instance-attribute \u00b6 nm_remote_sleep_indication_time: float nmRemoteSleepIndicationTime: Timeout for Remote Sleep Indication in seconds. nm_repeat_message_time instance-attribute \u00b6 nm_repeat_message_time: float nmRepeatMessageTime: Timeout for Repeat Message State in seconds. nm_wait_bus_sleep_time instance-attribute \u00b6 nm_wait_bus_sleep_time: float nmWaitBusSleepTime: Timeout for bus calm down phase in seconds. CanNmNode \u00b6 CanNmNode(element: Element) A CanNmNode represents a node in a CanNmCluster . The node connects to a CanCommunicationController and an NmEcu . communication_controller instance-attribute \u00b6 communication_controller: Optional[ CanCommunicationController ] get or set the referenced CanCommunicationController element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str nm_ecu instance-attribute \u00b6 nm_ecu: Optional[NmEcu] get or set the referenced NmEcu node_id instance-attribute \u00b6 node_id: Optional[int] get or set the nmNodeId This value is optional; if it is set to Some(x) the value is created, if it is set to None the value is removed. passive_mode instance-attribute \u00b6 passive_mode: Optional[bool] get or set ot remove the nmPassiveModeEnabled flag This flag is optional; if it is set to Some(x) the value is created, if it is set to None the value is removed. add_rx_nm_pdu \u00b6 add_rx_nm_pdu(nm_pdu: NmPdu) -> None add an Rx NmPdu Every NmNode must have at least one Rx NmPdu add_tx_nm_pdu \u00b6 add_tx_nm_pdu(nm_pdu: NmPdu) -> None add a Tx NmPdu Active NmNodes must have at least one Tx NmPdu , while passive NmNodes may have none. rx_nm_pdus \u00b6 rx_nm_pdus() -> Iterator[NmPdu] iterate over all RX NmPdus tx_nm_pdus \u00b6 tx_nm_pdus() -> Iterator[NmPdu] iterate over all TX NmPdus CanPhysicalChannel \u00b6 CanPhysicalChannel(element: Element) The `CanPhysicalChannel contains all of the communication on a CAN network cluster instance-attribute \u00b6 cluster: CanCluster get the cluster containing this physical channel element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str frame_triggerings \u00b6 frame_triggerings() -> Iterator[CanFrameTriggering] iterate over all frame triggerings of this physical channel pdu_triggerings \u00b6 pdu_triggerings() -> Iterator[PduTriggering] iterate over all PDU triggerings of this physical channel signal_triggerings \u00b6 signal_triggerings() -> Iterator[ISignalTriggering] iterate over all signal triggerings of this physical channel trigger_frame \u00b6 trigger_frame( frame: CanFrame, identifier: int, addressing_mode: CanAddressingMode, frame_type: CanFrameType, ) -> CanFrameTriggering add a trigger for a CAN frame in this physical channel CanTpAddress \u00b6 CanTpAddress(element: Element) A CanTpAddress represents a logical address in the CanTp module element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str tp_address instance-attribute \u00b6 tp_address: Optional[int] get or set the address of the CanTpAddress CanTpAddressingFormat \u00b6 The addressing format of a CanTpConnection Extended instance-attribute \u00b6 Extended: CanTpAddressingFormat Mixed instance-attribute \u00b6 Mixed: CanTpAddressingFormat Mixed29Bit instance-attribute \u00b6 Mixed29Bit: CanTpAddressingFormat NormalFixed instance-attribute \u00b6 NormalFixed: CanTpAddressingFormat Standard instance-attribute \u00b6 Standard: CanTpAddressingFormat CanTpChannel \u00b6 CanTpChannel(element: Element) A CanTpChannel represents a channel in the CanTp module channel_id instance-attribute \u00b6 channel_id: Optional[int] get or set the channel id of the channel channel_mode instance-attribute \u00b6 channel_mode: Optional[CanTpChannelMode] get or set the channel mode of the channel element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str CanTpChannelMode \u00b6 The mode of a CanTpChannel FullDuplex instance-attribute \u00b6 FullDuplex: CanTpChannelMode HalfDuplex instance-attribute \u00b6 HalfDuplex: CanTpChannelMode CanTpConfig \u00b6 CanTpConfig(element: Element) Container for CanTp configuration There should be one CanTpConfig for each CAN network in the system cluster instance-attribute \u00b6 cluster: Optional[CanCluster] get or set the CanCluster associated with this configuration element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str can_tp_addresses \u00b6 can_tp_addresses() -> Iterator[CanTpAddress] get all of the Can Tp addresses in the configuration can_tp_channels \u00b6 can_tp_channels() -> Iterator[CanTpChannel] iterate over all CanTpChannel s in the configuration can_tp_connections \u00b6 can_tp_connections() -> Iterator[CanTpConnection] get all of the CanTpConnections in the configuration can_tp_ecus \u00b6 can_tp_ecus() -> Iterator[CanTpEcu] get an iterator over all ECUs in the configuration can_tp_nodes \u00b6 can_tp_nodes() -> Iterator[CanTpNode] get all of the CanTpNodes in the configuration create_can_tp_address \u00b6 create_can_tp_address( name: str, address: int ) -> CanTpAddress create a new CanTpAddress in the configuration create_can_tp_channel \u00b6 create_can_tp_channel( name: str, channel_id: int, mode: CanTpChannelMode ) -> CanTpChannel create a new CanTpChannel in the configuration create_can_tp_connection \u00b6 create_can_tp_connection( name: Optional[str], addressing_format: CanTpAddressingFormat, can_tp_channel: CanTpChannel, data_pdu: NPdu, tp_sdu: IPdu, padding_activation: bool, ) -> CanTpConnection create a new CanTpConnection in the configuration create_can_tp_ecu \u00b6 create_can_tp_ecu( ecu_instance: EcuInstance, /, *, cycle_time_main_function: Optional[float] = None, ) -> CanTpEcu create a CanTp ECU in the configuration create_can_tp_node \u00b6 create_can_tp_node(name: str) -> CanTpNode create a new CanTpNode in the configuration CanTpConnection \u00b6 CanTpConnection(element: Element) A connection identifies the sender and the receiver of this particular communication. The CanTp module routes a Pdu through this connection. addressing_format instance-attribute \u00b6 addressing_format: Optional[CanTpAddressingFormat] get or set the addressing format of the connection channel instance-attribute \u00b6 channel: Optional[CanTpChannel] get or set the CanTpChannel associated with this connection data_pdu instance-attribute \u00b6 data_pdu: Optional[NPdu] get or set the NPdu associated with this connection element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str padding_activation instance-attribute \u00b6 padding_activation: Optional[bool] get or set the padding activation of the connection tp_sdu instance-attribute \u00b6 tp_sdu: Optional[IPdu] get or set the IPdu associated with this connection transmitter instance-attribute \u00b6 transmitter: Optional[CanTpNode] set the transmitter of the connection This is a CanTpNode representing an ECU that will send the data add_receiver \u00b6 add_receiver(receiver: CanTpNode) -> None add a receiver to the connection This is a CanTpNode representing an ECU that will receive the data receivers \u00b6 receivers() -> Iterator[CanTpNode] get all of the receivers of the connection CanTpEcu \u00b6 CanTpEcu(element: Element) A CanTpEcu represents an ECU that is using the CanTp module cycle_time_main_function instance-attribute \u00b6 cycle_time_main_function: Optional[float] get or set the cycle time of the CanTp main function of the ECU ecu_instance instance-attribute \u00b6 ecu_instance: Optional[EcuInstance] get or set the ECU instance of the CanTpEcu element instance-attribute \u00b6 element: Element CanTpNode \u00b6 CanTpNode(element: Element) A CanTpNode provides the TP address and the connection to the topology description in a CanTpConfig address instance-attribute \u00b6 address: Optional[CanTpAddress] get or set the CanTpAddress of this Node connector instance-attribute \u00b6 connector: Optional[CanCommunicationConnector] set the reference to a CanCommunicationConnector between an EcuInstance and a CanPhysicalChannel The connector connects the ECU to the physical channel, so by setting this reference, the ECU is also connected to the CanTpNode element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str ComTransformationTechnologyConfig \u00b6 ComTransformationTechnologyConfig( *, isignal_ipdu_length: int ) Configuration for a COM transformation isignal_ipdu_length instance-attribute \u00b6 isignal_ipdu_length: int The length of the ISignalIpdu tha will be transformed by this Com transformer. The value is only used up to AUTOSAR R20-11 ( AUTOSAR_00049 ), where it is needed to calculate the buffer size. CommonServiceDiscoveryConfig \u00b6 CommonServiceDiscoveryConfig( *, multicast_rx_socket: SocketAddress, multicast_rx_pdu: GeneralPurposePdu, remote_socket: SocketAddress, prefer_static_socket_connections: bool, ipdu_identifier_set: Optional[ SocketConnectionIpduIdentifierSet ] = None, name_prefix: Optional[str] = None, ) A CommonServiceDiscoveryConfig contains common configuration settings for System::configure_service_discovery_for_ecu . This struct contains ECU-independent settings that should be re-used for all ECUs that are configured for SD. ipdu_identifier_set instance-attribute \u00b6 ipdu_identifier_set: Optional[ SocketConnectionIpduIdentifierSet ] an ipdu identifier set in which PduTriggerings are created. Only needed for StaticSocketConnections . multicast_rx_pdu instance-attribute \u00b6 multicast_rx_pdu: GeneralPurposeIPdu the multicast rx PDU used by all SD ECUs multicast_rx_socket instance-attribute \u00b6 multicast_rx_socket: SocketAddress the socket address used for multicast rx by all SD ECUs name_prefix instance-attribute \u00b6 name_prefix: Optional[str] an optional prefix for the names of the created elements prefer_static_socket_connections instance-attribute \u00b6 prefer_static_socket_connections: bool configure_service_discovery_for_ecu checks if any SocketConnectionBundles exist. If so, the old configuration method must be used. If none are found and the version is new enough, both methods are possible, and this flag determines which one to use. remote_socket instance-attribute \u00b6 remote_socket: SocketAddress the remote socket used for SD communication. This socket must have an IP address (v4 or v6) set to ANY. CommunicationDirection \u00b6 The [ CommunicationDirection ] is used by the communication ports for frames, PDUs and signals In instance-attribute \u00b6 In: CommunicationDirection Out instance-attribute \u00b6 Out: CommunicationDirection ConsumedEventGroup \u00b6 ConsumedEventGroup(element: Element) A ConsumedEventGroup is a group of events in a ConsumedServiceInstance that are consumed by an ECU element instance-attribute \u00b6 element: Element event_group_identifier instance-attribute \u00b6 event_group_identifier: Optional[int] get or set the event group identifier of this ConsumedEventGroup name instance-attribute \u00b6 name: str sd_client_timer_config instance-attribute \u00b6 sd_client_timer_config: Optional[ SomeipSdClientEventGroupTimingConfig ] get or set the SD client timer configuration for this ConsumedEventGroup add_event_multicast_address \u00b6 add_event_multicast_address(address: SocketAddress) -> None add an event multicast address to this ConsumedEventGroup create_pdu_activation_routing_group \u00b6 create_pdu_activation_routing_group( name: str, event_group_control_type: EventGroupControlType, ) -> PduActivationRoutingGroup create a new PduActivationRoutingGroup in this ConsumedEventGroup event_multicast_addresses \u00b6 event_multicast_addresses() -> Iterator[SocketAddress] get the event multicast addresses pdu_activation_routing_groups \u00b6 pdu_activation_routing_groups() -> Iterator[ PduActivationRoutingGroup ] iterate over the PduActivationRoutingGroup s in this ConsumedEventGroup ConsumedEventGroupV1 \u00b6 ConsumedEventGroupV1(element: Element) A ConsumedEventGroupV1 is a SD event group of a service instance that is consumed by this ECU. This is the old V1 version of the service definition. application_endpoint instance-attribute \u00b6 application_endpoint: Optional[SocketAddress] set the SocketAddress that receives events from this ConsumedEventGroup This may be a different SocketAddress than the one that is used to send requests. element instance-attribute \u00b6 element: Element event_group_identifier instance-attribute \u00b6 event_group_identifier: Optional[int] get or set the event group identifier of this ConsumedEventGroup name instance-attribute \u00b6 name: str sd_client_config instance-attribute \u00b6 sd_client_config: Optional[SdEventConfig] get or set the SD client configuration for this ConsumedEventGroup add_routing_group \u00b6 add_routing_group(routing_group: SoAdRoutingGroup) -> None add a reference to a SoAdRoutingGroup to this ConsumedEventGroup event_handlers \u00b6 event_handlers() -> List[EventHandlerV1] list all EventHandlerV1 s that reference this ConsumedEventGroupV1 routing_groups \u00b6 routing_groups() -> Iterator[SoAdRoutingGroup] get the routing groups referenced by this ConsumedEventGroup ConsumedServiceInstance \u00b6 ConsumedServiceInstance(element: Element) A ConsumedServiceInstance is a service that is consumed by an ECU element instance-attribute \u00b6 element: Element instance_identifier instance-attribute \u00b6 instance_identifier: Optional[int] get or set the instance identifier of this ConsumedServiceInstance major_version instance-attribute \u00b6 major_version: Optional[int] get or set the major version of this ConsumedServiceInstance minor_version instance-attribute \u00b6 minor_version: Optional[Union[int, str]] get or set the minor version of this ConsumedServiceInstance The minor version can be a number or the String \"ANY\". name instance-attribute \u00b6 name: str sd_client_instance_config instance-attribute \u00b6 sd_client_instance_config: Optional[ SomeipSdClientServiceInstanceConfig ] get or set the SD client instance configuration for this ConsumedServiceInstance service_identifier instance-attribute \u00b6 service_identifier: Optional[int] get or set the service identifier of this ConsumedServiceInstance consumed_event_groups \u00b6 consumed_event_groups() -> Iterator[ConsumedEventGroup] get the ConsumedEventGroup s in this ConsumedServiceInstance create_consumed_event_group \u00b6 create_consumed_event_group( name: str, event_group_identifier: int ) -> ConsumedEventGroup create a new ConsumedEventGrup in this ConsumedServiceInstance local_unicast_addresses \u00b6 local_unicast_addresses() -> Iterator[SocketAddress] iterate over the local unicast addresses set_local_unicast_address \u00b6 set_local_unicast_address(address: SocketAddress) -> None set a local unicast address for this ConsumedServiceInstance The CSI may use two local unicast addresses, one each for UDP and TCP. If the consumed service instance does not specify a local unicast address because it only receives multicast messages, then the ConsumedEventGroup must have an eventMulticastAddress. ConsumedServiceInstanceV1 \u00b6 ConsumedServiceInstanceV1(element: Element) A ConsumedServiceInstanceV1 is a SD service instance that is consumed by this ECU. This is the old V1 version of the service definition. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str provided_service_instance instance-attribute \u00b6 provided_service_instance: Optional[ ProvidedServiceInstanceV1 ] get the ProvidedServiceInstanceV1 referenced by this ConsumedServiceInstanceV1 consumed_event_groups \u00b6 consumed_event_groups() -> Iterator[ConsumedEventGroupV1] get the ConsumedEventGroup s in this ConsumedServiceInstanceV1 create_consumed_event_group \u00b6 create_consumed_event_group( name: str, event_group_identifier: int, event_handler: EventHandlerV1, ) -> ConsumedEventGroupV1 create a new ConsumedEventGroupV1 in this ConsumedServiceInstanceV1 sd_client_config \u00b6 sd_client_config() -> Optional[SdConfig] get the SD client configuration for this ConsumedServiceInstanceV1 set_sd_client_config \u00b6 set_sd_client_config(sd_client_config: SdConfig) -> None set the SD client configuration for this ConsumedServiceInstanceV1 ContainedIPduCollectionSemantics \u00b6 collection semantics for the ContainedIPdu LastIsBest instance-attribute \u00b6 LastIsBest: ContainedIPduCollectionSemantics Queued instance-attribute \u00b6 Queued: ContainedIPduCollectionSemantics ContainedIPduProps \u00b6 ContainedIPduProps( *, collection_semantics: Optional[ ContainedIPduCollectionSemantics ] = None, header_id_long: Optional[int] = None, header_id_short: Optional[int] = None, offset: Optional[int] = None, priority: Optional[int] = None, timeout: Optional[float] = None, trigger: Optional[PduCollectionTrigger] = None, update_indication_bit_position: Optional[int] = None, ) Properties for an IPdu that is transmitted in a container IPdu collection_semantics instance-attribute \u00b6 collection_semantics: Optional[ ContainedIPduCollectionSemantics ] collection semantics: LastIsBest or Queued header_id_long instance-attribute \u00b6 header_id_long: Optional[int] header id of the contained IPdu, used when the header type is LongHeader header_id_short instance-attribute \u00b6 header_id_short: Optional[int] header id of the contained IPdu, used when the header type is ShortHeader offset instance-attribute \u00b6 offset: Optional[int] offset of the contained IPdu in the container IPdu, used when the header type is NoHeader priority instance-attribute \u00b6 priority: Optional[int] priority of the contained IPdu. 255: lowest, 0: highest timeout instance-attribute \u00b6 timeout: Optional[float] sender timeout. Ignored on the receiver side trigger instance-attribute \u00b6 trigger: Optional[PduCollectionTrigger] defines whether the contained IPdu triggers transmission of the container IPdu update_indication_bit_position instance-attribute \u00b6 update_indication_bit_position: Optional[int] update indication bit position of the contained IPdu ContainerIPdu \u00b6 ContainerIPdu(element: Element) Several IPdus can be collected in one ContainerIPdu based on the headerType contained_ipdu_props instance-attribute \u00b6 contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu container_timeout instance-attribute \u00b6 container_timeout: Optional[float] container_trigger instance-attribute \u00b6 container_trigger: Optional[ContainerIPduTrigger] get or set the container trigger of this ContainerIPdu element instance-attribute \u00b6 element: Element header_type instance-attribute \u00b6 header_type: ContainerIPduHeaderType length instance-attribute \u00b6 length: Optional[int] get or set the length of this PDU name instance-attribute \u00b6 name: str rx_accept_contained_ipdu instance-attribute \u00b6 rx_accept_contained_ipdu: Optional[RxAcceptContainedIPdu] get or set the rx accept of this ContainerIPdu contained_ipdu_triggerings \u00b6 contained_ipdu_triggerings() -> Iterator[PduTriggering] iterate over all contained IPdu triggerings map_ipdu \u00b6 map_ipdu( ipdu: IPdu, physical_channel: PhysicalChannel ) -> PduTriggering map an IPdu to this ContainerIPdu and create a PduTriggering for it in the PhysicalChannel pdu_triggerings \u00b6 pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU ContainerIPduHeaderType \u00b6 The header type of a ContainerIPdu LongHeader instance-attribute \u00b6 LongHeader: ContainerIPduHeaderType NoHeader instance-attribute \u00b6 NoHeader: ContainerIPduHeaderType ShortHeader instance-attribute \u00b6 ShortHeader: ContainerIPduHeaderType ContainerIPduTrigger \u00b6 Defines when the transmission of the ContainerIPdu shall be requested DefaultTrigger instance-attribute \u00b6 DefaultTrigger: ContainerIPduTrigger FirstContainedTrigger instance-attribute \u00b6 FirstContainedTrigger: ContainerIPduTrigger CycleRepetition \u00b6 The cycle repetition of a Flexray frame, from the Flexray standard C1 instance-attribute \u00b6 C1: CycleRepetition C10 instance-attribute \u00b6 C10: CycleRepetition C16 instance-attribute \u00b6 C16: CycleRepetition C2 instance-attribute \u00b6 C2: CycleRepetition C20 instance-attribute \u00b6 C20: CycleRepetition C32 instance-attribute \u00b6 C32: CycleRepetition C4 instance-attribute \u00b6 C4: CycleRepetition C40 instance-attribute \u00b6 C40: CycleRepetition C5 instance-attribute \u00b6 C5: CycleRepetition C50 instance-attribute \u00b6 C50: CycleRepetition C64 instance-attribute \u00b6 C64: CycleRepetition C8 instance-attribute \u00b6 C8: CycleRepetition CyclicTiming \u00b6 CyclicTiming( time_period: float, /, *, time_offset: Optional[float] = None, ) Cyclic timing parameters for an IPDU time_offset instance-attribute \u00b6 time_offset: Optional[float] delay until the first transmission of the PDU in seconds time_period instance-attribute \u00b6 time_period: float period of repetition in seconds DataIdMode \u00b6 data ID modes for E2E profiles 01 and 11 All16Bit instance-attribute \u00b6 All16Bit: DataIdMode Alternating8Bit instance-attribute \u00b6 Alternating8Bit: DataIdMode Lower12Bit instance-attribute \u00b6 Lower12Bit: DataIdMode Lower8Bit instance-attribute \u00b6 Lower8Bit: DataIdMode DataTransformation \u00b6 DataTransformation(element: Element) A DataTransformation is a chain of TransformationTechnology s that are used to transform data data_transformation_set instance-attribute \u00b6 data_transformation_set: Optional[DataTransformationSet] get the DataTransformationSet that contains this DataTransformation element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str transformation_technologies \u00b6 transformation_technologies() -> Iterator[ TransformationTechnology ] Create an iterator over the TransformationTechnologies in the DataTransformation DataTransformationSet \u00b6 DataTransformationSet(element: Element) A [ DataTransformationSet ] contains DataTransformation s and TransformationTechnology s used in communication Use [ ArPackage::create_data_transformation_set ] to create a new DataTransformationSet element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_data_transformation \u00b6 create_data_transformation( name: str, transformations: List[TransformationTechnology], execute_despite_data_unavailability: bool, ) -> DataTransformation Create a new DataTransformation in the DataTransformationSet create_transformation_technology \u00b6 create_transformation_technology( name: str, config: TransformationTechnologyConfig ) -> TransformationTechnology Create a new TransformationTechnology in the DataTransformationSet data_transformations \u00b6 data_transformations() -> Iterator[DataTransformation] Iterate over all DataTransformation s in the DataTransformationSet transformation_technologies \u00b6 transformation_technologies() -> Iterator[ TransformationTechnology ] Iterate over all TransformationTechnology s in the DataTransformationSet DcmIPdu \u00b6 DcmIPdu(element: Element) Represents the IPdus handled by Dcm contained_ipdu_props instance-attribute \u00b6 contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu element instance-attribute \u00b6 element: Element length instance-attribute \u00b6 length: Optional[int] get or set the length of this PDU name instance-attribute \u00b6 name: str pdu_triggerings \u00b6 pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU DoIpLogicAddress \u00b6 DoIpLogicAddress(element: Element) This element defines the logical address of a DoIp connection address instance-attribute \u00b6 address: Optional[int] get or set the address of this DoIpLogicAddress element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str DoIpTpConfig \u00b6 DoIpTpConfig(element: Element) Container for DoIp TP configuration cluster instance-attribute \u00b6 cluster: Optional[EthernetCluster] get or set the reference to the EthernetCluster for this DoIpTpConfig element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_doip_logic_address \u00b6 create_doip_logic_address( name: str, address: int ) -> DoIpLogicAddress create a new DoIpLogicAddress create_doip_tp_connection \u00b6 create_doip_tp_connection( name: Optional[str], source: DoIpLogicAddress, target: DoIpLogicAddress, tp_sdu_triggering: PduTriggering, ) -> DoIpTpConnection create a new DoIpTpConnection doip_logic_addresses \u00b6 doip_logic_addresses() -> Iterator[DoIpLogicAddress] iterate over all DoIpLogicAddresss doip_tp_connections \u00b6 doip_tp_connections() -> Iterator[DoIpTpConnection] iterate over all DoIpTpConnections DoIpTpConnection \u00b6 DoIpTpConnection(element: Element) The DoIpTpConnection defines a DoIp transport protocol connection element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str source instance-attribute \u00b6 source: Optional[DoIpLogicAddress] get or set the source DoIpLogicAddress target instance-attribute \u00b6 target: Optional[DoIpLogicAddress] get or set the target DoIpLogicAddress tp_sdu_triggering instance-attribute \u00b6 tp_sdu_triggering: Optional[PduTriggering] get or set the PduTriggering for this connection E2EProfile \u00b6 enumeration of the possible E2E profiles P01 instance-attribute \u00b6 P01: E2EProfile P02 instance-attribute \u00b6 P02: E2EProfile P04 instance-attribute \u00b6 P04: E2EProfile P04m instance-attribute \u00b6 P04m: E2EProfile P05 instance-attribute \u00b6 P05: E2EProfile P06 instance-attribute \u00b6 P06: E2EProfile P07 instance-attribute \u00b6 P07: E2EProfile P07m instance-attribute \u00b6 P07m: E2EProfile P08 instance-attribute \u00b6 P08: E2EProfile P08m instance-attribute \u00b6 P08m: E2EProfile P11 instance-attribute \u00b6 P11: E2EProfile P22 instance-attribute \u00b6 P22: E2EProfile P44 instance-attribute \u00b6 P44: E2EProfile P44m instance-attribute \u00b6 P44m: E2EProfile E2EProfileBehavior \u00b6 there are two standardized behaviors for E2E profiles, which can be selected for each E2E transformation PreR4_2 instance-attribute \u00b6 PreR4_2: E2EProfileBehavior R4_2 instance-attribute \u00b6 R4_2: E2EProfileBehavior E2ETransformationTechnologyConfig \u00b6 E2ETransformationTechnologyConfig( *, profile: E2EProfile, zero_header_length: bool, transform_in_place: bool, offset: int, max_delta_counter: int, max_error_state_init: int, max_error_state_invalid: int, max_error_state_valid: int, max_no_new_or_repeated_data: int, min_ok_state_init: int, min_ok_state_invalid: int, min_ok_state_valid: int, window_size: int, window_size_init: Optional[int] = None, window_size_invalid: Optional[int] = None, window_size_valid: Optional[int] = None, profile_behavior: Optional[E2EProfileBehavior] = None, sync_counter_init: Optional[int] = None, data_id_mode: Optional[DataIdMode] = None, data_id_nibble_offset: Optional[int] = None, crc_offset: Optional[int] = None, counter_offset: Optional[int] = None, ) Configuration for an E2E transformation counter_offset instance-attribute \u00b6 counter_offset: Optional[int] Offset of the counter in the Data[] array in bits. Required for E2E profiles 01 and 11, unused otherwise crc_offset instance-attribute \u00b6 crc_offset: Optional[int] Offset of the crc in the Data[] array in bits. Required for E2E profiles 01 and 11, unused otherwise data_id_mode instance-attribute \u00b6 data_id_mode: Optional[DataIdMode] The data ID mode to use; required for E2E profiles 01 and 11, unused otherwise data_id_nibble_offset instance-attribute \u00b6 data_id_nibble_offset: Optional[int] Offset of the data ID in the Data[] array in bits. Required for E2E profiles 01 and 11 when data_id_mode is Lower12Bit , unused otherwise max_delta_counter instance-attribute \u00b6 max_delta_counter: int Maximum jump in the counter value between two consecutive messages max_error_state_init instance-attribute \u00b6 max_error_state_init: int The maximum allowed number of consecutive failed counter checks in the init state max_error_state_invalid instance-attribute \u00b6 max_error_state_invalid: int The maximum allowed number of consecutive failed counter checks in the invalid state max_error_state_valid instance-attribute \u00b6 max_error_state_valid: int The maximum allowed number of consecutive failed counter checks in the valid state max_no_new_or_repeated_data instance-attribute \u00b6 max_no_new_or_repeated_data: int The maximum allowed number of consecutive failed counter checks min_ok_state_init instance-attribute \u00b6 min_ok_state_init: int The minimum allowed number of consecutive successful counter checks in the init state min_ok_state_invalid instance-attribute \u00b6 min_ok_state_invalid: int The minimum allowed number of consecutive successful counter checks in the invalid state min_ok_state_valid instance-attribute \u00b6 min_ok_state_valid: int The minimum allowed number of consecutive successful counter checks in the valid state offset instance-attribute \u00b6 offset: int The offset in bits from the start of the buffer where the E2E data should be placed If E2E is used after COM, the offset should be 0; if E2E is used after SOMEIP, the offset should be 64 profile instance-attribute \u00b6 profile: E2EProfile E2E profile to use profile_behavior instance-attribute \u00b6 profile_behavior: Optional[E2EProfileBehavior] Behavior of the check functionality sync_counter_init instance-attribute \u00b6 sync_counter_init: Optional[int] Number of successful checks required for validating the consistency of the counter transform_in_place instance-attribute \u00b6 transform_in_place: bool Should the E2E transformation take place in the existing buffer or in a separate buffer? window_size instance-attribute \u00b6 window_size: int window size: Size of the monitoring window for the E2E state machine. This can be directly set up to AUTOSAR 4.4.0 ( AUTOSAR_00047 ). For newer files this only provides the default if window_size_init , window_size_invalid and window_size_valid are not set window_size_init instance-attribute \u00b6 window_size_init: Optional[int] window size in the init state - only valid in AUTOSAR 4.5.0 ( AUTOSAR_00048 ) and newer. if it is not set, this will default to window_size window_size_invalid instance-attribute \u00b6 window_size_invalid: Optional[int] window size in the invalid state - only valid in AUTOSAR 4.5.0 ( AUTOSAR_00048 ) and newer. if it is not set, this will default to window_size window_size_valid instance-attribute \u00b6 window_size_valid: Optional[int] window size in the valid state - only valid in AUTOSAR 4.5.0 ( AUTOSAR_00048 ) and newer. if it is not set, this will default to window_size zero_header_length instance-attribute \u00b6 zero_header_length: bool When E2E is used in a transformer chain after COM, the header length must be zero. In this configuration you are expected to provide space for the E2E data inside the signal group layout, and zero_header_length should be set to true. If zero_header_length is set to false, the appropriate header length for the chosen E2E profile will be used (e.g. 24 bits for PROFILE_05 ) EndToEndTransformationISignalProps \u00b6 EndToEndTransformationISignalProps(element: Element) Properties for the End to End transformation of an ISignal(Group) data_ids instance-attribute \u00b6 data_ids: List[int] get or set the data IDs that are used for the E2E transformation data_length instance-attribute \u00b6 data_length: Optional[int] get or set the length of payload and E2E header in bits element instance-attribute \u00b6 element: Element max_data_length instance-attribute \u00b6 max_data_length: Optional[int] get or set the maximum data length min_data_length instance-attribute \u00b6 min_data_length: Optional[int] get or set the minimum data length source_id instance-attribute \u00b6 source_id: Optional[int] get or set the source ID transformer instance-attribute \u00b6 transformer: Optional[TransformationTechnology] get or set the transformer reference of the E2E transformation properties EthernetCluster \u00b6 EthernetCluster(element: Element) An EthernetCluster contains all configuration items associated with an ethernet network. The cluster connects multiple ECUs. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str system instance-attribute \u00b6 system: Optional[System] get the System that this EthernetCluster is part of create_physical_channel \u00b6 create_physical_channel( channel_name: str, /, *, vlan_info: Optional[EthernetVlanInfo] = None, ) -> EthernetPhysicalChannel Create a new physical channel for the cluster The supplied VLAN info must be unique - there cannot be two VLANs with the same vlan identifier. One channel may be created without VLAN information; it carries untagged traffic. physical_channels \u00b6 physical_channels() -> Iterator[EthernetPhysicalChannel] returns an iterator over all [ EthernetPhysicalChannel ]s in the cluster EthernetCommunicationConnector \u00b6 EthernetCommunicationConnector(element: Element) A connector between an [ EthernetCommunicationController ] in an ECU and an [ EthernetPhysicalChannel ] controller instance-attribute \u00b6 controller: EthernetCommunicationController Get the controller of the CommunicationConnector ecu_instance instance-attribute \u00b6 ecu_instance: EcuInstance Get the EcuInstance that contains this CommunicationConnector element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str EthernetCommunicationController \u00b6 EthernetCommunicationController(element: Element) An EcuInstance needs an EthernetCommunicationController in order to connect to an ethernet cluster. ecu_instance instance-attribute \u00b6 ecu_instance: EcuInstance Get the EcuInstance that contains this EthernetCommunicationController element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str connect_physical_channel \u00b6 connect_physical_channel( connection_name: str, eth_channel: EthernetPhysicalChannel, ) -> EthernetCommunicationConnector Connect this [ EthernetCommunicationController ] inside an [ EcuInstance ] to an [ EthernetPhysicalChannel ] in the [ crate::System ] Creates an EthernetCommunicationConnector in the [ EcuInstance ] that contains this [ EthernetCommunicationController ]. This function establishes the relationships [ EthernetPhysicalChannel ] -> EthernetCommunicationConnector EthernetCommunicationConnector -> [ EthernetCommunicationController ] connected_channels \u00b6 connected_channels() -> Iterator[EthernetPhysicalChannel] return an iterator over the [ EthernetPhysicalChannel ]s connected to this controller EthernetPhysicalChannel \u00b6 EthernetPhysicalChannel(element: Element) The EthernetPhysicalChannel represents a VLAN or untagged traffic cluster instance-attribute \u00b6 cluster: EthernetCluster get the cluster containing this physical channel element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str configure_service_discovery_for_ecu \u00b6 configure_service_discovery_for_ecu( ecu: EcuInstance, unicast_socket: SocketAddress, unicast_rx_pdu: GeneralPurposePdu, unicast_tx_pdu: GeneralPurposePdu, common_config: CommonServiceDiscoveryConfig, ) -> None configure SOME/IP service discovery (SD) for an ECU connected to this channel SD is used to broadcast service offers on the network and subscribe to services offered by other ECUs. This function configures the ECU to use the SOME/IP SD protocol. SD uses either socket connection bundles or static socket connections to communicate. ecu is the ECU that should be configured for SD. unicast_socket is the socket address used for unicast rx/tx communication by the ECU. unicast_rx_pdu and unicast_tx_pdu are the GeneralPurposePdus used for the unicast communication. common_config contains common configuration settings that can be used for all SD ECUs. - multicast_rx_socket is the socket address used for multicast communication by all SD ECUs. - remote_socket is a socket whose IP is set to ANY with UDP port 0, acting as the remote address in the SD communication. - name_prefix is an optional prefix for the names of the created elements. - prefer_static_socket_connections is a flag that determines if SocketConnectionBundles should be used instead of StaticSocketConnections . This is only relevant if the type can't be detected automatically. - ipdu_identifier_set is contains the IPduIdentifiers that are used in StaticSocketConnections . Note: Usually SomeIP SD is expected to use port 30490, but this is not mandatory. The port number is set in the sockets, and must be the same for all SD sockets. create_network_endpoint \u00b6 create_network_endpoint( name: str, address: NetworkEndpointAddress, /, *, ecu: Optional[EcuInstance] = None, ) -> NetworkEndpoint create a network endpoint - IPv4 or IPv6 address - for this channel In older versions of the Autosar standard, up to version 4.4.0, the NetworkEndpoint could be linked to an Ecu. The parameter ecu specifies the target. The link is obsoleted in newer versions, and will only be created if the file version allows it. create_socket_address \u00b6 create_socket_address( name: str, network_endpoint: NetworkEndpoint, tp_config: TpConfig, sa_type: SocketAddressType, ) -> SocketAddress create a socket address in the ethernet channel It contains the settings of the TCP/UDP port and links to a [ NetworkEndpoint ] which contains the IP address. The socket address can either be a unicast adress which is associated with a single ECU, or a multicast address create_socket_connection_bundle \u00b6 create_socket_connection_bundle( name: str, server_port: SocketAddress ) -> SocketConnectionBundle create a socket connection bundle The SocketConnectionBundle is the \"old\" way to establish a connection between two sockets. It is deprecated in newer versions of the Autosar standard, but remains available for compatibility. create_static_socket_connection_pair \u00b6 create_static_socket_connection_pair( name: str, port_1: SocketAddress, port_2: SocketAddress, /, *, tcp_connect_timeout: Optional[float] = None, ) -> Tuple[StaticSocketConnection, StaticSocketConnection] create a pair of static socket connections Static socket connections are usually created as a pair, one on each socket involved on the connection. This helper function creates both at once. To create a single connection, use [ SocketAddress::create_static_socket_connection ]. If the connection is a TCP connection, the first port connects to the second port, and the second port listens for incoming connection. The ordering of port_1 and port_2 has no impact on the direction of the transported PDUs. This is defined in the PduTriggering . StaticSocketConnection s are the \"new\" way to establish a connection between two sockets. It was introduced in Autosar 4.5.0 ( AUTOSAR_00048 ) and is the recommended way to create connections. SocketConnectionBundles (old) and StaticSocketConnections (new) may never be used in the same file. has_socket_connections \u00b6 has_socket_connections() -> bool check if the channel contains any SocketConnectionBundles (old) or SocketConnections (very old) network_endpoints \u00b6 network_endpoints() -> Iterator[NetworkEndpoint] create an iterator over all [ NetworkEndpoint ]s in this channel pdu_triggerings \u00b6 pdu_triggerings() -> Iterator[PduTriggering] iterate over all PDU triggerings of this physical channel set_vlan_info \u00b6 set_vlan_info( vlan_info: Optional[EthernetVlanInfo], ) -> None get or set the VLAN information of the channel. In an EthernetCluster, each physical channel must have unique VLAN settings; only one channel can omit VLAN information - it carries untagged traffic. Setting duplicate VLAN information will result in an error. signal_triggerings \u00b6 signal_triggerings() -> Iterator[ISignalTriggering] iterate over all signal triggerings of this physical channel socket_addresses \u00b6 socket_addresses() -> Iterator[SocketAddress] create an iterator over all [ SocketAddress ]es in this channel socket_connection_bundles \u00b6 socket_connection_bundles() -> Iterator[ SocketConnectionBundle ] iterate over all socket connection bundles in this channel The SocketConnectionBundle is the \"old\" way to establish a connection between two sockets. It is deprecated in newer versions of the Autosar standard, but remains available for compatibility. vlan_info \u00b6 vlan_info() -> Optional[EthernetVlanInfo] get or set the VLAN information of the channel. In an EthernetCluster, each physical channel must have unique VLAN settings; only one channel can omit VLAN information - it carries untagged traffic. Setting duplicate VLAN information will result in an error. EthernetVlanInfo \u00b6 EthernetVlanInfo(*, vlan_name: str, vlan_id: int) Provides information about the VLAN of an [ EthernetPhysicalChannel ] vlan_id instance-attribute \u00b6 vlan_id: int vlan_name instance-attribute \u00b6 vlan_name: str EventControlledTiming \u00b6 EventControlledTiming( number_of_repetitions: int, /, *, repetition_period: Optional[float] = None, ) Event controlled timing parameters for an IPDU number_of_repetitions instance-attribute \u00b6 number_of_repetitions: int The PDU will be sent (number of repetitions + 1) times. If number of repetitions is 0, then the PDU is sent exactly once. repetition_period instance-attribute \u00b6 repetition_period: Optional[float] time in seconds between two transmissions of the PDU EventGroupControlType \u00b6 control types used in routing groups for SOME/IP events ActivationAndTriggerUnicast instance-attribute \u00b6 ActivationAndTriggerUnicast: EventGroupControlType ActivationMulticast instance-attribute \u00b6 ActivationMulticast: EventGroupControlType ActivationUnicast instance-attribute \u00b6 ActivationUnicast: EventGroupControlType TriggerUnicast instance-attribute \u00b6 TriggerUnicast: EventGroupControlType EventHandler \u00b6 EventHandler(element: Element) An EventHandler describes the handling of a single event in a ProvidedServiceInstance element instance-attribute \u00b6 element: Element event_group_identifier instance-attribute \u00b6 event_group_identifier: Optional[int] get or set the event group identifier of this EventHandler name instance-attribute \u00b6 name: str sd_server_event_group_timing_config instance-attribute \u00b6 sd_server_event_group_timing_config: Optional[ SomeipSdServerEventGroupTimingConfig ] get or set the SD server event group timing configuration for this EventHandler create_pdu_activation_routing_group \u00b6 create_pdu_activation_routing_group( name: str, event_group_control_type: EventGroupControlType, ) -> PduActivationRoutingGroup create a new PduActivationRoutingGroup in this EventHandler pdu_activation_routing_groups \u00b6 pdu_activation_routing_groups() -> Iterator[ PduActivationRoutingGroup ] get the PduActivationRoutingGroup s in this EventHandler EventHandlerV1 \u00b6 EventHandlerV1(element: Element) An EventHandlerV1 is a SD event handler that is used to receive events from other ECUs. This is the old V1 version of the service definition. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str add_consumed_event_group \u00b6 add_consumed_event_group( consumed_event_group: ConsumedEventGroupV1, ) -> None add a reference to a ConsumedEventGroupV1 to this EventHandlerV1 add_routing_group \u00b6 add_routing_group(routing_group: SoAdRoutingGroup) -> None add a reference to a SoAdRoutingGroup to this EventHandler consumed_event_groups \u00b6 consumed_event_groups() -> Iterator[ConsumedEventGroupV1] get the consumed event groups referenced by this EventHandler routing_groups \u00b6 routing_groups() -> Iterator[SoAdRoutingGroup] get the routing groups referenced by this EventHandler sd_server_config \u00b6 sd_server_config() -> Optional[SdEventConfig] get the SD server event configuration for this EventHandlerV1 set_sd_server_config \u00b6 set_sd_server_config( sd_event_config: SdEventConfig, ) -> None set the SD server event configuration for this EventHandlerV1 FlexrayArTpChannel \u00b6 FlexrayArTpChannel(element: Element) The FlexrayArTpChannel represents a channel in the Flexray Autosar Transport Protocol ack_type instance-attribute \u00b6 ack_type: Optional[FrArTpAckType] get or set the ack type of the channel element instance-attribute \u00b6 element: Element extended_addressing instance-attribute \u00b6 extended_addressing: Optional[bool] get or set the extended addressing attribute maximum_message_length instance-attribute \u00b6 maximum_message_length: Optional[MaximumMessageLengthType] get or set the maximum message length type minimum_separation_time instance-attribute \u00b6 minimum_separation_time: Optional[float] get or set the minimum separation time multicast_segmentation instance-attribute \u00b6 multicast_segmentation: Optional[bool] get or set the multicast segmentation add_n_pdu \u00b6 add_n_pdu(n_pdu: NPdu) -> None add an N-PDU to the channel The NPdus are logically assembled into a pool of Rx NPdus and another pool of Tx NPdus . This function is supported on autosar 4.1 and later, while Autosar 4.0 uses a different approach. create_flexray_ar_tp_connection \u00b6 create_flexray_ar_tp_connection( name: Optional[str], direct_tp_sdu: IPdu, source: FlexrayArTpNode, target: FlexrayArTpNode, ) -> FlexrayArTpConnection create a new FlexrayArTpConnection for this channel flexray_ar_tp_connections \u00b6 flexray_ar_tp_connections() -> Iterator[ FlexrayArTpConnection ] get an iterator over the connections in the channel n_pdus \u00b6 n_pdus() -> Iterator[NPdu] iterate over the NPdus of the channel FlexrayArTpConfig \u00b6 FlexrayArTpConfig(element: Element) The FlexrayArTpConfig represents the configuration of the Flexray Autosar Transport Protocol cluster instance-attribute \u00b6 cluster: Optional[FlexrayCluster] get or set the Flexray cluster for the configuration element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_flexray_ar_tp_channel \u00b6 create_flexray_ar_tp_channel( ack_type: FrArTpAckType, extended_addressing: bool, maximum_message_length: MaximumMessageLengthType, minimum_separation_time: float, multicast_segmentation: bool, ) -> FlexrayArTpChannel create a new FlexrayArTpChannel create_flexray_ar_tp_node \u00b6 create_flexray_ar_tp_node(name: str) -> FlexrayArTpNode create a new FlexrayArTpNode create_tp_address \u00b6 create_tp_address(name: str, address: int) -> TpAddress create a new TpAddress flexray_ar_tp_channels \u00b6 flexray_ar_tp_channels() -> Iterator[FlexrayArTpChannel] get an iterator over the channels in the configuration flexray_ar_tp_nodes \u00b6 flexray_ar_tp_nodes() -> Iterator[FlexrayArTpNode] get an iterator over the nodes tp_addresses \u00b6 tp_addresses() -> Iterator[TpAddress] iterate over all TpAddresses FlexrayArTpConnection \u00b6 FlexrayArTpConnection(element: Element) FlexrayArTpConnection represents a connection within a FlexrayArTpChannel The connection identifies the sender and the receiver of this particular communication. The Flexray Autosar Tp module routes a Pdu through this connection. direct_tp_sdu instance-attribute \u00b6 direct_tp_sdu: Optional[IPdu] get or set the direct TP SDU element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str reversed_tp_sdu instance-attribute \u00b6 reversed_tp_sdu: Optional[IPdu] get or set or remove the reversed TP SDU If the connection supports both directions, then the reversed TP SDU is required. if Some(value) is passed, the reversed TP SDU is set to the given value, otherwise it is removed. source instance-attribute \u00b6 source: Optional[FlexrayArTpNode] get or set the source of the connection add_target \u00b6 add_target(target: FlexrayArTpNode) -> None add a target to the connection The connection can have multiple targets, but at least one target is required. targets \u00b6 targets() -> Iterator[FlexrayArTpNode] get the targets FlexrayArTpNode \u00b6 FlexrayArTpNode(element: Element) FlexrayArTpNode represents a node in the Flexray Autosar Transport Protocol A TP node (sender or receiver) provides the TP address and the connection to the topology description element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str tp_address instance-attribute \u00b6 tp_address: Optional[TpAddress] set or remove the TP address if Some(value) is passed, the TP address is set to the given value, otherwise it is removed. add_communication_connector \u00b6 add_communication_connector( connector: FlexrayCommunicationConnector, ) -> None add a reference to a FlexrayCommunicationConnector The connectors define the association with a PhysicalChannel and an ECU. In a SystemDescription , this reference is mandatory, but in an ECUExtract it is optional. Up to 2 connectors can be added to a node. communication_connectors \u00b6 communication_connectors() -> Iterator[ FlexrayCommunicationConnector ] get the connectors FlexrayChannelName \u00b6 A flexray cluster may contain the channels A and/or B. This enum is an abstraction over the element. A instance-attribute \u00b6 A: FlexrayChannelName B instance-attribute \u00b6 B: FlexrayChannelName FlexrayCluster \u00b6 FlexrayCluster(element: Element) A FlexrayCluster contains all configuration items associated with a Flexray network. The cluster connects multiple ECUs. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str physical_channels instance-attribute \u00b6 physical_channels: FlexrayPhysicalChannelsInfo get the physical channels of this cluster system instance-attribute \u00b6 system: Optional[System] get the system that contains this cluster create_physical_channel \u00b6 create_physical_channel( name: str, channel_name: FlexrayChannelName ) -> FlexrayPhysicalChannel Create a new physical channel for the cluster A cluster may contain channel A, channel B, or both A and B. set_settings \u00b6 set_settings(settings: FlexrayClusterSettings) -> None set the current flexray cluster settings settings \u00b6 settings() -> Optional[FlexrayClusterSettings] get the current flexray cluster settings FlexrayClusterSettings \u00b6 action_point_offset instance-attribute \u00b6 action_point_offset: float get or set the action point offset of the cluster baudrate instance-attribute \u00b6 baudrate: int get or set the baudrate of the cluster bit instance-attribute \u00b6 bit: float get or set the bit time of the cluster cas_rx_low_max instance-attribute \u00b6 cas_rx_low_max: int get or set the cas rx low max of the cluster cold_start_attempts instance-attribute \u00b6 cold_start_attempts: int get or set the cold start attempts of the cluster cycle instance-attribute \u00b6 cycle: float get or set the cycle time of the cluster (in seconds) cycle_count_max instance-attribute \u00b6 cycle_count_max: int get or set the cycle count max of the cluster detect_nit_error instance-attribute \u00b6 detect_nit_error: bool get or set the detect nit error status of the cluster dynamic_slot_idle_phase instance-attribute \u00b6 dynamic_slot_idle_phase: int get or set the dynamic slot idle phase of the cluster ignore_after_tx instance-attribute \u00b6 ignore_after_tx: int get or set the ignore after tx duration of the cluster listen_noise instance-attribute \u00b6 listen_noise: int get or set the listen noise of the cluster macro_per_cycle instance-attribute \u00b6 macro_per_cycle: int get or set the macro per cycle of the cluster macrotick_duration instance-attribute \u00b6 macrotick_duration: float get or set the macrotick duration of the cluster max_without_clock_correction_fatal instance-attribute \u00b6 max_without_clock_correction_fatal: int get or set the max without clock correction fatal of the cluster max_without_clock_correction_passive instance-attribute \u00b6 max_without_clock_correction_passive: int get or set the max without clock correction passive of the cluster minislot_action_point_offset instance-attribute \u00b6 minislot_action_point_offset: int get or set the minislot action point offset of the cluster minislot_duration instance-attribute \u00b6 minislot_duration: int get or set the minislot duration of the cluster network_idle_time instance-attribute \u00b6 network_idle_time: int get or set the network idle time of the cluster network_management_vector_length instance-attribute \u00b6 network_management_vector_length: int get or set the network management vector length of the cluster number_of_minislots instance-attribute \u00b6 number_of_minislots: int get or set the number of minislots of the cluster number_of_static_slots instance-attribute \u00b6 number_of_static_slots: int get or set the number of static slots of the cluster offset_correction_start instance-attribute \u00b6 offset_correction_start: int get or set the offset correction start of the cluster payload_length_static instance-attribute \u00b6 payload_length_static: int get or set the payload length static of the cluster safety_margin instance-attribute \u00b6 safety_margin: int get or set the safety margin of the cluster sample_clock_period instance-attribute \u00b6 sample_clock_period: Optional[float] get or set the sample clock period of the cluster static_slot_duration instance-attribute \u00b6 static_slot_duration: int get or set the static slot duration of the cluster symbol_window instance-attribute \u00b6 symbol_window: int get or set the symbol window of the cluster symbol_window_action_point_offset instance-attribute \u00b6 symbol_window_action_point_offset: int get or set the symbol window action point offset of the cluster sync_frame_id_count_max instance-attribute \u00b6 sync_frame_id_count_max: int get or set the sync frame id count max of the cluster transceiver_standby_delay instance-attribute \u00b6 transceiver_standby_delay: Optional[float] get or set the transceiver standby delay of the cluster transmission_start_sequence_duration instance-attribute \u00b6 transmission_start_sequence_duration: int get or set the transmission start sequence duration of the cluster wakeup_rx_idle instance-attribute \u00b6 wakeup_rx_idle: int get or set the wakeup rx idle of the cluster wakeup_rx_low instance-attribute \u00b6 wakeup_rx_low: int get or set the wakeup rx low of the cluster wakeup_rx_window instance-attribute \u00b6 wakeup_rx_window: int get or set the wakeup rx window of the cluster wakeup_tx_active instance-attribute \u00b6 wakeup_tx_active: int get or set the wakeup tx active of the cluster wakeup_tx_idle instance-attribute \u00b6 wakeup_tx_idle: int get or set the wakeup tx idle of the cluster verify \u00b6 verify() -> bool verify the settings of a flexray cluster FlexrayCommunicationConnector \u00b6 FlexrayCommunicationConnector(element: Element) A connector between a [ FlexrayCommunicationController ] in an ECU and a [ FlexrayPhysicalChannel ] controller instance-attribute \u00b6 controller: FlexrayCommunicationController Get or set the controller of the CommunicationConnector ecu_instance instance-attribute \u00b6 ecu_instance: EcuInstance Get the EcuInstance that contains this CommunicationConnector element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str FlexrayCommunicationController \u00b6 FlexrayCommunicationController(element: Element) An EcuInstance needs a FlexrayCommunicationController in order to connect to a Flexray cluster. ecu_instance instance-attribute \u00b6 ecu_instance: EcuInstance Get the EcuInstance that contains this FlexrayCommunicationController element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str connect_physical_channel \u00b6 connect_physical_channel( connection_name: str, flx_channel: FlexrayPhysicalChannel, ) -> FlexrayCommunicationConnector Connect this [ FlexrayCommunicationController ] inside an [ EcuInstance ] to a [ FlexrayPhysicalChannel ] in the [ crate::System ] Creates a FlexrayCommunicationConnector in the [ EcuInstance ] that contains this [ FlexrayCommunicationController ]. This function establishes the relationships [ FlexrayPhysicalChannel ] -> FlexrayCommunicationConnector FlexrayCommunicationConnector -> [ FlexrayCommunicationController ] connected_channels \u00b6 connected_channels() -> Iterator[FlexrayPhysicalChannel] return an iterator over the [ FlexrayPhysicalChannel ]s connected to this controller FlexrayCommunicationCycle \u00b6 The timing settings of a Flexray frame Counter instance-attribute \u00b6 Counter: Type[FlexrayCommunicationCycle_Counter] Repetition instance-attribute \u00b6 Repetition: Type[FlexrayCommunicationCycle_Repetition] FlexrayCommunicationCycle_Counter \u00b6 FlexrayCommunicationCycle_Counter(cycle_counter: int) Bases: FlexrayCommunicationCycle cycle_counter instance-attribute \u00b6 cycle_counter: int FlexrayCommunicationCycle_Repetition \u00b6 FlexrayCommunicationCycle_Repetition( base_cycle: int, cycle_repetition: CycleRepetition ) Bases: FlexrayCommunicationCycle base_cycle instance-attribute \u00b6 base_cycle: int cycle_repetition instance-attribute \u00b6 cycle_repetition: CycleRepetition FlexrayFrame \u00b6 FlexrayFrame(element: Element) a Flexray frame element instance-attribute \u00b6 element: Element length instance-attribute \u00b6 length: Optional[int] get or set the length of the frame name instance-attribute \u00b6 name: str frame_triggerings \u00b6 frame_triggerings() -> List[FlexrayFrameTriggering] List all FlexrayFrameTriggering s using this frame map_pdu \u00b6 map_pdu( pdu: Pdu, start_position: int, byte_order: ByteOrder, /, *, update_bit: Optional[int] = None, ) -> FlexrayFrameTriggering map a PDU to the frame mapped_pdus \u00b6 mapped_pdus() -> Iterator[Pdu] returns an iterator over all PDUs in the frame FlexrayFrameTriggering \u00b6 FlexrayFrameTriggering(element: Element) Iterator over all [ FlexrayFrameTriggering ]s using this frame map a PDU to the frame The frame triggering connects a frame to a physical channel element instance-attribute \u00b6 element: Element frame instance-attribute \u00b6 frame: Optional[FlexrayFrame] get the frame triggered by the frame triggering name instance-attribute \u00b6 name: str physical_channel instance-attribute \u00b6 physical_channel: FlexrayPhysicalChannel get the physical channel that contains this frame triggering slot instance-attribute \u00b6 slot: Optional[int] get or set the slot id for the flexray frame triggering connect_to_ecu \u00b6 connect_to_ecu( ecu: EcuInstance, direction: CommunicationDirection ) -> FramePort connect this frame triggering to an ECU The frame triggering may be connected to any number of ECUs. frame_ports \u00b6 frame_ports() -> Iterator[FramePort] get the frame ports connected to this frame triggering pdu_triggerings \u00b6 pdu_triggerings() -> Iterator[PduTriggering] get the PDU triggerings referenced by this frame triggering set_timing \u00b6 set_timing(timing: FlexrayCommunicationCycle) -> None set the timing of the flexray frame timing \u00b6 timing() -> Optional[FlexrayCommunicationCycle] get the timing of the flexray frame In a well-formed file this should always return a value FlexrayNmCluster \u00b6 FlexrayNmCluster(element: Element) Flexray specific NmCluster channel_sleep_master instance-attribute \u00b6 channel_sleep_master: Optional[bool] get or set or remove the nmChannelSleepMaster flag communication_cluster instance-attribute \u00b6 communication_cluster: Optional[FlexrayCluster] get or set the referenced FlexrayCluster element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str nm_data_cycle instance-attribute \u00b6 nm_data_cycle: Optional[int] get or set the nmDataCycle Number of Flexray Communication Cycles needed to transmit the Nm Data PDUs of all Flexray Nm Ecus of this FlexrayNmCluster . nm_remote_sleep_indication_time instance-attribute \u00b6 nm_remote_sleep_indication_time: Optional[float] get or set the nmRemoteSleepIndicationTime Timeout for Remote Sleep Indication in seconds. nm_repeat_message_time instance-attribute \u00b6 nm_repeat_message_time: Optional[float] get or set the nmRepeatMessageTime Timeout for Repeat Message State in seconds. nm_repetition_cycle instance-attribute \u00b6 nm_repetition_cycle: Optional[int] get or set the nmRepetitionCycle Number of Flexray Communication Cycles used to repeat the transmission of the Nm vote Pdus of all Flexray NmEcus of this FlexrayNmCluster . This value shall be an integral multiple of nmVotingCycle. nm_voting_cycle instance-attribute \u00b6 nm_voting_cycle: Optional[int] get or set the nmVotingCycle The number of Flexray Communication Cycles used to transmit the Nm Vote PDUs of all Flexray Nm Ecus of this FlexrayNmCluster . node_detection_enabled instance-attribute \u00b6 node_detection_enabled: Optional[bool] get or set the nmNodeDetectionEnabled flag node_id_enabled instance-attribute \u00b6 node_id_enabled: Optional[bool] get or set the nmNodeIdEnabled flag pnc_cluster_vector_length instance-attribute \u00b6 pnc_cluster_vector_length: Optional[int] get or set the pncClusterVectorLength pnc_participation instance-attribute \u00b6 pnc_participation: Optional[bool] get or set the nmPncParticipation flag repeat_msg_ind_enabled instance-attribute \u00b6 repeat_msg_ind_enabled: Optional[bool] get or set the nmRepeatMsgIndEnabled flag synchronizing_network instance-attribute \u00b6 synchronizing_network: Optional[bool] get or set the nmSynchronizingNetwork flag create_flexray_nm_node \u00b6 create_flexray_nm_node( name: str, controller: FlexrayCommunicationController, nm_ecu: NmEcu, ) -> FlexrayNmNode add a FlexrayNmNode to the cluster nm_nodes \u00b6 nm_nodes() -> Iterator[FlexrayNmNode] iterate over all NmNodes in this cluster FlexrayNmClusterCoupling \u00b6 FlexrayNmClusterCoupling(element: Element) A FlexrayNmClusterCoupling couples multiple FlexrayNmCluster`s. element instance-attribute \u00b6 element: Element nm_schedule_variant instance-attribute \u00b6 nm_schedule_variant: Optional[FlexrayNmScheduleVariant] get or set the nmScheduleVariant add_coupled_cluster \u00b6 add_coupled_cluster(cluster: FlexrayNmCluster) -> None add a reference to a coupled NmCluster coupled_clusters \u00b6 coupled_clusters() -> Iterator[FlexrayNmCluster] iterate over all coupled NmClusters FlexrayNmClusterSettings \u00b6 FlexrayNmClusterSettings( *, nm_data_cycle: int, nm_remote_sleep_indication_time: float, nm_repeat_message_time: float, nm_repetition_cycle: int, nm_voting_cycle: int, ) Mandatory settings for a FlexrayNmCluster These settings must be provided when creating a new FlexrayNmCluster . Additional optional settings can be set using FlexrayNmCluster methods. nm_data_cycle instance-attribute \u00b6 nm_data_cycle: Optional[int] nmDataCycle: Number of Flexray Communication Cycles needed to transmit the Nm Data PDUs of all Flexray Nm Ecus of this FlexrayNmCluster . nm_remote_sleep_indication_time instance-attribute \u00b6 nm_remote_sleep_indication_time: Optional[float] nmRemoteSleepIndicationTime: Timeout for Remote Sleep Indication in seconds. nm_repeat_message_time instance-attribute \u00b6 nm_repeat_message_time: Optional[float] nmRepeatMessageTime: Timeout for Repeat Message State in seconds. nm_repetition_cycle instance-attribute \u00b6 nm_repetition_cycle: Optional[int] nmRepetitionCycle: Number of Flexray Communication Cycles used to repeat the transmission of the Nm vote Pdus of all Flexray NmEcus of this FlexrayNmCluster . This value shall be an integral multiple of nmVotingCycle. nm_voting_cycle instance-attribute \u00b6 nm_voting_cycle: Optional[int] nmVotingCycle: The number of Flexray Communication Cycles used to transmit the Nm Vote PDUs of all Flexray Nm Ecus of this FlexrayNmCluster . FlexrayNmNode \u00b6 FlexrayNmNode(element: Element) A FlexrayNmNode represents a Flexray specific NmNode . It connects a FlexrayCommunicationController with a NmEcu . communication_controller instance-attribute \u00b6 communication_controller: Optional[ FlexrayCommunicationController ] get or set the referenced FlexrayCommunicationController element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str nm_ecu instance-attribute \u00b6 nm_ecu: Optional[NmEcu] get or set the referenced NmEcu node_id instance-attribute \u00b6 node_id: Optional[int] get or set the nmNodeId This value is optional; if it is set to Some(x) the value is created, if it is set to None the value is removed. passive_mode instance-attribute \u00b6 passive_mode: Optional[bool] get or set ot remove the nmPassiveModeEnabled flag This flag is optional; if it is set to Some(x) the value is created, if it is set to None the value is removed. add_rx_nm_pdu \u00b6 add_rx_nm_pdu(nm_pdu: NmPdu) -> None add an Rx NmPdu Every NmNode must have at least one Rx NmPdu add_tx_nm_pdu \u00b6 add_tx_nm_pdu(nm_pdu: NmPdu) -> None add a Tx NmPdu Active NmNodes must have at least one Tx NmPdu , while passive NmNodes may have none. rx_nm_pdus \u00b6 rx_nm_pdus() -> Iterator[NmPdu] iterate over all RX NmPdus tx_nm_pdus \u00b6 tx_nm_pdus() -> Iterator[NmPdu] iterate over all TX NmPdus FlexrayNmScheduleVariant \u00b6 The FlexrayNmScheduleVariant defines the way the NM-Vote and NM-Data are transmitted within the Flexray network. ScheduleVariant1 instance-attribute \u00b6 ScheduleVariant1: FlexrayNmScheduleVariant ScheduleVariant2 instance-attribute \u00b6 ScheduleVariant2: FlexrayNmScheduleVariant ScheduleVariant3 instance-attribute \u00b6 ScheduleVariant3: FlexrayNmScheduleVariant ScheduleVariant4 instance-attribute \u00b6 ScheduleVariant4: FlexrayNmScheduleVariant ScheduleVariant5 instance-attribute \u00b6 ScheduleVariant5: FlexrayNmScheduleVariant ScheduleVariant6 instance-attribute \u00b6 ScheduleVariant6: FlexrayNmScheduleVariant ScheduleVariant7 instance-attribute \u00b6 ScheduleVariant7: FlexrayNmScheduleVariant FlexrayPhysicalChannel \u00b6 FlexrayPhysicalChannel(element: Element) the FlexrayPhysicalChannel represents either channel A or B of Flexray cluster channel_name instance-attribute \u00b6 channel_name: Optional[FlexrayChannelName] get the channel name of a FlexrayPhysicalChannel cluster instance-attribute \u00b6 cluster: FlexrayCluster get the cluster containing this physical channel element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str frame_triggerings \u00b6 frame_triggerings() -> Iterator[FlexrayFrameTriggering] iterate over all frame triggerings of this physical channel pdu_triggerings \u00b6 pdu_triggerings() -> Iterator[PduTriggering] iterate over all PDU triggerings of this physical channel signal_triggerings \u00b6 signal_triggerings() -> Iterator[ISignalTriggering] iterate over all signal triggerings of this physical channel trigger_frame \u00b6 trigger_frame( frame: FlexrayFrame, slot_id: int, timing: FlexrayCommunicationCycle, ) -> FlexrayFrameTriggering add a trigger for a flexray frame in this physical channel FlexrayPhysicalChannelsInfo \u00b6 Information about the flexray physical channels present inside a cluster channel_a instance-attribute \u00b6 channel_a: Optional[FlexrayPhysicalChannel] get the channel A of the cluster channel_b instance-attribute \u00b6 channel_b: Optional[FlexrayPhysicalChannel] get the channel B of the cluster FlexrayTpConfig \u00b6 FlexrayTpConfig(element: Element) FlexrayTpConfig defines exactly one Flexray ISO TP Configuration cluster instance-attribute \u00b6 cluster: Optional[FlexrayCluster] get or set the FlexrayCluster of the FlexrayTpConfig element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_flexray_tp_connection \u00b6 create_flexray_tp_connection( name: Optional[str], transmitter: FlexrayTpNode, direct_tp_sdu: IPdu, connection_control: FlexrayTpConnectionControl, ) -> FlexrayTpConnection create a new FlexrayTpConnection create_flexray_tp_connection_control \u00b6 create_flexray_tp_connection_control( name: str, ) -> FlexrayTpConnectionControl create a new FlexrayTpConnectionControl create_flexray_tp_ecu \u00b6 create_flexray_tp_ecu( ecu_instance: EcuInstance, full_duplex_enabled: bool ) -> FlexrayTpEcu add a FlexrayTpEcu to the FlexrayTpConfig create_flexray_tp_node \u00b6 create_flexray_tp_node(name: str) -> FlexrayTpNode create a new FlexrayTpNode create_flexray_tp_pdu_pool \u00b6 create_flexray_tp_pdu_pool(name: str) -> FlexrayTpPduPool create a new FlexrayTpPduPool create_tp_address \u00b6 create_tp_address(name: str, address: int) -> TpAddress create a new TpAddress flexray_tp_connection_controls \u00b6 flexray_tp_connection_controls() -> Iterator[ FlexrayTpConnectionControl ] iterate over all FlexrayTpConnectionControls flexray_tp_connections \u00b6 flexray_tp_connections() -> Iterator[FlexrayTpConnection] iterate over all FlexrayTpConnections flexray_tp_ecus \u00b6 flexray_tp_ecus() -> Iterator[FlexrayTpEcu] iterate over all FlexrayTpEcus flexray_tp_nodes \u00b6 flexray_tp_nodes() -> Iterator[FlexrayTpNode] iterate over all FlexrayTpNodes flexray_tp_pdu_pools \u00b6 flexray_tp_pdu_pools() -> Iterator[FlexrayTpPduPool] iterate over all FlexrayTpPduPools tp_addresses \u00b6 tp_addresses() -> Iterator[TpAddress] iterate over all TpAddresses FlexrayTpConnection \u00b6 FlexrayTpConnection(element: Element) A FlexrayTpConnection defines a connection between FlexrayTpNodes connection_control instance-attribute \u00b6 connection_control: Optional[FlexrayTpConnectionControl] get or set the connection control of the connection direct_tp_sdu instance-attribute \u00b6 direct_tp_sdu: Optional[IPdu] get or set the direct TP SDU of the connection element instance-attribute \u00b6 element: Element multicast_address instance-attribute \u00b6 multicast_address: Optional[TpAddress] get or set the multicast TpAddress of the connection name instance-attribute \u00b6 name: str reversed_tp_sdu instance-attribute \u00b6 reversed_tp_sdu: Optional[IPdu] get or set the reversed TP SDU of the connection This is used if the connection supports both sending and receiving rx_pdu_pool instance-attribute \u00b6 rx_pdu_pool: Optional[FlexrayTpPduPool] get or set the RX FlexrayTpPduPool of the connection transmitter instance-attribute \u00b6 transmitter: Optional[FlexrayTpNode] get or set the transmitter of the connection tx_pdu_pool instance-attribute \u00b6 tx_pdu_pool: Optional[FlexrayTpPduPool] get or set the TX FlexrayTpPduPool of the connection add_receiver \u00b6 add_receiver(receiver: FlexrayTpNode) -> None add a receiver to the connection receivers \u00b6 receivers() -> Iterator[FlexrayTpNode] iterate over all receivers of the connection FlexrayTpConnectionControl \u00b6 FlexrayTpConnectionControl(element: Element) A FlexrayTpConnectionControl defines the connection control parameters for a FlexrayTpConnection element instance-attribute \u00b6 element: Element max_fc_wait instance-attribute \u00b6 max_fc_wait: Optional[int] get or set the maxFcWait value max_number_of_npdu_per_cycle instance-attribute \u00b6 max_number_of_npdu_per_cycle: Optional[int] get or set the maxNumberOfNpduPerCycle value max_retries instance-attribute \u00b6 max_retries: Optional[int] get or set the maxRetries value name instance-attribute \u00b6 name: str separation_cycle_exponent instance-attribute \u00b6 separation_cycle_exponent: Optional[int] get or set the separationCycleExponent value FlexrayTpEcu \u00b6 FlexrayTpEcu(element: Element) A FlexrayTpEcu represents an ECU within the FlexrayTpConfig cancellation instance-attribute \u00b6 cancellation: Optional[bool] get or set the cancellation status of the FlexrayTpEcu cycle_time_main_function instance-attribute \u00b6 cycle_time_main_function: Optional[float] get or set the cycle time of the TP main function in seconds ecu_instance instance-attribute \u00b6 ecu_instance: Optional[EcuInstance] get or set the ECU instance of the FlexrayTpEcu element instance-attribute \u00b6 element: Element full_duplex_enabled instance-attribute \u00b6 full_duplex_enabled: Optional[bool] get or set the full duplex enabled flag of the FlexrayTpEcu FlexrayTpNode \u00b6 FlexrayTpNode(element: Element) A FlexrayTpNode provides the TP address and the connection to the topology description in a FlexrayTpConfig element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str tp_address instance-attribute \u00b6 tp_address: Optional[TpAddress] set or remove FlexrayTpAddress of the node A TP address is mandatory for unicast nodes, but optional for multicast nodes Setting None will remove the element add_communication_connector \u00b6 add_communication_connector( connector: FlexrayCommunicationConnector, ) -> None add a FlexrayCommunicationConnector to the node The node can be associated with up to 2 connectors. In a system description this reference is mandatory. communication_connectors \u00b6 communication_connectors() -> Iterator[ FlexrayCommunicationConnector ] iterate over all FlexrayCommunicationConnectors of the node FlexrayTpPduPool \u00b6 FlexrayTpPduPool(element: Element) A FlexrayTpPduPool contains a set of NPdus that can be used for sending and receiving element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str add_n_pdu \u00b6 add_n_pdu(n_pdu: NPdu) -> None add an NPdu to the PduPool n_pdus \u00b6 n_pdus() -> Iterator[NPdu] iterate over all referenced NPdus FrArTpAckType \u00b6 Types of Acknowledgement that can be used in an FlexrayArTpChannel AckWithRt instance-attribute \u00b6 AckWithRt: FrArTpAckType AckWithoutRt instance-attribute \u00b6 AckWithoutRt: FrArTpAckType NoAck instance-attribute \u00b6 NoAck: FrArTpAckType FramePort \u00b6 FramePort(element: Element) The FramePort allows an ECU to send or receive a frame communication_direction instance-attribute \u00b6 communication_direction: Optional[CommunicationDirection] get or set the communication direction of the frame port ecu instance-attribute \u00b6 ecu: EcuInstance get the ECU instance that contains this frame port element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str GeneralPurposeIPdu \u00b6 GeneralPurposeIPdu(element: Element) This element is used for AUTOSAR Pdus without attributes that are routed by the PduR category instance-attribute \u00b6 category: Optional[GeneralPurposeIPduCategory] get the category of this PDU contained_ipdu_props instance-attribute \u00b6 contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu element instance-attribute \u00b6 element: Element length instance-attribute \u00b6 length: Optional[int] get or set the length of this PDU name instance-attribute \u00b6 name: str pdu_triggerings \u00b6 pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU GeneralPurposeIPduCategory \u00b6 The category of a GeneralPurposeIPdu The Autosar standard defines the following categories: - XCP - SOMEIP_SEGMENTED_IPDU - DLT Dlt instance-attribute \u00b6 Dlt: GeneralPurposeIPduCategory SomeipSegmentedIpdu instance-attribute \u00b6 SomeipSegmentedIpdu: GeneralPurposeIPduCategory Xcp instance-attribute \u00b6 Xcp: GeneralPurposeIPduCategory GeneralPurposePdu \u00b6 GeneralPurposePdu(element: Element) This element is used for AUTOSAR Pdus without additional attributes that are routed by a bus interface category instance-attribute \u00b6 category: Optional[GeneralPurposePduCategory] get or set the category of this PDU element instance-attribute \u00b6 element: Element length instance-attribute \u00b6 length: Optional[int] get or set the length of this PDU name instance-attribute \u00b6 name: str pdu_triggerings \u00b6 pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU GeneralPurposePduCategory \u00b6 The category of a GeneralPurposePdu The Autosar standard defines the following categories: - SD - GLOBAL_TIME - DOIP DoIp instance-attribute \u00b6 DoIp: GeneralPurposePduCategory GlobalTime instance-attribute \u00b6 GlobalTime: GeneralPurposePduCategory Sd instance-attribute \u00b6 Sd: GeneralPurposePduCategory GenericTransformationTechnologyConfig \u00b6 GenericTransformationTechnologyConfig( *, protocol_name: str, protocol_version: str, header_length: int, in_place: bool, ) Configuration for a generic transformation technology For a generic trasformation, the mandatory values must be chosen by the user header_length instance-attribute \u00b6 header_length: int The length of the header in bits in_place instance-attribute \u00b6 in_place: bool Should the transformation take place in the existing buffer or in a separate buffer? protocol_name instance-attribute \u00b6 protocol_name: str The name of the custom protocol protocol_version instance-attribute \u00b6 protocol_version: str The version of the custom protocol IPduPort \u00b6 IPduPort(element: Element) The IPduPort allows an ECU to send or receive a PDU communication_direction instance-attribute \u00b6 communication_direction: Optional[CommunicationDirection] get or set the communication direction of this IPduPort ecu instance-attribute \u00b6 ecu: EcuInstance get the ECU instance that contains this IPduPort element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str IPv4AddressSource \u00b6 IPv4AddressSource defines how the address of an IPv4 NetworkEndpoint is obtained AutoIp instance-attribute \u00b6 AutoIp: IPv4AddressSource AutoIpDoIp instance-attribute \u00b6 AutoIpDoIp: IPv4AddressSource DHCPv4 instance-attribute \u00b6 DHCPv4: IPv4AddressSource Fixed instance-attribute \u00b6 Fixed: IPv4AddressSource IPv6AddressSource \u00b6 IPv6AddressSource defines how the address of an IPv6 NetworkEndpoint is obtained DHCPv6 instance-attribute \u00b6 DHCPv6: IPv6AddressSource Fixed instance-attribute \u00b6 Fixed: IPv6AddressSource LinkLocal instance-attribute \u00b6 LinkLocal: IPv6AddressSource LinkLocalDoIp instance-attribute \u00b6 LinkLocalDoIp: IPv6AddressSource RouterAdvertisement instance-attribute \u00b6 RouterAdvertisement: IPv6AddressSource ISignal \u00b6 ISignal(element: Element) Signal of the Interaction Layer datatype instance-attribute \u00b6 datatype: Optional[SwBaseType] get or set the data type for this signal element instance-attribute \u00b6 element: Element init_value instance-attribute \u00b6 init_value: Optional[ValueSpecification] get or set the initial value of the signal length instance-attribute \u00b6 length: Optional[int] set the length of this signal in bits name instance-attribute \u00b6 name: str signal_group instance-attribute \u00b6 signal_group: Optional[ISignalGroup] get the signal group that contains this signal, if any system_signal instance-attribute \u00b6 system_signal: Optional[SystemSignal] get the system signal that corresponds to this isignal add_data_transformation \u00b6 add_data_transformation( data_transformation: DataTransformation, ) -> None add a data transformation to this signal create_e2e_transformation_isignal_props \u00b6 create_e2e_transformation_isignal_props( transformer: TransformationTechnology, ) -> EndToEndTransformationISignalProps create E2E transformation properties for this signal create_someip_transformation_isignal_props \u00b6 create_someip_transformation_isignal_props( transformer: TransformationTechnology, ) -> SomeIpTransformationISignalProps create SomeIp transformation properties for this signal data_transformations \u00b6 data_transformations() -> Iterator[DataTransformation] get all data transformations that are applied to this signal mappings \u00b6 mappings() -> List[ISignalToIPduMapping] list all ISignalToIPduMapping for this signal Usually a signal should only be mapped to a single PDU, so this list is expected to contain either zero or one items in ordinary cases. signal_triggerings \u00b6 signal_triggerings() -> List[ISignalTriggering] list all ISignalTriggering s that trigger this signal transformation_isignal_props \u00b6 transformation_isignal_props() -> Iterator[ Union[ EndToEndTransformationISignalProps, SomeIpTransformationISignalProps, ] ] get all transformation properties that are applied to this signal ISignalGroup \u00b6 ISignalGroup(element: Element) An ISignalGroup groups signals that should always be kept together element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str system_signal_group instance-attribute \u00b6 system_signal_group: Optional[SystemSignalGroup] get the system signal group that is associated with this signal group add_data_transformation \u00b6 add_data_transformation( data_transformation: DataTransformation, ) -> None add a data transformation to this signal group add_signal \u00b6 add_signal(signal: ISignal) -> None Add a signal to the signal group create_e2e_transformation_isignal_props \u00b6 create_e2e_transformation_isignal_props( transformer: TransformationTechnology, ) -> EndToEndTransformationISignalProps create E2E transformation properties for this signal group create_someip_transformation_isignal_props \u00b6 create_someip_transformation_isignal_props( transformer: TransformationTechnology, ) -> SomeIpTransformationISignalProps create SomeIp transformation properties for this signal group data_transformations \u00b6 data_transformations() -> Iterator[DataTransformation] iterate over all data transformations that are applied to this signal group signals \u00b6 signals() -> Iterator[ISignal] Iterator over all [ ISignal ]s in this group Example \u00b6 transformation_isignal_props \u00b6 transformation_isignal_props() -> Iterator[ Union[ EndToEndTransformationISignalProps, SomeIpTransformationISignalProps, ] ] get all transformation properties that are applied to this signal group ISignalIPdu \u00b6 ISignalIPdu(element: Element) Represents the IPdus handled by Com contained_ipdu_props instance-attribute \u00b6 contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu element instance-attribute \u00b6 element: Element length instance-attribute \u00b6 length: Optional[int] get or set the length of this PDU name instance-attribute \u00b6 name: str map_signal \u00b6 map_signal( signal: ISignal, start_position: int, byte_order: ByteOrder, /, *, update_bit: Optional[int] = None, transfer_property: TransferProperty = TransferProperty.Pending, ) -> ISignalToIPduMapping map a signal to the ISignalIPdu If this signal is part of a signal group, then the group must be mapped first map_signal_group \u00b6 map_signal_group( signal_group: ISignalGroup, ) -> ISignalToIPduMapping map a signal group to the PDU mapped_signals \u00b6 mapped_signals() -> Iterator[Union[ISignal, ISignalGroup]] returns an iterator over all signals and signal groups mapped to the PDU pdu_triggerings \u00b6 pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU set_timing \u00b6 set_timing(timing_spec: IpduTiming) -> None set the transmission timing of the PDU timing \u00b6 timing() -> IpduTiming Helper function to set the transmission mode timing, used by ISignalIPdu::set_timing for both true and false timing get the transmission timing of the PDU ISignalPort \u00b6 ISignalPort(element: Element) The ISignalPort allows an ECU to send or receive a Signal communication_direction instance-attribute \u00b6 communication_direction: Optional[CommunicationDirection] get or set the communication direction of this port ecu instance-attribute \u00b6 ecu: EcuInstance get the ECU that is connected to this signal port element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str ISignalToIPduMapping \u00b6 ISignalToIPduMapping(element: Element) ISignalToIPduMapping connects an ISignal or ISignalGroup to an ISignalToIPdu byte_order instance-attribute \u00b6 byte_order: Optional[ByteOrder] get or set the byte order of the data in the mapped signal. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str signal instance-attribute \u00b6 signal: Optional[ISignal] Reference to the signal that is mapped to the PDU. Every mapping contains either a signal or a signal group. signal_group instance-attribute \u00b6 signal_group: Optional[ISignalGroup] Reference to the signal group that is mapped to the PDU. Every mapping contains either a signal or a signal group. start_position instance-attribute \u00b6 start_position: Optional[int] Start position of the signal data within the PDU (bit position). The start position is mandatory if the mapping describes a signal. transfer_property instance-attribute \u00b6 transfer_property: Optional[TransferProperty] Set the transfer property of the mapped signal update_bit instance-attribute \u00b6 update_bit: Optional[int] Bit position of the update bit for the mapped signal. Not all signals use an update bit. This is never used for signal groups ISignalTriggering \u00b6 ISignalTriggering(element: Element) an ISignalTriggering triggers a signal in a PDU element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str physical_channel instance-attribute \u00b6 physical_channel: PhysicalChannel get the physical channel that contains this signal triggering connect_to_ecu \u00b6 connect_to_ecu( ecu: EcuInstance, direction: CommunicationDirection ) -> ISignalPort connect this signal triggering to an ECU signal_ports \u00b6 signal_ports() -> Iterator[ISignalPort] create an iterator over all signal ports that are connected to this signal triggering InitialSdDelayConfig \u00b6 InitialSdDelayConfig( *, initial_delay_max_value: float, initial_delay_min_value: float, initial_repetitions_base_delay: Optional[float] = None, initial_repetitions_max: Optional[int] = None, ) A InitialSdDelayConfig contains the configuration for the initial delay of an SD client or server initial_delay_max_value instance-attribute \u00b6 initial_delay_max_value: float maximum value of the randomized delay in seconds initial_delay_min_value instance-attribute \u00b6 initial_delay_min_value: float minimum value of the randomized delay in seconds initial_repetitions_base_delay instance-attribute \u00b6 initial_repetitions_base_delay: Optional[float] base delay for repetitions in seconds initial_repetitions_max instance-attribute \u00b6 initial_repetitions_max: Optional[int] maximum number of repetitions IpduTiming \u00b6 IpduTiming( *, minimum_delay: Optional[float] = None, transmission_mode_true_timing: Optional[ TransmissionModeTiming ] = None, transmission_mode_false_timing: Optional[ TransmissionModeTiming ] = None, ) Timing specification for an IPDU minimum_delay instance-attribute \u00b6 minimum_delay: Optional[float] minimum delay in seconds between two transmissions of the PDU transmission_mode_false_timing instance-attribute \u00b6 transmission_mode_false_timing: Optional[ TransmissionModeTiming ] timing specification if the COM transmission mode is false transmission_mode_true_timing instance-attribute \u00b6 transmission_mode_true_timing: Optional[ TransmissionModeTiming ] timing specification if the COM transmission mode is true LocalUnicastAddress \u00b6 A LocalUnicastAddress is a local address (TCP or UDP) that can be used for a ProvidedServiceInstance or ConsumedServiceInstance Tcp instance-attribute \u00b6 Tcp: Type[LocalUnicastAddress_Tcp] Udp instance-attribute \u00b6 Udp: Type[LocalUnicastAddress_Udp] LocalUnicastAddress_Tcp \u00b6 LocalUnicastAddress_Tcp(address: SocketAddress) Bases: LocalUnicastAddress address instance-attribute \u00b6 address: SocketAddress LocalUnicastAddress_Udp \u00b6 LocalUnicastAddress_Udp(address: SocketAddress) Bases: LocalUnicastAddress address instance-attribute \u00b6 address: SocketAddress MaximumMessageLengthType \u00b6 Types of Maximum Message Length that can be used in an FlexrayArTpChannel I4g instance-attribute \u00b6 I4g: MaximumMessageLengthType Iso instance-attribute \u00b6 Iso: MaximumMessageLengthType Iso6 instance-attribute \u00b6 Iso6: MaximumMessageLengthType MultiplexedIPdu \u00b6 MultiplexedIPdu(element: Element) The multiplexed pdu contains one of serveral signal pdus contained_ipdu_props instance-attribute \u00b6 contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu element instance-attribute \u00b6 element: Element length instance-attribute \u00b6 length: Optional[int] get or set the length of this PDU name instance-attribute \u00b6 name: str pdu_triggerings \u00b6 pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU NPdu \u00b6 NPdu(element: Element) This is a Pdu of the transport layer. The main purpose of the TP layer is to segment and reassemble IPdus . contained_ipdu_props instance-attribute \u00b6 contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu element instance-attribute \u00b6 element: Element length instance-attribute \u00b6 length: Optional[int] get or set the length of this PDU name instance-attribute \u00b6 name: str pdu_triggerings \u00b6 pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU NetworkEndpoint \u00b6 NetworkEndpoint(element: Element) A network endpoint contains address information for a connection element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str add_network_endpoint_address \u00b6 add_network_endpoint_address( address: NetworkEndpointAddress, ) -> None add a network endpoint address to this NetworkEndpoint A NetworkEndpoint may have multiple sets of address information. The following restrictions apply: all addresses must have the same type, i.e. all IPv4 or all IPv6 only one of them may be a Fixed address, all others must be dynamic (DHCP, automatic link local, etc.) addresses \u00b6 addresses() -> Iterator[NetworkEndpointAddress] iterator over all addresses in the NetworkEndpoint NetworkEndpointAddress \u00b6 address information for a network endpoint IPv4 instance-attribute \u00b6 IPv4: Type[NetworkEndpointAddress_IPv4] IPv6 instance-attribute \u00b6 IPv6: Type[NetworkEndpointAddress_IPv6] NetworkEndpointAddress_IPv4 \u00b6 NetworkEndpointAddress_IPv4( *, address: Optional[str] = None, address_source: Optional[IPv4AddressSource] = None, default_gateway: Optional[str] = None, network_mask: Optional[str] = None, ) Bases: NetworkEndpointAddress address instance-attribute \u00b6 address: Optional[str] address_source instance-attribute \u00b6 address_source: Optional[IPv4AddressSource] default_gateway instance-attribute \u00b6 default_gateway: Optional[str] network_mask instance-attribute \u00b6 network_mask: Optional[str] NetworkEndpointAddress_IPv6 \u00b6 NetworkEndpointAddress_IPv6( *, address: Optional[str] = None, address_source: Optional[IPv6AddressSource] = None, default_router: Optional[str] = None, ) Bases: NetworkEndpointAddress address instance-attribute \u00b6 address: Optional[str] address_source instance-attribute \u00b6 address_source: Optional[IPv6AddressSource] default_router instance-attribute \u00b6 default_router: Optional[str] NmConfig \u00b6 NmConfig(element: Element) The NmConfig is the root element for the network management configuration. Only one config may exist per System , and this configuration may contain multiple NmClusters for different bus types. Use System::create_nm_config to create a new NmConfig in a System . element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_can_nm_cluster \u00b6 create_can_nm_cluster( name: str, settings: CanNmClusterSettings, can_cluster: CanCluster, ) -> CanNmCluster create a new CanNmCluster create_can_nm_cluster_coupling \u00b6 create_can_nm_cluster_coupling( nm_busload_reduction_enabled: bool, nm_immediate_restart_enabled: bool, ) -> CanNmClusterCoupling create a new CanNmClusterCoupling create_flexray_nm_cluster \u00b6 create_flexray_nm_cluster( name: str, settings: FlexrayNmClusterSettings, flexray_cluster: FlexrayCluster, ) -> FlexrayNmCluster create a new FlexrayNmCluster create_flexray_nm_cluster_coupling \u00b6 create_flexray_nm_cluster_coupling( nm_schedule_variant: FlexrayNmScheduleVariant, ) -> FlexrayNmClusterCoupling create a new FlexrayNmClusterCoupling create_nm_ecu \u00b6 create_nm_ecu( name: str, ecu_instance: EcuInstance ) -> NmEcu create a new NmEcu create_udp_nm_cluster \u00b6 create_udp_nm_cluster( name: str, settings: UdpNmClusterSettings, ethernet_cluster: EthernetCluster, ) -> UdpNmCluster create a new UdpNmCluster create_udp_nm_cluster_coupling \u00b6 create_udp_nm_cluster_coupling() -> UdpNmClusterCoupling create a new UdpNmClusterCoupling nm_cluster_couplings \u00b6 nm_cluster_couplings() -> Iterator[ Union[ CanNmClusterCoupling, FlexrayNmClusterCoupling, UdpNmClusterCoupling, ] ] iterate over all NmClusterCouplings nm_clusters \u00b6 nm_clusters() -> Iterator[ Union[CanNmCluster, FlexrayNmCluster, UdpNmCluster] ] get all NmClusters nm_ecus \u00b6 nm_ecus() -> Iterator[NmEcu] iterate over all NmEcus NmEcu \u00b6 NmEcu(element: Element) The NmEcu represents an EcuInstance wich participates in network management. cycle_time_main_function instance-attribute \u00b6 cycle_time_main_function: Optional[float] get or set or remove the nmCycletimeMainFunction value ecu_instance instance-attribute \u00b6 ecu_instance: Optional[EcuInstance] get or set the referenced EcuInstance element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str nm_bus_synchronization_enabled instance-attribute \u00b6 nm_bus_synchronization_enabled: Optional[bool] get or set the nmBusSynchronizationEnabled flag nm_com_control_enabled instance-attribute \u00b6 nm_com_control_enabled: Optional[bool] get or set the nmComControlEnabled flag NmPdu \u00b6 NmPdu(element: Element) Network Management Pdu element instance-attribute \u00b6 element: Element length instance-attribute \u00b6 length: Optional[int] get or set the length of this PDU name instance-attribute \u00b6 name: str pdu_triggerings \u00b6 pdu_triggerings() -> List[PduTriggering] List all PduTriggerings that trigger this PDU PduActivationRoutingGroup \u00b6 PduActivationRoutingGroup(element: Element) A group of Pdus that can be activated or deactivated for transmission over a socket connection. It is used by EventHandler s in ProvidedServiceInstance s and ConsumedServiceInstance s. element instance-attribute \u00b6 element: Element event_group_control_type instance-attribute \u00b6 event_group_control_type: Optional[EventGroupControlType] get or set the event group control type of this PduActivationRoutingGroup name instance-attribute \u00b6 name: str add_ipdu_identifier_tcp \u00b6 add_ipdu_identifier_tcp( ipdu_identifier: SoConIPduIdentifier, ) -> None add a reference to a SoConIPduIdentifier for TCP communication to this PduActivationRoutingGroup add_ipdu_identifier_udp \u00b6 add_ipdu_identifier_udp( ipdu_identifier: SoConIPduIdentifier, ) -> None add a reference to a SoConIPduIdentifier for UDP communication to this PduActivationRoutingGroup ipdu_identifiers_tcp \u00b6 ipdu_identifiers_tcp() -> Iterator[SoConIPduIdentifier] get all SoConIPduIdentifier s for TCP communication in this PduActivationRoutingGroup ipdu_identifiers_udp \u00b6 ipdu_identifiers_udp() -> Iterator[SoConIPduIdentifier] get all SoConIPduIdentifier s for UDP communication in this PduActivationRoutingGroup PduCollectionTrigger \u00b6 The collction trigger defines whether a Pdu contributes to the triggering of the data transmission if Pdu collection is enabled Always instance-attribute \u00b6 Always: PduCollectionTrigger Never instance-attribute \u00b6 Never: PduCollectionTrigger PduToFrameMapping \u00b6 PduToFrameMapping(element: Element) PduToFrameMapping connects a PDU to a frame byte_order instance-attribute \u00b6 byte_order: Optional[ByteOrder] get or set the byte order of the data in the PDU. All PduToFrameMappings within a frame must have the same byte order. PDUs may not use the byte order value Opaque . Note: If the byte order is swapped, then the start position must be adjusted accordingly. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str pdu instance-attribute \u00b6 pdu: Optional[Pdu] Reference to the PDU that is mapped into the frame. The PDU reference is mandatory. start_position instance-attribute \u00b6 start_position: Optional[int] set the start position of the PDU data within the frame (bit position). PDUs are byte aligned. For little-endian data the values 0, 8, 16, ... are allowed; for big-endian data the values 7, 15, 23, ... are allowed. Note: if you intend to change both the byte order and the start position, then you should change the byte order first. New values set here must match the configured byte order. update_bit instance-attribute \u00b6 update_bit: Optional[int] set or clear the bit position of the update bit for the mapped PDU. PduTriggering \u00b6 PduTriggering(element: Element) a PduTriggering triggers a PDU in a frame or ethernet connection element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str pdu instance-attribute \u00b6 pdu: Optional[Pdu] get the Pdu that is triggered by this pdu triggering physical_channel instance-attribute \u00b6 physical_channel: PhysicalChannel get the physical channel that contains this pdu triggering create_pdu_port \u00b6 create_pdu_port( ecu: EcuInstance, direction: CommunicationDirection ) -> IPduPort create an IPduPort to connect a PduTriggering to an EcuInstance pdu_ports \u00b6 pdu_ports() -> Iterator[IPduPort] create an iterator over the IPduPorts that are connected to this PduTriggering signal_triggerings \u00b6 signal_triggerings() -> Iterator[ISignalTriggering] create an iterator over the ISignalTriggerings that are triggered by this PduTriggering ProvidedServiceInstance \u00b6 ProvidedServiceInstance(element: Element) A ProvidedServiceInstance is a service that is provided by an ECU element instance-attribute \u00b6 element: Element instance_identifier instance-attribute \u00b6 instance_identifier: Optional[int] get or set the instance identifier of this ProvidedServiceInstance major_version instance-attribute \u00b6 major_version: Optional[int] get or set the major version of this ProvidedServiceInstance minor_version instance-attribute \u00b6 minor_version: Optional[int] get or set the minor version of this ProvidedServiceInstance name instance-attribute \u00b6 name: str sd_server_instance_config instance-attribute \u00b6 sd_server_instance_config: Optional[ SomeipSdServerServiceInstanceConfig ] get or set the SD server instance configuration for this ProvidedServiceInstance service_identifier instance-attribute \u00b6 service_identifier: Optional[int] get or set the service identifier of this ProvidedServiceInstance create_event_handler \u00b6 create_event_handler( name: str, event_group_identifier: int ) -> EventHandler create a new EventHandler in this ProvidedServiceInstance event_handlers \u00b6 event_handlers() -> Iterator[EventHandler] get the EventHandler s in this ProvidedServiceInstance local_unicast_addresses \u00b6 local_unicast_addresses() -> Iterator[LocalUnicastAddress] iterate over the local unicast addresses set_local_unicast_address \u00b6 set_local_unicast_address(address: SocketAddress) -> None set a local unicast address for this ProvidedServiceInstance The PSI may use two local unicast addresses, one each for UDP and TCP. The unicast address is used to assign the service to a specific ECU, and may not be empty. ProvidedServiceInstanceV1 \u00b6 ProvidedServiceInstanceV1(element: Element) A ProvidedServiceInstanceV1 is a SD service instance that is provided by this ECU. This is the old V1 version of the service definition. element instance-attribute \u00b6 element: Element instance_identifier instance-attribute \u00b6 instance_identifier: Optional[int] get or set the instance identifier of this ProvidedServiceInstance name instance-attribute \u00b6 name: str service_identifier instance-attribute \u00b6 service_identifier: Optional[int] get or set the service identifier of this ProvidedServiceInstance create_event_handler \u00b6 create_event_handler(name: str) -> EventHandlerV1 create a new EventHandlerV1 in this ProvidedServiceInstance event_handlers \u00b6 event_handlers() -> Iterator[EventHandlerV1] get the EventHandlerV1 s in this ProvidedServiceInstance sd_server_config \u00b6 sd_server_config() -> Optional[SdConfig] get or set the SD server configuration for this ProvidedServiceInstance set_sd_server_config \u00b6 set_sd_server_config(sd_server_config: SdConfig) -> None get or set the SD server configuration for this ProvidedServiceInstance RequestResponseDelay \u00b6 RequestResponseDelay(*, min_value: float, max_value: float) A RequestResponseDelay contains the minimum and maximum delay for a request-response cycle max_value instance-attribute \u00b6 max_value: float set the maximum value of this RequestResponseDelay min_value instance-attribute \u00b6 min_value: float set the minimum value of this RequestResponseDelay RxAcceptContainedIPdu \u00b6 The RxAcceptContainedIPdu enum defines whether a fixed set of contained IPdus is accepted or all contained IPdus AcceptAll instance-attribute \u00b6 AcceptAll: RxAcceptContainedIPdu AcceptConfigured instance-attribute \u00b6 AcceptConfigured: RxAcceptContainedIPdu SdConfig \u00b6 SdConfig( *, service_major_version: int, service_minor_version: int, initial_delay_max_value: float, initial_delay_min_value: float, initial_repetitions_base_delay: Optional[float] = None, initial_repetitions_max: int, offer_cyclic_delay: Optional[float] = None, request_response_delay_max_value: float, request_response_delay_min_value: float, ttl: int, ) SD configuration for a service instance This struct is used to configure the SD server and client behavior for a service instance. it is used for the old V1 service definitions. initial_delay_max_value instance-attribute \u00b6 initial_delay_max_value: float The maximum delay for the initial offer initial_delay_min_value instance-attribute \u00b6 initial_delay_min_value: float The minimum delay for the initial offer initial_repetitions_base_delay instance-attribute \u00b6 initial_repetitions_base_delay: Optional[float] The base delay for offer repetitions (if aggregated by SdServerConfig ) or find repetitions (if aggregated by SdClientConfig ) initial_repetitions_max instance-attribute \u00b6 initial_repetitions_max: int The maximum number of repetitions for the initial offer or find offer_cyclic_delay instance-attribute \u00b6 offer_cyclic_delay: Optional[float] The delay between two offers (if aggregated by SdServerConfig ) or finds (if aggregated by SdClientConfig ) request_response_delay_max_value instance-attribute \u00b6 request_response_delay_max_value: float The maximum delay for a request-response cycle request_response_delay_min_value instance-attribute \u00b6 request_response_delay_min_value: float The minimum delay for a request-response cycle service_major_version instance-attribute \u00b6 service_major_version: int The major version of the service service_minor_version instance-attribute \u00b6 service_minor_version: int The minor version of the service ttl instance-attribute \u00b6 ttl: int The time-to-live for the service offer SdEventConfig \u00b6 SdEventConfig( *, request_response_delay_max_value: float, request_response_delay_min_value: float, ttl: int, ) Configuration for an SD event handler request_response_delay_max_value instance-attribute \u00b6 request_response_delay_max_value: float The maximum delay for a request-response cycle request_response_delay_min_value instance-attribute \u00b6 request_response_delay_min_value: float The minimum delay for a request-response cycle ttl instance-attribute \u00b6 ttl: int The time-to-live for the service offer SecureCommunicationProps \u00b6 SecureCommunicationProps( *, auth_data_freshness_length: Optional[int] = None, auth_data_freshness_start_position: Optional[ int ] = None, authentication_build_attempts: Optional[int] = None, authentication_retries: Optional[int] = None, data_id: Optional[int] = None, freshness_value_id: Optional[int] = None, message_link_length: Optional[int] = None, message_link_position: Optional[int] = None, secondary_freshness_value_id: Optional[int] = None, secured_area_length: Optional[int] = None, secured_area_offset: Optional[int] = None, ) The properties of a SecuredIPdu auth_data_freshness_length instance-attribute \u00b6 auth_data_freshness_length: Optional[int] length in bits of the authentic PDU data auth_data_freshness_start_position instance-attribute \u00b6 auth_data_freshness_start_position: Optional[int] start position in bits of the authentic PDU data authentication_build_attempts instance-attribute \u00b6 authentication_build_attempts: Optional[int] number of authentication build attempts authentication_retries instance-attribute \u00b6 authentication_retries: Optional[int] number of additional authentication attempts. If this value is zero, the authentication is not repeated data_id instance-attribute \u00b6 data_id: Optional[int] numerical identifier of the secured IPdu freshness_value_id instance-attribute \u00b6 freshness_value_id: Optional[int] id of the freshness value message_link_length instance-attribute \u00b6 message_link_length: Optional[int] message link length in bits message_link_position instance-attribute \u00b6 message_link_position: Optional[int] message link start position in bits secondary_freshness_value_id instance-attribute \u00b6 secondary_freshness_value_id: Optional[int] seconday freshness value id secured_area_length instance-attribute \u00b6 secured_area_length: Optional[int] length in bytes of the secure area inside the payload pdu secured_area_offset instance-attribute \u00b6 secured_area_offset: Optional[int] start position in bytes of the secure area inside the payload pdu SecuredIPdu \u00b6 SecuredIPdu(element: Element) Wraps an IPdu to protect it from unauthorized manipulation contained_ipdu_props instance-attribute \u00b6 contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu element instance-attribute \u00b6 element: Element length instance-attribute \u00b6 length: Optional[int] get or set the length of this PDU name instance-attribute \u00b6 name: str payload_pdu_triggering instance-attribute \u00b6 payload_pdu_triggering: Optional[PduTriggering] get or set the PduTriggering that triggers the payload PDU When use_as_cryptographic_ipdu is true, this attribute can be used to directly set PduTriggering of the payload PDU. When use_as_cryptographic_ipdu is false, the function set_payload_ipdu should be used to create a new PduTriggering and set it. secure_communication_props instance-attribute \u00b6 secure_communication_props: Optional[ SecureCommunicationProps ] use_as_cryptographic_ipdu instance-attribute \u00b6 use_as_cryptographic_ipdu: Optional[bool] pdu_triggerings \u00b6 pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU set_payload_ipdu \u00b6 set_payload_ipdu( pdu: IPdu, physical_channel: PhysicalChannel ) -> PduTriggering set the payload PduTriggering based on an IPdu This function should be used when useAsCryptographicIPdu is false or not set. A PduTriggering is created for the Pdu ServiceInstanceCollectionSet \u00b6 ServiceInstanceCollectionSet(element: Element) A ServiceInstanceCollectionSet contains ServiceInstance s that are provided or consumed by an ECU element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_consumed_service_instance \u00b6 create_consumed_service_instance( name: str, service_identifier: int, instance_identifier: int, major_version: int, minor_version: str, ) -> ConsumedServiceInstance create a new ConsumedServiceInstance in this ServiceInstanceCollectionSet create_provided_service_instance \u00b6 create_provided_service_instance( name: str, service_identifier: int, instance_identifier: int, major_version: int, minor_version: int, ) -> ProvidedServiceInstance create a new ProvidedServiceInstance in this ServiceInstanceCollectionSet service_instances \u00b6 service_instances() -> Iterator[ Union[ConsumedServiceInstance, ProvidedServiceInstance] ] create an iterator over all ServiceInstances in this set SoAdRoutingGroup \u00b6 SoAdRoutingGroup(element: Element) A SoAdRoutingGroup is used to link SomeIp settings in Consumed/ProvidedServiceInstances to the SocketConnectionBundles used for transmission. SoAdRoutingGroups are part of the old way of configuring Ethernet communication in AUTOSAR. control_type instance-attribute \u00b6 control_type: Optional[EventGroupControlType] get or set the EventGroupControlType of this SoAdRoutingGroup element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str SoConIPduIdentifier \u00b6 SoConIPduIdentifier(element: Element) A SoConIPduIdentifier describes a PDU that is transported over a static socket connection. collection_trigger instance-attribute \u00b6 collection_trigger: Optional[PduCollectionTrigger] get or set the collection trigger for this SoConIPduIdentifier element instance-attribute \u00b6 element: Element header_id instance-attribute \u00b6 header_id: Optional[int] get or set the header id for this SoConIPduIdentifier name instance-attribute \u00b6 name: str pdu_triggering instance-attribute \u00b6 pdu_triggering: Optional[PduTriggering] get the PduTriggering referenced by this SoConIPduIdentifier timeout instance-attribute \u00b6 timeout: Optional[float] set the timeout for this SoConIPduIdentifier set_pdu \u00b6 set_pdu(pdu: Pdu, channel: EthernetPhysicalChannel) -> None create a new PduTriggering for the pdu and reference it in this SoConIPduIdentifier SocketAddress \u00b6 SocketAddress(element: Element) A socket address establishes the link between one or more ECUs and a NetworkEndpoint . It contains all settings that are relevant for this combination. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str network_endpoint instance-attribute \u00b6 network_endpoint: Optional[NetworkEndpoint] get the network endpoint of this SocketAddress physical_channel instance-attribute \u00b6 physical_channel: EthernetPhysicalChannel get the EthernetPhysicalChannel containing this SocketAddress socket_address_type instance-attribute \u00b6 socket_address_type: Optional[SocketAddressType] get the socket address type: unicast / multicast, as well as the connected ecus tp_config instance-attribute \u00b6 tp_config: Optional[TpConfig] get the transport protocol settings for this SocketAddress add_multicast_ecu \u00b6 add_multicast_ecu(ecu: EcuInstance) -> None add an EcuInstance to this multicast SocketAddress consumed_service_instances \u00b6 consumed_service_instances() -> Iterator[ ConsumedServiceInstanceV1 ] get the ConsumedServiceInstance s in this SocketAddress create_consumed_service_instance \u00b6 create_consumed_service_instance( name: str, provided_service_instance: ProvidedServiceInstanceV1, ) -> ConsumedServiceInstanceV1 create a ConsumedServiceInstanceV1 in this SocketAddress Creating a ConsumedServiceInstanceV1 in a SocketAddress is part of the old way of defining services (<= Autosar 4.5.0). It is obsolete in newer versions of the standard. When using the new way of defining services, a ConsumedServiceInstance should be created in a ServiceInstanceCollectionSet instead. create_provided_service_instance \u00b6 create_provided_service_instance( name: str, service_identifier: int, instance_identifier: int, ) -> ProvidedServiceInstanceV1 create a ProvidedServiceInstanceV1 in this SocketAddress Creating a ProvidedServiceInstanceV1 in a SocketAddress is part of the old way of defining services (<= Autosar 4.5.0). It is obsolete in newer versions of the standard. When using the new way of defining services, a ProvidedServiceInstance should be created in a ServiceInstanceCollectionSet instead. create_static_socket_connection \u00b6 create_static_socket_connection( name: str, remote_address: SocketAddress, /, *, tcp_role: Optional[TcpRole] = None, tcp_connect_timeout: Optional[float] = None, ) -> StaticSocketConnection create a new StaticSocketConnection from this SocketAddress to a remote SocketAddress provided_service_instances \u00b6 provided_service_instances() -> Iterator[ ProvidedServiceInstanceV1 ] get the ProvidedServiceInstanceV1 s in this SocketAddress set_unicast_ecu \u00b6 set_unicast_ecu(ecu: EcuInstance) -> None set the EcuInstance for this unicast SocketAddress static_socket_connections \u00b6 static_socket_connections() -> Iterator[ StaticSocketConnection ] iterate over all StaticSocketConnection s in this SocketAddress SocketAddressType \u00b6 Describes if a [ SocketAddress ] is used for unicast or multicast Multicast instance-attribute \u00b6 Multicast: Type[SocketAddressType_Multicast] Unicast instance-attribute \u00b6 Unicast: Type[SocketAddressType_Unicast] SocketAddressType.Unicast(ecu | None) SocketAddressType_Multicast \u00b6 SocketAddressType_Multicast(ecus: List[EcuInstance] = []) Bases: SocketAddressType ecus instance-attribute \u00b6 ecus: List[EcuInstance] SocketAddressType_Unicast \u00b6 SocketAddressType_Unicast( ecu: Optional[EcuInstance] = None, ) Bases: SocketAddressType ecu instance-attribute \u00b6 ecu: Optional[EcuInstance] SocketConnection \u00b6 SocketConnection(element: Element) A socketConnection inside a SocketConnectionBundle describes a single connection to a specific client port. client_ip_addr_from_connection_request instance-attribute \u00b6 client_ip_addr_from_connection_request: Optional[bool] get or set the client_ip_addr_from_connection_request attribute for this socket connection if the value is Some(true), the attribute is set to \"true\" if the value is Some(false), the attribute is set to \"false\" if the value is None, the attribute is removed client_port instance-attribute \u00b6 client_port: Optional[SocketAddress] get or set the client port of this socket connection client_port_from_connection_request instance-attribute \u00b6 client_port_from_connection_request: Optional[bool] get or set the client_port_from_connection_request attribute for this socket connection if the value is Some(true), the attribute is set to \"true\" if the value is Some(false), the attribute is set to \"false\" if the value is None, the attribute is removed element instance-attribute \u00b6 element: Element runtime_ip_address_configuration instance-attribute \u00b6 runtime_ip_address_configuration: bool get or set the value of the RuntimeIpAddressConfiguration attribute for this socket connection runtime_port_configuration instance-attribute \u00b6 runtime_port_configuration: bool get or set the value of the RuntimePortConfiguration attribute for this socket connection socket_connection_bundle instance-attribute \u00b6 socket_connection_bundle: SocketConnectionBundle get the socket connection bundle containing this socket connection create_socket_connection_ipdu_identifier \u00b6 create_socket_connection_ipdu_identifier( pdu: Pdu, header_id: int, /, *, timeout: Optional[float] = None, collection_trigger: Optional[ PduCollectionTrigger ] = None, ) -> Tuple[SocketConnectionIpduIdentifier, PduTriggering] add a PDU to the socket connection, returning a PduTriggering pdu_triggerings \u00b6 pdu_triggerings() -> Iterator[PduTriggering] create an iterator over all PDU triggerings in this socket connection socket_connection_ipdu_identifiers \u00b6 socket_connection_ipdu_identifiers() -> Iterator[ SocketConnectionIpduIdentifier ] create an iterator over all SocketConnectionIpduIdentifiers in this socket connection SocketConnectionBundle \u00b6 SocketConnectionBundle(element: Element) A SocketConnectionBundle describes a connection between a server port and multiple client ports. It contains multiple bundled connections, each transporting one or more PDUs. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str physical_channel instance-attribute \u00b6 physical_channel: EthernetPhysicalChannel get the physical channel containing this socket connection bundle server_port instance-attribute \u00b6 server_port: Optional[SocketAddress] get or set the server port of this socket connection bundle bundled_connections \u00b6 bundled_connections() -> Iterator[SocketConnection] create an iterator over all bundled connections in this socket connection bundle create_bundled_connection \u00b6 create_bundled_connection( client_port: SocketAddress, ) -> SocketConnection create a bundled SocketConnection between the server port and a client port SocketConnectionIpduIdentifier \u00b6 SocketConnectionIpduIdentifier(element: Element) A SocketConnectionIpduIdentifier is used to trigger a PDU in a SocketConnection . In addition to the Pdu Triggering, it also contains associated settings like the header id, timeout and collection trigger. collection_trigger instance-attribute \u00b6 collection_trigger: Optional[PduCollectionTrigger] set the collection trigger for this SocketConnectionIpduIdentifier element instance-attribute \u00b6 element: Element header_id instance-attribute \u00b6 header_id: Optional[int] set the header id for this SocketConnectionIpduIdentifier pdu_triggering instance-attribute \u00b6 pdu_triggering: Optional[PduTriggering] get the PduTriggering associated with this SocketConnectionIpduIdentifier socket_connection instance-attribute \u00b6 socket_connection: SocketConnection get the SocketConnection containing this SocketConnectionIpduIdentifier timeout instance-attribute \u00b6 timeout: Optional[float] set the timeout for this SocketConnectionIpduIdentifier add_routing_group \u00b6 add_routing_group(routing_group: SoAdRoutingGroup) -> None add a reference to a SoAdRoutingGroup to this SocketConnectionIpduIdentifier routing_groups \u00b6 routing_groups() -> Iterator[SoAdRoutingGroup] create an iterator over all SoAdRoutingGroups referenced by this SocketConnectionIpduIdentifier trigger_pdu \u00b6 trigger_pdu(pdu: Pdu) -> PduTriggering trigger a PDU in this SocketConnectionIpduIdentifier , creating a PduTriggering SocketConnectionIpduIdentifierSet \u00b6 SocketConnectionIpduIdentifierSet(element: Element) A SocketConnectionIpduIdentifierSet contains a set of SoConIPduIdentifiers , which are used in static socket connections and in SomeIp events. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_socon_ipdu_identifier \u00b6 create_socon_ipdu_identifier( name: str, pdu: Pdu, channel: EthernetPhysicalChannel, /, *, header_id: Optional[int] = None, timeout: Optional[float] = None, collection_trigger: Optional[ PduCollectionTrigger ] = None, ) -> SoConIPduIdentifier create a new SoConIPduIdentifier in this set socon_ipdu_identifiers \u00b6 socon_ipdu_identifiers() -> Iterator[SoConIPduIdentifier] create an iterator over all SoConIPduIdentifiers in this set SomeIpMessageType \u00b6 message types that can be used in a SOME/IP message header, depending on the type of communication Notification instance-attribute \u00b6 Notification: SomeIpMessageType Request instance-attribute \u00b6 Request: SomeIpMessageType RequestNoReturn instance-attribute \u00b6 RequestNoReturn: SomeIpMessageType Response instance-attribute \u00b6 Response: SomeIpMessageType SomeIpTransformationISignalProps \u00b6 SomeIpTransformationISignalProps(element: Element) Properties for the SOMEIP transformation of an ISignal(Group) dynamic_length instance-attribute \u00b6 dynamic_length: Optional[bool] get or set the dynamic length property element instance-attribute \u00b6 element: Element interface_version instance-attribute \u00b6 interface_version: Optional[int] get or set the interface version property legacy_strings instance-attribute \u00b6 legacy_strings: Optional[bool] get or set the legacy strings property message_type instance-attribute \u00b6 message_type: Optional[SomeIpMessageType] get or set the message type property size_of_array_length instance-attribute \u00b6 size_of_array_length: Optional[int] get or set the size of array length property size_of_string_length instance-attribute \u00b6 size_of_string_length: Optional[int] get or set the size of string length property size_of_struct_length instance-attribute \u00b6 size_of_struct_length: Optional[int] get or set the size of struct length property size_of_union_length instance-attribute \u00b6 size_of_union_length: Optional[int] get or set the size of union length property transformer instance-attribute \u00b6 transformer: Optional[TransformationTechnology] get or set the transformer reference of the E2E transformation properties SomeIpTransformationTechnologyConfig \u00b6 SomeIpTransformationTechnologyConfig( *, alignment: int, byte_order: ByteOrder, interface_version: int, ) Configuration for a SOMEIP transformation alignment instance-attribute \u00b6 alignment: int The alignment of the data in bits byte_order instance-attribute \u00b6 byte_order: ByteOrder The byte order of the data interface_version instance-attribute \u00b6 interface_version: int The interface version the SOME/IP transformer shall use. SomeipSdClientEventGroupTimingConfig \u00b6 SomeipSdClientEventGroupTimingConfig(element: Element) A SomeipSdClientEventGroupTimingConfig contains the configuration for the timing of a ConsumedEventGroup This configuration is a named element that is created separately and can be used by multiple ConsumedEventGroup s. Use [ ArPackage::create_someip_sd_client_event_group_timing_config ] to create a new SomeipSdClientEventGroupTimingConfig . element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str subscribe_eventgroup_retry_delay instance-attribute \u00b6 subscribe_eventgroup_retry_delay: Optional[float] get or set the subscribe eventgroup retry delay of this SomeipSdClientEventGroupTimingConfig subscribe_eventgroup_retry_max instance-attribute \u00b6 subscribe_eventgroup_retry_max: Optional[int] get or set subscribe eventgroup retry max of this SomeipSdClientEventGroupTimingConfig time_to_live instance-attribute \u00b6 time_to_live: Optional[int] get or set the time to live of this SomeipSdClientEventGroupTimingConfig request_response_delay \u00b6 request_response_delay() -> Optional[RequestResponseDelay] get the request response delay of this SomeipSdClientEventGroupTimingConfig set_request_response_delay \u00b6 set_request_response_delay( request_response_delay: RequestResponseDelay, ) -> None set the request response delay of this SomeipSdClientEventGroupTimingConfig SomeipSdClientServiceInstanceConfig \u00b6 SomeipSdClientServiceInstanceConfig(element: Element) A SomeipSdClientServiceInstanceConfig is a configuration for a ConsumedServiceInstance This configuration is a named element that is created separately and can be used by multiple ConsumedServiceInstance s. Use [ ArPackage::create_someip_sd_client_service_instance_config ] to create a new SomeipSdClientServiceInstanceConfig . element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str priority instance-attribute \u00b6 priority: Optional[int] get or set the priority of this SomeipSdClientServiceInstanceConfig Available since R21-11 ( AUTOSAR_00050 ) initial_find_behavior \u00b6 initial_find_behavior() -> Optional[InitialSdDelayConfig] get the initial find behavior of this SomeipSdClientServiceInstanceConfig set_initial_find_behavior \u00b6 set_initial_find_behavior( initial_find_behavior: InitialSdDelayConfig, ) -> None set the initial find behavior of this SomeipSdClientServiceInstanceConfig SomeipSdServerEventGroupTimingConfig \u00b6 SomeipSdServerEventGroupTimingConfig(element: Element) A SomeipSdServerEventGroupTimingConfig contains the configuration for the timing of an EventHandler This configuration is a named element that is created separately and can be used by multiple EventHandler s. Use [ ArPackage::create_someip_sd_server_event_group_timing_config ] to create a new SomeipSdServerEventGroupTimingConfig . element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str request_response_delay \u00b6 request_response_delay() -> Optional[RequestResponseDelay] get the request response delay of this SomeipSdServerEventGroupTimingConfig set_request_response_delay \u00b6 set_request_response_delay( request_response_Delay: RequestResponseDelay, ) -> None set the request response delay of this SomeipSdServerEventGroupTimingConfig SomeipSdServerServiceInstanceConfig \u00b6 SomeipSdServerServiceInstanceConfig(element: Element) A SomeipSdServerServiceInstanceConfig is a configuration for a ProvidedServiceInstance This configuration is a named element that is created separately and can be used by multiple ProvidedServiceInstance s. Use [ ArPackage::create_someip_sd_server_service_instance_config ] to create a new SomeipSdServerServiceInstanceConfig . element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str offer_cyclic_delay instance-attribute \u00b6 offer_cyclic_delay: Optional[float] get or set the offer cyclic delay of this SomeipSdServerServiceInstanceConfig priority instance-attribute \u00b6 priority: Optional[int] get or set the priority of this SomeipSdServerServiceInstanceConfig Available since R21-11 ( AUTOSAR_00050 ) service_offer_time_to_live instance-attribute \u00b6 service_offer_time_to_live: Optional[int] get or set the service offer time to live of this SomeipSdServerServiceInstanceConfig initial_offer_behavior \u00b6 initial_offer_behavior() -> Optional[InitialSdDelayConfig] get the initial offer behavior of this SomeipSdServerServiceInstanceConfig request_response_delay \u00b6 request_response_delay() -> Optional[RequestResponseDelay] get the request response delay of this SomeipSdServerServiceInstanceConfig set_initial_offer_behavior \u00b6 set_initial_offer_behavior( initial_offer_behavior: InitialSdDelayConfig, ) -> None set the initial offer behavior of this SomeipSdServerServiceInstanceConfig set_request_response_delay \u00b6 set_request_response_delay( request_response_delay: RequestResponseDelay, ) -> None set the request response delay of this SomeipSdServerServiceInstanceConfig SomeipTpChannel \u00b6 SomeipTpChannel(element: Element) General settings for a SomeIp TP channel version >= AUTOSAR_00046 element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str rx_timeout_time instance-attribute \u00b6 rx_timeout_time: Optional[float] set the rxTimeoutTime for the SomeIpTpChannel separation_time instance-attribute \u00b6 separation_time: Optional[float] set the separationTime for the SomeIpTpChannel SomeipTpConfig \u00b6 SomeipTpConfig(element: Element) A SomipTpConfig contains the configuration of individual SomeIp TP connections cluster instance-attribute \u00b6 cluster: Optional[ Union[CanCluster, FlexrayCluster, EthernetCluster] ] get the communication cluster of this SomeipTpConfig element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_someip_tp_channel \u00b6 create_someip_tp_channel(name: str) -> SomeipTpChannel create a new SomeipTpChannel in this SomeipTpConfig version >= AUTOSAR_00046 create_someip_tp_connection \u00b6 create_someip_tp_connection( tp_sdu: ISignalIPdu, transport_pdu_triggering: PduTriggering, /, *, tp_channel: Optional[SomeipTpChannel] = None, ) -> SomeipTpConnection create a new SomeIp TP connection in this SomeipTpConfig someip_tp_channels \u00b6 someip_tp_channels() -> Iterator[SomeipTpChannel] iterate over all SomeipTpChannel s in this SomeipTpConfig someip_tp_connections \u00b6 someip_tp_connections() -> Iterator[SomeipTpConnection] get all SomeipTpConnection s in this SomeipTpConfig SomeipTpConnection \u00b6 SomeipTpConnection(element: Element) A SomeipTpConnection contains the configuration of a single SomeIp TP connection element instance-attribute \u00b6 element: Element someip_tp_config instance-attribute \u00b6 someip_tp_config: SomeipTpConfig get the SomeipTpConfig that contains this SomeipTpConnection tp_channel instance-attribute \u00b6 tp_channel: Optional[SomeipTpChannel] set the TpChannel of this SomeipTpConnection tp_sdu instance-attribute \u00b6 tp_sdu: Optional[ISignalIPdu] set the TpSdu of this SomeipTpConnection transport_pdu_triggering instance-attribute \u00b6 transport_pdu_triggering: Optional[PduTriggering] get or set the PduTriggering for the transport PDU of this SomeipTpConnection StaticSocketConnection \u00b6 StaticSocketConnection(element: Element) A static socket connection is a connection between two sockets. This is the new way to establish a connection. It was introduced in Autosar 4.5.0 ( AUTOSAR_00048 ). element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str remote_socket instance-attribute \u00b6 remote_socket: Optional[SocketAddress] get or set the remote socket of this connection socket_address instance-attribute \u00b6 socket_address: SocketAddress get the socket address containing this static socket connection tcp_connect_timeout instance-attribute \u00b6 tcp_connect_timeout: Optional[float] get or set the TCP connect timeout of this static socket connection tcp_role instance-attribute \u00b6 tcp_role: Optional[TcpRole] get or set the TCP role of this static socket connection add_ipdu_identifier \u00b6 add_ipdu_identifier( identifier: SoConIPduIdentifier, ) -> None add a SoConIPduIdentifier to this static socket connection ipdu_identifiers \u00b6 ipdu_identifiers() -> Iterator[SoConIPduIdentifier] create an iterator over all SoConIPduIdentifiers in this static socket connection SystemSignal \u00b6 SystemSignal(element: Element) The system signal represents the communication system's view of data exchanged between SW components which reside on different ECUs Use [ ArPackage::create_system_signal ] to create a new system signal compu_method instance-attribute \u00b6 compu_method: Optional[CompuMethod] get or set the compu method for this signal data_constr instance-attribute \u00b6 data_constr: Optional[DataConstr] get or set the data constraint for this signal element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str signal_group instance-attribute \u00b6 signal_group: Optional[SystemSignalGroup] get the signal group that contains this signal unit instance-attribute \u00b6 unit: Optional[Unit] get or set the unit for this signal SystemSignalGroup \u00b6 SystemSignalGroup(element: Element) A signal group refers to a set of signals that shall always be kept together. A signal group is used to guarantee the atomic transfer of AUTOSAR composite data types. Use [ ArPackage::create_system_signal_group ] to create a new system signal group element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str add_signal \u00b6 add_signal(signal: SystemSignal) -> None Add a signal to the signal group signals \u00b6 signals() -> Iterator[ISignal] Iterate over all signals in the signal group TcpRole \u00b6 The role of a TCP connection in a static socket connection can either be Connect (=client) or Listen (=server). Connect instance-attribute \u00b6 Connect: TcpRole Listen instance-attribute \u00b6 Listen: TcpRole TpAddress \u00b6 TpAddress(element: Element) Represents an ECUs transport layer address on the referenced channel The TpAddress element is used by FlexrayArTpConfig and FlexrayTpConfig address instance-attribute \u00b6 address: Optional[int] get or set the value of the address element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str TpConfig \u00b6 transport protocol settings of a [ SocketAddress ] TcpTp staticmethod \u00b6 TcpTp( *, port_number: Optional[int] = None, port_dynamically_assigned: Optional[bool] = None, ) -> TpConfig_TcpTp UdpTp staticmethod \u00b6 UdpTp( *, port_number: Optional[int] = None, port_dynamically_assigned: Optional[bool] = None, ) -> TpConfig_UdpTp TpConfig_TcpTp \u00b6 Bases: TpConfig port_dynamically_assigned instance-attribute \u00b6 port_dynamically_assigned: Optional[bool] port_number instance-attribute \u00b6 port_number: Optional[int] TpConfig_UdpTp \u00b6 Bases: TpConfig port_dynamically_assigned instance-attribute \u00b6 port_dynamically_assigned: Optional[bool] port_number instance-attribute \u00b6 port_number: Optional[int] TransferProperty \u00b6 The TransferProperty defines if or how the signal influences the transfer of the PDU Pending instance-attribute \u00b6 Pending: TransferProperty Triggered instance-attribute \u00b6 Triggered: TransferProperty TriggeredOnChange instance-attribute \u00b6 TriggeredOnChange: TransferProperty TriggeredOnChangeWithoutRepetition instance-attribute \u00b6 TriggeredOnChangeWithoutRepetition: TransferProperty TriggeredWithoutRepetition instance-attribute \u00b6 TriggeredWithoutRepetition: TransferProperty TransformationTechnology \u00b6 TransformationTechnology(element: Element) A TransformationTechnology describes how to transform signal or PDU data data_transformation_set instance-attribute \u00b6 data_transformation_set: Optional[DataTransformationSet] get the DataTransformationSet that contains this TransformationTechnology element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str protocol instance-attribute \u00b6 protocol: Optional[str] Get the protocol of the TransformationTechnology . It can be set by replacing the whole config transformer_class instance-attribute \u00b6 transformer_class: Optional[str] Get the transformer class of the TransformationTechnology config \u00b6 config() -> Optional[TransformationTechnologyConfig] get the configuration of the TransformationTechnology set_config \u00b6 set_config(config: TransformationTechnologyConfig) -> None set the configuration of the TransformationTechnology TransmissionModeTiming \u00b6 TransmissionModeTiming( *, cyclic_timing: Optional[CyclicTiming] = None, event_controlled_timing: Optional[ EventControlledTiming ] = None, ) Cyclic and event controlled timing parameters for an IPDU cyclic_timing instance-attribute \u00b6 cyclic_timing: Optional[CyclicTiming] cyclic timing parameters event_controlled_timing instance-attribute \u00b6 event_controlled_timing: Optional[EventControlledTiming] event controlled timing parameters UdpNmCluster \u00b6 UdpNmCluster(element: Element) Udp / Ethernet specific NmCluster channel_sleep_master instance-attribute \u00b6 channel_sleep_master: Optional[bool] get or set the nmChannelSleepMaster flag communication_cluster instance-attribute \u00b6 communication_cluster: Optional[EthernetCluster] set the referenced EthernetCluster element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str nm_cbv_position instance-attribute \u00b6 nm_cbv_position: Optional[int] get or set the value nmCbvPosition nm_immediate_nm_transmissions instance-attribute \u00b6 nm_immediate_nm_transmissions: Optional[int] get or set the value nmImmediateNmTransmissions nm_message_timeout_time instance-attribute \u00b6 nm_message_timeout_time: Optional[float] get or set the nmMessageTimeoutTime nm_msg_cycle_time instance-attribute \u00b6 nm_msg_cycle_time: Optional[float] get or set the nmMsgCycleTime nm_network_timeout instance-attribute \u00b6 nm_network_timeout: Optional[float] get or set the NmNetworkTimeout nm_nid_position instance-attribute \u00b6 nm_nid_position: Optional[int] get or set the value nmNidPosition nm_remote_sleep_indication_time instance-attribute \u00b6 nm_remote_sleep_indication_time: Optional[float] get or set the NmRemoteSleepIndicationTime nm_repeat_message_time instance-attribute \u00b6 nm_repeat_message_time: Optional[float] get or set the NmRepeatMessageTime nm_wait_bus_sleep_time instance-attribute \u00b6 nm_wait_bus_sleep_time: Optional[float] get or set the NmWaitBusSleepTime node_detection_enabled instance-attribute \u00b6 node_detection_enabled: Optional[bool] get or set the nmNodeDetectionEnabled flag node_id_enabled instance-attribute \u00b6 node_id_enabled: Optional[bool] get or set the nmNodeIdEnabled flag pnc_cluster_vector_length instance-attribute \u00b6 pnc_cluster_vector_length: Optional[int] get or set the pncClusterVectorLength pnc_participation instance-attribute \u00b6 pnc_participation: Optional[bool] get or set the nmPncParticipation flag repeat_msg_ind_enabled instance-attribute \u00b6 repeat_msg_ind_enabled: Optional[bool] get or set the nmRepeatMsgIndEnabled flag synchronizing_network instance-attribute \u00b6 synchronizing_network: Optional[bool] get or set the nmSynchronizingNetwork flag vlan instance-attribute \u00b6 vlan: Optional[EthernetPhysicalChannel] get or set the Vlan associated with the cluster through an EthernetPhysicalChannel reference. create_udp_nm_node \u00b6 create_udp_nm_node( name: str, controller: EthernetCommunicationController, nm_ecu: NmEcu, nm_msg_cycle_offset: float, ) -> UdpNmNode add a UdpNmNode to the cluster nm_nodes \u00b6 nm_nodes() -> Iterator[UdpNmNode] iterate over all NmNodes in this cluster UdpNmClusterCoupling \u00b6 UdpNmClusterCoupling(element: Element) Udp / Ethernet specific NmClusterCoupling It couples multiple UdpNmCluster s and provides UdpNm-specific settings element instance-attribute \u00b6 element: Element nm_immediate_restart_enabled instance-attribute \u00b6 nm_immediate_restart_enabled: Optional[bool] set or remove the nmImmediateRestartEnabled flag add_coupled_cluster \u00b6 add_coupled_cluster(cluster: UdpNmCluster) -> None add a reference to a coupled NmCluster coupled_clusters \u00b6 coupled_clusters() -> Iterator[UdpNmCluster] iterate over all coupled NmClusters UdpNmClusterSettings \u00b6 UdpNmClusterSettings( *, nm_msg_cycle_time: float, nm_msg_timeout_time: float, nm_network_timeout: float, nm_remote_sleep_indication_time: float, nm_repeat_message_time: float, nm_wait_bus_sleep_time: float, ) UdpNmClusterSettings encapsulates the mandatory settings for a UdpNmCluster nm_msg_cycle_time instance-attribute \u00b6 nm_msg_cycle_time: float Period of an NmPdu in seconds nm_msg_timeout_time instance-attribute \u00b6 nm_msg_timeout_time: float Timeout of a NmPdu in seconds nm_network_timeout instance-attribute \u00b6 nm_network_timeout: float Network Timeout for NmPdus in seconds nm_remote_sleep_indication_time instance-attribute \u00b6 nm_remote_sleep_indication_time: float Timeout for Remote Sleep Indication in seconds nm_repeat_message_time instance-attribute \u00b6 nm_repeat_message_time: float Timeout for Repeat Message State in seconds nm_wait_bus_sleep_time instance-attribute \u00b6 nm_wait_bus_sleep_time: float Timeout for bus calm down phase in seconds UdpNmNode \u00b6 UdpNmNode(element: Element) Udp / Ethernet specific NmNode all_nm_messages_keep_awake instance-attribute \u00b6 all_nm_messages_keep_awake: Optional[bool] set ot remove the allNmMessagesKeepAwake flag If enabled is Some , the flag is set to the value of enabled . If enabled is None , the flag is removed. communication_controller instance-attribute \u00b6 communication_controller: Optional[ EthernetCommunicationController ] get or set the referenced EthernetCommunicationController element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str nm_ecu instance-attribute \u00b6 nm_ecu: Optional[NmEcu] get or set the referenced NmEcu nm_msg_cycle_offset instance-attribute \u00b6 nm_msg_cycle_offset: Optional[float] get or set the NmMsgCycleOffset node_id instance-attribute \u00b6 node_id: Optional[int] set the nmNodeId passive_mode instance-attribute \u00b6 passive_mode: Optional[bool] set ot remove the nmPassiveModeEnabled flag add_rx_nm_pdu \u00b6 add_rx_nm_pdu(nm_pdu: NmPdu) -> None add an Rx NmPdu Every NmNode must have at least one Rx NmPdu add_tx_nm_pdu \u00b6 add_tx_nm_pdu(nm_pdu: NmPdu) -> None add a Tx NmPdu Active NmNodes must have at least one Tx NmPdu , while passive NmNodes may have none. rx_nm_pdus \u00b6 rx_nm_pdus() -> Iterator[NmPdu] iterate over all RX NmPdus tx_nm_pdus \u00b6 tx_nm_pdus() -> Iterator[NmPdu] iterate over all TX NmPdus","title":"Communication"},{"location":"communication_api/#api-documentation-autosar_dataabstractioncommunication","text":"","title":"API Documentation: autosar_data.abstraction.communication"},{"location":"communication_api/#examples","text":"","title":"Examples"},{"location":"communication_api/#can","text":"from autosar_data.abstraction import * from autosar_data.abstraction.communication import * model = AutosarModelAbstraction.create(\"can_example.arxml\") package = model.get_or_create_package(\"/Package\") # basic model elements system = package.create_system(\"system\", SystemCategory.EcuExtract) ecu = system.create_ecu_instance(\"Ecu\", package) can_cluster = system.create_can_cluster(\"CanBus\", package) can_channel = can_cluster.create_physical_channel(\"CanChannel\") ecu_can_ctrl = ecu.create_can_communication_controller(\"CanController\") ecu_can_ctrl.connect_physical_channel(\"Connection\", can_channel) # communication elements frame = system.create_can_frame(\"Frame\", package, 8) can_channel.trigger_frame(frame, 0x101, CanAddressingMode.Standard, CanFrameType.Can20) isignal_ipdu = system.create_isignal_ipdu(\"Pdu\", package, 8) frame.map_pdu(isignal_ipdu, 0, ByteOrder.MostSignificantByteLast) syssignal = package.create_system_signal(\"SysSignal\") signal = system.create_isignal(\"Signal\", package, 12, syssignal) isignal_ipdu.map_signal(signal, 0, ByteOrder.MostSignificantByteLast) signal.init_value = 1","title":"CAN"},{"location":"communication_api/#ethernet-old","text":"The way ethernet networks are modeled was changed substantially in Autosar 4.5.0 ( AUTOSAR_00048 ). This example shows the old way, which still exists but is deprecated. from autosar_data import AutosarVersion from autosar_data.abstraction import * from autosar_data.abstraction.communication import * model = AutosarModelAbstraction.create( \"ethernet_old.arxml\", version=AutosarVersion.AUTOSAR_00047 ) package = model.get_or_create_package(\"/Package\") # basic model elements system = package.create_system(\"system\", SystemCategory.EcuExtract) ecu = system.create_ecu_instance(\"Ecu\", package) eth_cluster = system.create_ethernet_cluster(\"EthCluster\", package) eth_channel = eth_cluster.create_physical_channel( \"EthChannel\", vlan_info=EthernetVlanInfo(vlan_name=\"VLAN_12\", vlan_id=12) ) ecu_eth_ctrl = ecu.create_ethernet_communication_controller(\"EthCtrl\") ecu_eth_ctrl.connect_physical_channel(\"Connection\", eth_channel) # network addresses ecu_address = eth_channel.create_network_endpoint( \"ecu_address\", NetworkEndpointAddress.IPv4(address=\"192.168.12.100\"), ecu=ecu ) remote_address = eth_channel.create_network_endpoint( \"remote_address\", NetworkEndpointAddress.IPv4(address=\"ANY\") ) # create network sockets ecu_socket = eth_channel.create_socket_address( \"ecu_socket\", ecu_address, TpConfig.UdpTp(port_number=1234), SocketAddressType.Unicast(ecu), ) remote_socket = eth_channel.create_socket_address( \"remote_socket\", remote_address, TpConfig.UdpTp(port_number=1234), SocketAddressType.Unicast(None), ) # socket connection bundles handle the connection between sockets socket_connection_bundle = eth_channel.create_socket_connection_bundle( \"SCB\", ecu_socket ) socket_connection = socket_connection_bundle.create_bundled_connection(remote_socket) # create a PDU and associate it with the socket connection idpu = system.create_isignal_ipdu(\"PDU\", package, 16) socket_connection.create_socket_connection_ipdu_identifier(idpu, 0xBEEF) # signals could be mapped to the PDU [...]","title":"Ethernet (old)"},{"location":"communication_api/#ethernet-new","text":"This example shows the new way of modeling an ethernet network which was introduced in Autosar 4.5.0 ( AUTOSAR_00048 ). from autosar_data import AutosarVersion from autosar_data.abstraction import * from autosar_data.abstraction.communication import * model = AutosarModelAbstraction.create( \"ethernet_new.arxml\", version=AutosarVersion.LATEST ) package = model.get_or_create_package(\"/Package\") # basic model elements system = package.create_system(\"system\", SystemCategory.EcuExtract) ecu = system.create_ecu_instance(\"Ecu\", package) eth_cluster = system.create_ethernet_cluster(\"EthCluster\", package) eth_channel = eth_cluster.create_physical_channel( \"EthChannel\", vlan_info=EthernetVlanInfo(vlan_name=\"VLAN_12\", vlan_id=12) ) ecu_eth_ctrl = ecu.create_ethernet_communication_controller(\"EthCtrl\") ecu_eth_ctrl.connect_physical_channel(\"Connection\", eth_channel) # network addresses ecu_address = eth_channel.create_network_endpoint( \"ecu_address\", NetworkEndpointAddress.IPv4(address=\"192.168.12.100\"), ecu=ecu ) remote_address = eth_channel.create_network_endpoint( \"remote_address\", NetworkEndpointAddress.IPv4(address=\"ANY\") ) # create network sockets ecu_socket = eth_channel.create_socket_address( \"ecu_socket\", ecu_address, TpConfig.UdpTp(port_number=1234), SocketAddressType.Unicast(ecu), ) remote_socket = eth_channel.create_socket_address( \"remote_socket\", remote_address, TpConfig.UdpTp(port_number=1234), SocketAddressType.Unicast(None), ) # socket connection bundles handle the connection between sockets static_socket_connection = ecu_socket.create_static_socket_connection( \"StaticConnection\", remote_socket ) pdu = system.create_isignal_ipdu(\"Pdu\", package, 33) ipdu_identifier_set = system.create_socket_connection_ipdu_identifier_set( \"IpduIdentifierSet\", package ) ipdu_identifier = ipdu_identifier_set.create_socon_ipdu_identifier( \"IPduIdentifier\", pdu, eth_channel ) static_socket_connection.add_ipdu_identifier(ipdu_identifier)","title":"Ethernet (new)"},{"location":"communication_api/#flexray","text":"from autosar_data import AutosarVersion from autosar_data.abstraction import * from autosar_data.abstraction.communication import * model = AutosarModelAbstraction.create(\"flexray.arxml\") package = model.get_or_create_package(\"/Package\") # basic model elements system = package.create_system(\"system\", SystemCategory.EcuExtract) ecu = system.create_ecu_instance(\"Ecu\", package) flx_cluster_settings = FlexrayClusterSettings() flx_cluster_settings.baudrate = 10_000_000 # customize other cluster settings ... flx_cluster = system.create_flexray_cluster( \"FlexrayCluster\", package, flx_cluster_settings ) flx_channel = flx_cluster.create_physical_channel( \"FlexrayChannel\", FlexrayChannelName.A ) ecu_flx_ctrl = ecu.create_flexray_communication_controller(\"FlexrayController\") # communication elements frame = system.create_flexray_frame(\"Frame\", package, 32) flx_channel.trigger_frame( frame, 1, FlexrayCommunicationCycle.Repetition(1, CycleRepetition.C1) ) isignal_ipdu = system.create_isignal_ipdu(\"Pdu\", package, 32) frame.map_pdu(isignal_ipdu, 0, ByteOrder.MostSignificantByteLast) syssignal = package.create_system_signal(\"SysSignal\") signal = system.create_isignal(\"Signal\", package, 12, syssignal) isignal_ipdu.map_signal(signal, 0, ByteOrder.MostSignificantByteLast) signal.init_value = 1","title":"Flexray"},{"location":"communication_api/#api","text":"","title":"API"},{"location":"communication_api/#autosar_data.abstraction.communication","text":"","title":"communication"},{"location":"communication_api/#autosar_data.abstraction.communication.Cluster","text":"Cluster: TypeAlias = Union[ CanCluster, FlexrayCluster, EthernetCluster ]","title":"Cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.CommunicationController","text":"CommunicationController: TypeAlias = Union[ CanCommunicationController, FlexrayCommunicationController, EthernetCommunicationController, ]","title":"CommunicationController"},{"location":"communication_api/#autosar_data.abstraction.communication.Frame","text":"Frame: TypeAlias = Union[CanFrame, FlexrayFrame]","title":"Frame"},{"location":"communication_api/#autosar_data.abstraction.communication.IPdu","text":"IPdu: TypeAlias = Union[ ContainerIPdu, DcmIPdu, GeneralPurposeIPdu, ISignalIPdu, SecuredIPdu, NPdu, MultiplexedIPdu, ]","title":"IPdu"},{"location":"communication_api/#autosar_data.abstraction.communication.Pdu","text":"Pdu: TypeAlias = Union[ ContainerIPdu, DcmIPdu, GeneralPurposePdu, GeneralPurposeIPdu, NPdu, ISignalIPdu, NmPdu, SecuredIPdu, MultiplexedIPdu, ]","title":"Pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.PhysicalChannel","text":"PhysicalChannel: TypeAlias = Union[ CanPhysicalChannel, FlexrayPhysicalChannel, EthernetPhysicalChannel, ]","title":"PhysicalChannel"},{"location":"communication_api/#autosar_data.abstraction.communication.TransformationTechnologyConfig","text":"TransformationTechnologyConfig: TypeAlias = Union[ ComTransformationTechnologyConfig, E2ETransformationTechnologyConfig, SomeIpTransformationTechnologyConfig, GenericTransformationTechnologyConfig, ]","title":"TransformationTechnologyConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.CanAddressingMode","text":"The addressing mode for a CAN frame","title":"CanAddressingMode"},{"location":"communication_api/#autosar_data.abstraction.communication.CanAddressingMode.Extended","text":"Extended: CanAddressingMode","title":"Extended"},{"location":"communication_api/#autosar_data.abstraction.communication.CanAddressingMode.Standard","text":"Standard: CanAddressingMode","title":"Standard"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCluster","text":"CanCluster(element: Element) A CanCluster contains all configuration items associated with a CAN network. The cluster connects multiple ECUs.","title":"CanCluster"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCluster.baudrate","text":"baudrate: int get or set the baudrate of the cluster","title":"baudrate"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCluster.can_fd_baudrate","text":"can_fd_baudrate: Optional[int] get or set the CAN FD baudrate of the cluster","title":"can_fd_baudrate"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCluster.can_xl_baudrate","text":"can_xl_baudrate: Optional[int] get or set the CAN XL baudrate of the cluster","title":"can_xl_baudrate"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCluster.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCluster.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCluster.physical_channel","text":"physical_channel: Optional[CanPhysicalChannel] get or set the settings of this CanCluster with new values for the baudrates","title":"physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCluster.system","text":"system: Optional[System] get the System that contains this CanCluster","title":"system"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCluster.create_physical_channel","text":"create_physical_channel( channel_name: str, ) -> CanPhysicalChannel Create a new physical channel for the cluster A can cluster must contain exactly one physical channel; trying to add a second one triggers an error.","title":"create_physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCommunicationConnector","text":"CanCommunicationConnector(element: Element) A connector between a [ CanCommunicationController ] in an ECU and a [ CanPhysicalChannel ]","title":"CanCommunicationConnector"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCommunicationConnector.controller","text":"controller: CanCommunicationController Get the controller of the CommunicationConnector","title":"controller"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCommunicationConnector.ecu_instance","text":"ecu_instance: EcuInstance EcuInstance that contains this CommunicationConnector","title":"ecu_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCommunicationConnector.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCommunicationConnector.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCommunicationController","text":"CanCommunicationController(element: Element) An EcuInstance needs a CanCommunicationController in order to connect to a CAN cluster.","title":"CanCommunicationController"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCommunicationController.ecu_instance","text":"ecu_instance: EcuInstance Get the EcuInstance that contains this CanCommunicationController","title":"ecu_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCommunicationController.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCommunicationController.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCommunicationController.connect_physical_channel","text":"connect_physical_channel( connection_name: str, can_channel: CanPhysicalChannel ) -> CanCommunicationConnector Connect this [ CanCommunicationController ] inside an [ EcuInstance ] to a [ CanPhysicalChannel ] in the [ crate::System ] Creates a [ CanCommunicationConnector ] in the [ EcuInstance ] that contains this [ CanCommunicationController ]. This function establishes the relationships [ CanPhysicalChannel ] -> [ CanCommunicationConnector ] [ CanCommunicationConnector ] -> [ CanCommunicationController ]","title":"connect_physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.CanCommunicationController.connected_channels","text":"connected_channels() -> Iterator[CanPhysicalChannel] return an iterator over the [ CanPhysicalChannel ]s connected to this controller","title":"connected_channels"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrame","text":"CanFrame(element: Element) A frame on a CAN bus","title":"CanFrame"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrame.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrame.length","text":"length: Optional[int] length of the frame","title":"length"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrame.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrame.frame_triggerings","text":"frame_triggerings() -> List[CanFrameTriggering] List all [ FrameTriggering ]s using this frame","title":"frame_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrame.map_pdu","text":"map_pdu( pdu: Pdu, start_position: int, byte_order: ByteOrder, /, *, update_bit: Optional[int] = None, ) -> PduToFrameMapping map a PDU to the frame","title":"map_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrame.mapped_pdus","text":"mapped_pdus() -> Iterator[Pdu] returns an iterator over all PDUs in the frame","title":"mapped_pdus"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameTriggering","text":"CanFrameTriggering(element: Element) The frame triggering connects a frame to a physical channel","title":"CanFrameTriggering"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameTriggering.addressing_mode","text":"addressing_mode: Optional[CanAddressingMode] set the addressing mode for this frame triggering","title":"addressing_mode"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameTriggering.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameTriggering.frame","text":"frame: Optional[CanFrame] get the frame associated with this frame triggering","title":"frame"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameTriggering.frame_type","text":"frame_type: Optional[CanFrameType] frame type for this frame triggering","title":"frame_type"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameTriggering.identifier","text":"identifier: Optional[int] can id associated with this frame","title":"identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameTriggering.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameTriggering.physical_channel","text":"physical_channel: CanPhysicalChannel get the physical channel that contains this frame triggering","title":"physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameTriggering.connect_to_ecu","text":"connect_to_ecu( ecu: EcuInstance, direction: CommunicationDirection ) -> FramePort connect this frame triggering to an ECU The direction parameter specifies if the communication is incoming or outgoing","title":"connect_to_ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameTriggering.frame_ports","text":"frame_ports() -> Iterator[FramePort] iterate over all frame ports for this frame triggering","title":"frame_ports"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameTriggering.pdu_triggerings","text":"pdu_triggerings() -> Iterator[PduTriggering] iterate over all PDU triggerings referenced by the frame triggering","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameType","text":"The type of a CAN frame","title":"CanFrameType"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameType.Any","text":"Any: CanFrameType","title":"Any"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameType.Can20","text":"Can20: CanFrameType","title":"Can20"},{"location":"communication_api/#autosar_data.abstraction.communication.CanFrameType.CanFd","text":"CanFd: CanFrameType","title":"CanFd"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster","text":"CanNmCluster(element: Element) Can specific NmCluster attributes","title":"CanNmCluster"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.channel_sleep_master","text":"channel_sleep_master: Optional[bool] set or remove the nmChannelSleepMaster flag","title":"channel_sleep_master"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.communication_cluster","text":"communication_cluster: Optional[CanCluster] get or set the referenced CanCluster","title":"communication_cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.nm_busload_reduction_active","text":"nm_busload_reduction_active: Optional[bool] nmBusloadReductionActive flag","title":"nm_busload_reduction_active"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.nm_immediate_nm_transmissions","text":"nm_immediate_nm_transmissions: Optional[int] nmImmediateNmTransmissions value","title":"nm_immediate_nm_transmissions"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.nm_message_timeout_time","text":"nm_message_timeout_time: Optional[float] get or set the nmMessageTimeoutTime","title":"nm_message_timeout_time"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.nm_msg_cycle_time","text":"nm_msg_cycle_time: Optional[float] get or set the nmMsgCycleTime","title":"nm_msg_cycle_time"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.nm_network_timeout","text":"nm_network_timeout: Optional[float] get or set the nmNetworkTimeout","title":"nm_network_timeout"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.nm_remote_sleep_indication_time","text":"nm_remote_sleep_indication_time: Optional[float] get or set the nmRemoteSleepIndicationTime","title":"nm_remote_sleep_indication_time"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.nm_repeat_message_time","text":"nm_repeat_message_time: Optional[float] get or set the nmRepeatMessageTime","title":"nm_repeat_message_time"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.nm_wait_bus_sleep_time","text":"nm_wait_bus_sleep_time: Optional[float] get or set the nmWaitBusSleepTime","title":"nm_wait_bus_sleep_time"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.node_detection_enabled","text":"node_detection_enabled: Optional[bool] get or set the nmNodeDetectionEnabled flag","title":"node_detection_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.node_id_enabled","text":"node_id_enabled: Optional[bool] get or set the nmNodeIdEnabled flag","title":"node_id_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.pnc_cluster_vector_length","text":"pnc_cluster_vector_length: Optional[int] get or set the pncClusterVectorLength","title":"pnc_cluster_vector_length"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.pnc_participation","text":"pnc_participation: Optional[bool] get or set the nmPncParticipation flag","title":"pnc_participation"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.repeat_msg_ind_enabled","text":"repeat_msg_ind_enabled: Optional[bool] get or set the nmRepeatMsgIndEnabled flag","title":"repeat_msg_ind_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.synchronizing_network","text":"synchronizing_network: Optional[bool] get or set the nmSynchronizingNetwork flag","title":"synchronizing_network"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.create_can_nm_node","text":"create_can_nm_node( name: str, controller: CanCommunicationController, nm_ecu: NmEcu, ) -> CanNmNode add a CanNmNode to the cluster","title":"create_can_nm_node"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmCluster.nm_nodes","text":"nm_nodes() -> Iterator[CanNmNode] iterate over all NmNodes in this cluster","title":"nm_nodes"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterCoupling","text":"CanNmClusterCoupling(element: Element) A CanNmClusterCoupling couples multiple CanNmCluster s, and contains CAN specific settings.","title":"CanNmClusterCoupling"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterCoupling.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterCoupling.nm_busload_reduction_enabled","text":"nm_busload_reduction_enabled: Optional[bool] get or set the nmBusloadReductionEnabled flag","title":"nm_busload_reduction_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterCoupling.nm_immediate_restart_enabled","text":"nm_immediate_restart_enabled: Optional[bool] get or set the nmImmediateRestartEnabled flag","title":"nm_immediate_restart_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterCoupling.add_coupled_cluster","text":"add_coupled_cluster(cluster: CanNmCluster) -> None add a reference to a coupled NmCluster","title":"add_coupled_cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterCoupling.coupled_clusters","text":"coupled_clusters() -> Iterator[CanNmCluster] iterate over all coupled NmClusters","title":"coupled_clusters"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterSettings","text":"CanNmClusterSettings( *, nm_busload_reduction_active: bool, nm_immediate_nm_transmissions: int, nm_message_timeout_time: float, nm_msg_cycle_time: float, nm_network_timeout: float, nm_remote_sleep_indication_time: float, nm_repeat_message_time: float, nm_wait_bus_sleep_time: float, ) Mandatory settings for a CanNmCluster These settings are mandatory for a CanNmCluster and must be set during creation. Additional optional settings can be set using the CanNmCluster methods.","title":"CanNmClusterSettings"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterSettings.nm_busload_reduction_active","text":"nm_busload_reduction_active: bool nmBusloadReductionActive: Determines if bus load reduction for the respective CanNm channel is active.","title":"nm_busload_reduction_active"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterSettings.nm_immediate_nm_transmissions","text":"nm_immediate_nm_transmissions: int nmImmediateNmTransmissions: Defines the number of immediate NmPdus which shall be transmitted. If the value is zero no immediate NmPdus are transmitted.","title":"nm_immediate_nm_transmissions"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterSettings.nm_message_timeout_time","text":"nm_message_timeout_time: float nmMessageTimeoutTime: Timeout of an NmPdu in seconds.","title":"nm_message_timeout_time"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterSettings.nm_msg_cycle_time","text":"nm_msg_cycle_time: float nmMsgCycleTime: Period of a NmPdu in seconds","title":"nm_msg_cycle_time"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterSettings.nm_network_timeout","text":"nm_network_timeout: float nmNetworkTimeout: Network Timeout for NmPdus in seconds.","title":"nm_network_timeout"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterSettings.nm_remote_sleep_indication_time","text":"nm_remote_sleep_indication_time: float nmRemoteSleepIndicationTime: Timeout for Remote Sleep Indication in seconds.","title":"nm_remote_sleep_indication_time"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterSettings.nm_repeat_message_time","text":"nm_repeat_message_time: float nmRepeatMessageTime: Timeout for Repeat Message State in seconds.","title":"nm_repeat_message_time"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmClusterSettings.nm_wait_bus_sleep_time","text":"nm_wait_bus_sleep_time: float nmWaitBusSleepTime: Timeout for bus calm down phase in seconds.","title":"nm_wait_bus_sleep_time"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmNode","text":"CanNmNode(element: Element) A CanNmNode represents a node in a CanNmCluster . The node connects to a CanCommunicationController and an NmEcu .","title":"CanNmNode"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmNode.communication_controller","text":"communication_controller: Optional[ CanCommunicationController ] get or set the referenced CanCommunicationController","title":"communication_controller"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmNode.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmNode.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmNode.nm_ecu","text":"nm_ecu: Optional[NmEcu] get or set the referenced NmEcu","title":"nm_ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmNode.node_id","text":"node_id: Optional[int] get or set the nmNodeId This value is optional; if it is set to Some(x) the value is created, if it is set to None the value is removed.","title":"node_id"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmNode.passive_mode","text":"passive_mode: Optional[bool] get or set ot remove the nmPassiveModeEnabled flag This flag is optional; if it is set to Some(x) the value is created, if it is set to None the value is removed.","title":"passive_mode"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmNode.add_rx_nm_pdu","text":"add_rx_nm_pdu(nm_pdu: NmPdu) -> None add an Rx NmPdu Every NmNode must have at least one Rx NmPdu","title":"add_rx_nm_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmNode.add_tx_nm_pdu","text":"add_tx_nm_pdu(nm_pdu: NmPdu) -> None add a Tx NmPdu Active NmNodes must have at least one Tx NmPdu , while passive NmNodes may have none.","title":"add_tx_nm_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmNode.rx_nm_pdus","text":"rx_nm_pdus() -> Iterator[NmPdu] iterate over all RX NmPdus","title":"rx_nm_pdus"},{"location":"communication_api/#autosar_data.abstraction.communication.CanNmNode.tx_nm_pdus","text":"tx_nm_pdus() -> Iterator[NmPdu] iterate over all TX NmPdus","title":"tx_nm_pdus"},{"location":"communication_api/#autosar_data.abstraction.communication.CanPhysicalChannel","text":"CanPhysicalChannel(element: Element) The `CanPhysicalChannel contains all of the communication on a CAN network","title":"CanPhysicalChannel"},{"location":"communication_api/#autosar_data.abstraction.communication.CanPhysicalChannel.cluster","text":"cluster: CanCluster get the cluster containing this physical channel","title":"cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.CanPhysicalChannel.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanPhysicalChannel.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.CanPhysicalChannel.frame_triggerings","text":"frame_triggerings() -> Iterator[CanFrameTriggering] iterate over all frame triggerings of this physical channel","title":"frame_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.CanPhysicalChannel.pdu_triggerings","text":"pdu_triggerings() -> Iterator[PduTriggering] iterate over all PDU triggerings of this physical channel","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.CanPhysicalChannel.signal_triggerings","text":"signal_triggerings() -> Iterator[ISignalTriggering] iterate over all signal triggerings of this physical channel","title":"signal_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.CanPhysicalChannel.trigger_frame","text":"trigger_frame( frame: CanFrame, identifier: int, addressing_mode: CanAddressingMode, frame_type: CanFrameType, ) -> CanFrameTriggering add a trigger for a CAN frame in this physical channel","title":"trigger_frame"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpAddress","text":"CanTpAddress(element: Element) A CanTpAddress represents a logical address in the CanTp module","title":"CanTpAddress"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpAddress.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpAddress.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpAddress.tp_address","text":"tp_address: Optional[int] get or set the address of the CanTpAddress","title":"tp_address"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpAddressingFormat","text":"The addressing format of a CanTpConnection","title":"CanTpAddressingFormat"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpAddressingFormat.Extended","text":"Extended: CanTpAddressingFormat","title":"Extended"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpAddressingFormat.Mixed","text":"Mixed: CanTpAddressingFormat","title":"Mixed"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpAddressingFormat.Mixed29Bit","text":"Mixed29Bit: CanTpAddressingFormat","title":"Mixed29Bit"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpAddressingFormat.NormalFixed","text":"NormalFixed: CanTpAddressingFormat","title":"NormalFixed"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpAddressingFormat.Standard","text":"Standard: CanTpAddressingFormat","title":"Standard"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpChannel","text":"CanTpChannel(element: Element) A CanTpChannel represents a channel in the CanTp module","title":"CanTpChannel"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpChannel.channel_id","text":"channel_id: Optional[int] get or set the channel id of the channel","title":"channel_id"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpChannel.channel_mode","text":"channel_mode: Optional[CanTpChannelMode] get or set the channel mode of the channel","title":"channel_mode"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpChannel.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpChannel.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpChannelMode","text":"The mode of a CanTpChannel","title":"CanTpChannelMode"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpChannelMode.FullDuplex","text":"FullDuplex: CanTpChannelMode","title":"FullDuplex"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpChannelMode.HalfDuplex","text":"HalfDuplex: CanTpChannelMode","title":"HalfDuplex"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig","text":"CanTpConfig(element: Element) Container for CanTp configuration There should be one CanTpConfig for each CAN network in the system","title":"CanTpConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.cluster","text":"cluster: Optional[CanCluster] get or set the CanCluster associated with this configuration","title":"cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.can_tp_addresses","text":"can_tp_addresses() -> Iterator[CanTpAddress] get all of the Can Tp addresses in the configuration","title":"can_tp_addresses"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.can_tp_channels","text":"can_tp_channels() -> Iterator[CanTpChannel] iterate over all CanTpChannel s in the configuration","title":"can_tp_channels"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.can_tp_connections","text":"can_tp_connections() -> Iterator[CanTpConnection] get all of the CanTpConnections in the configuration","title":"can_tp_connections"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.can_tp_ecus","text":"can_tp_ecus() -> Iterator[CanTpEcu] get an iterator over all ECUs in the configuration","title":"can_tp_ecus"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.can_tp_nodes","text":"can_tp_nodes() -> Iterator[CanTpNode] get all of the CanTpNodes in the configuration","title":"can_tp_nodes"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.create_can_tp_address","text":"create_can_tp_address( name: str, address: int ) -> CanTpAddress create a new CanTpAddress in the configuration","title":"create_can_tp_address"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.create_can_tp_channel","text":"create_can_tp_channel( name: str, channel_id: int, mode: CanTpChannelMode ) -> CanTpChannel create a new CanTpChannel in the configuration","title":"create_can_tp_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.create_can_tp_connection","text":"create_can_tp_connection( name: Optional[str], addressing_format: CanTpAddressingFormat, can_tp_channel: CanTpChannel, data_pdu: NPdu, tp_sdu: IPdu, padding_activation: bool, ) -> CanTpConnection create a new CanTpConnection in the configuration","title":"create_can_tp_connection"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.create_can_tp_ecu","text":"create_can_tp_ecu( ecu_instance: EcuInstance, /, *, cycle_time_main_function: Optional[float] = None, ) -> CanTpEcu create a CanTp ECU in the configuration","title":"create_can_tp_ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConfig.create_can_tp_node","text":"create_can_tp_node(name: str) -> CanTpNode create a new CanTpNode in the configuration","title":"create_can_tp_node"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConnection","text":"CanTpConnection(element: Element) A connection identifies the sender and the receiver of this particular communication. The CanTp module routes a Pdu through this connection.","title":"CanTpConnection"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConnection.addressing_format","text":"addressing_format: Optional[CanTpAddressingFormat] get or set the addressing format of the connection","title":"addressing_format"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConnection.channel","text":"channel: Optional[CanTpChannel] get or set the CanTpChannel associated with this connection","title":"channel"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConnection.data_pdu","text":"data_pdu: Optional[NPdu] get or set the NPdu associated with this connection","title":"data_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConnection.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConnection.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConnection.padding_activation","text":"padding_activation: Optional[bool] get or set the padding activation of the connection","title":"padding_activation"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConnection.tp_sdu","text":"tp_sdu: Optional[IPdu] get or set the IPdu associated with this connection","title":"tp_sdu"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConnection.transmitter","text":"transmitter: Optional[CanTpNode] set the transmitter of the connection This is a CanTpNode representing an ECU that will send the data","title":"transmitter"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConnection.add_receiver","text":"add_receiver(receiver: CanTpNode) -> None add a receiver to the connection This is a CanTpNode representing an ECU that will receive the data","title":"add_receiver"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpConnection.receivers","text":"receivers() -> Iterator[CanTpNode] get all of the receivers of the connection","title":"receivers"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpEcu","text":"CanTpEcu(element: Element) A CanTpEcu represents an ECU that is using the CanTp module","title":"CanTpEcu"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpEcu.cycle_time_main_function","text":"cycle_time_main_function: Optional[float] get or set the cycle time of the CanTp main function of the ECU","title":"cycle_time_main_function"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpEcu.ecu_instance","text":"ecu_instance: Optional[EcuInstance] get or set the ECU instance of the CanTpEcu","title":"ecu_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpEcu.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpNode","text":"CanTpNode(element: Element) A CanTpNode provides the TP address and the connection to the topology description in a CanTpConfig","title":"CanTpNode"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpNode.address","text":"address: Optional[CanTpAddress] get or set the CanTpAddress of this Node","title":"address"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpNode.connector","text":"connector: Optional[CanCommunicationConnector] set the reference to a CanCommunicationConnector between an EcuInstance and a CanPhysicalChannel The connector connects the ECU to the physical channel, so by setting this reference, the ECU is also connected to the CanTpNode","title":"connector"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpNode.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.CanTpNode.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ComTransformationTechnologyConfig","text":"ComTransformationTechnologyConfig( *, isignal_ipdu_length: int ) Configuration for a COM transformation","title":"ComTransformationTechnologyConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.ComTransformationTechnologyConfig.isignal_ipdu_length","text":"isignal_ipdu_length: int The length of the ISignalIpdu tha will be transformed by this Com transformer. The value is only used up to AUTOSAR R20-11 ( AUTOSAR_00049 ), where it is needed to calculate the buffer size.","title":"isignal_ipdu_length"},{"location":"communication_api/#autosar_data.abstraction.communication.CommonServiceDiscoveryConfig","text":"CommonServiceDiscoveryConfig( *, multicast_rx_socket: SocketAddress, multicast_rx_pdu: GeneralPurposePdu, remote_socket: SocketAddress, prefer_static_socket_connections: bool, ipdu_identifier_set: Optional[ SocketConnectionIpduIdentifierSet ] = None, name_prefix: Optional[str] = None, ) A CommonServiceDiscoveryConfig contains common configuration settings for System::configure_service_discovery_for_ecu . This struct contains ECU-independent settings that should be re-used for all ECUs that are configured for SD.","title":"CommonServiceDiscoveryConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.CommonServiceDiscoveryConfig.ipdu_identifier_set","text":"ipdu_identifier_set: Optional[ SocketConnectionIpduIdentifierSet ] an ipdu identifier set in which PduTriggerings are created. Only needed for StaticSocketConnections .","title":"ipdu_identifier_set"},{"location":"communication_api/#autosar_data.abstraction.communication.CommonServiceDiscoveryConfig.multicast_rx_pdu","text":"multicast_rx_pdu: GeneralPurposeIPdu the multicast rx PDU used by all SD ECUs","title":"multicast_rx_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.CommonServiceDiscoveryConfig.multicast_rx_socket","text":"multicast_rx_socket: SocketAddress the socket address used for multicast rx by all SD ECUs","title":"multicast_rx_socket"},{"location":"communication_api/#autosar_data.abstraction.communication.CommonServiceDiscoveryConfig.name_prefix","text":"name_prefix: Optional[str] an optional prefix for the names of the created elements","title":"name_prefix"},{"location":"communication_api/#autosar_data.abstraction.communication.CommonServiceDiscoveryConfig.prefer_static_socket_connections","text":"prefer_static_socket_connections: bool configure_service_discovery_for_ecu checks if any SocketConnectionBundles exist. If so, the old configuration method must be used. If none are found and the version is new enough, both methods are possible, and this flag determines which one to use.","title":"prefer_static_socket_connections"},{"location":"communication_api/#autosar_data.abstraction.communication.CommonServiceDiscoveryConfig.remote_socket","text":"remote_socket: SocketAddress the remote socket used for SD communication. This socket must have an IP address (v4 or v6) set to ANY.","title":"remote_socket"},{"location":"communication_api/#autosar_data.abstraction.communication.CommunicationDirection","text":"The [ CommunicationDirection ] is used by the communication ports for frames, PDUs and signals","title":"CommunicationDirection"},{"location":"communication_api/#autosar_data.abstraction.communication.CommunicationDirection.In","text":"In: CommunicationDirection","title":"In"},{"location":"communication_api/#autosar_data.abstraction.communication.CommunicationDirection.Out","text":"Out: CommunicationDirection","title":"Out"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroup","text":"ConsumedEventGroup(element: Element) A ConsumedEventGroup is a group of events in a ConsumedServiceInstance that are consumed by an ECU","title":"ConsumedEventGroup"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroup.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroup.event_group_identifier","text":"event_group_identifier: Optional[int] get or set the event group identifier of this ConsumedEventGroup","title":"event_group_identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroup.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroup.sd_client_timer_config","text":"sd_client_timer_config: Optional[ SomeipSdClientEventGroupTimingConfig ] get or set the SD client timer configuration for this ConsumedEventGroup","title":"sd_client_timer_config"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroup.add_event_multicast_address","text":"add_event_multicast_address(address: SocketAddress) -> None add an event multicast address to this ConsumedEventGroup","title":"add_event_multicast_address"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroup.create_pdu_activation_routing_group","text":"create_pdu_activation_routing_group( name: str, event_group_control_type: EventGroupControlType, ) -> PduActivationRoutingGroup create a new PduActivationRoutingGroup in this ConsumedEventGroup","title":"create_pdu_activation_routing_group"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroup.event_multicast_addresses","text":"event_multicast_addresses() -> Iterator[SocketAddress] get the event multicast addresses","title":"event_multicast_addresses"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroup.pdu_activation_routing_groups","text":"pdu_activation_routing_groups() -> Iterator[ PduActivationRoutingGroup ] iterate over the PduActivationRoutingGroup s in this ConsumedEventGroup","title":"pdu_activation_routing_groups"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroupV1","text":"ConsumedEventGroupV1(element: Element) A ConsumedEventGroupV1 is a SD event group of a service instance that is consumed by this ECU. This is the old V1 version of the service definition.","title":"ConsumedEventGroupV1"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroupV1.application_endpoint","text":"application_endpoint: Optional[SocketAddress] set the SocketAddress that receives events from this ConsumedEventGroup This may be a different SocketAddress than the one that is used to send requests.","title":"application_endpoint"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroupV1.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroupV1.event_group_identifier","text":"event_group_identifier: Optional[int] get or set the event group identifier of this ConsumedEventGroup","title":"event_group_identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroupV1.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroupV1.sd_client_config","text":"sd_client_config: Optional[SdEventConfig] get or set the SD client configuration for this ConsumedEventGroup","title":"sd_client_config"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroupV1.add_routing_group","text":"add_routing_group(routing_group: SoAdRoutingGroup) -> None add a reference to a SoAdRoutingGroup to this ConsumedEventGroup","title":"add_routing_group"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroupV1.event_handlers","text":"event_handlers() -> List[EventHandlerV1] list all EventHandlerV1 s that reference this ConsumedEventGroupV1","title":"event_handlers"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedEventGroupV1.routing_groups","text":"routing_groups() -> Iterator[SoAdRoutingGroup] get the routing groups referenced by this ConsumedEventGroup","title":"routing_groups"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstance","text":"ConsumedServiceInstance(element: Element) A ConsumedServiceInstance is a service that is consumed by an ECU","title":"ConsumedServiceInstance"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstance.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstance.instance_identifier","text":"instance_identifier: Optional[int] get or set the instance identifier of this ConsumedServiceInstance","title":"instance_identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstance.major_version","text":"major_version: Optional[int] get or set the major version of this ConsumedServiceInstance","title":"major_version"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstance.minor_version","text":"minor_version: Optional[Union[int, str]] get or set the minor version of this ConsumedServiceInstance The minor version can be a number or the String \"ANY\".","title":"minor_version"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstance.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstance.sd_client_instance_config","text":"sd_client_instance_config: Optional[ SomeipSdClientServiceInstanceConfig ] get or set the SD client instance configuration for this ConsumedServiceInstance","title":"sd_client_instance_config"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstance.service_identifier","text":"service_identifier: Optional[int] get or set the service identifier of this ConsumedServiceInstance","title":"service_identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstance.consumed_event_groups","text":"consumed_event_groups() -> Iterator[ConsumedEventGroup] get the ConsumedEventGroup s in this ConsumedServiceInstance","title":"consumed_event_groups"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstance.create_consumed_event_group","text":"create_consumed_event_group( name: str, event_group_identifier: int ) -> ConsumedEventGroup create a new ConsumedEventGrup in this ConsumedServiceInstance","title":"create_consumed_event_group"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstance.local_unicast_addresses","text":"local_unicast_addresses() -> Iterator[SocketAddress] iterate over the local unicast addresses","title":"local_unicast_addresses"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstance.set_local_unicast_address","text":"set_local_unicast_address(address: SocketAddress) -> None set a local unicast address for this ConsumedServiceInstance The CSI may use two local unicast addresses, one each for UDP and TCP. If the consumed service instance does not specify a local unicast address because it only receives multicast messages, then the ConsumedEventGroup must have an eventMulticastAddress.","title":"set_local_unicast_address"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstanceV1","text":"ConsumedServiceInstanceV1(element: Element) A ConsumedServiceInstanceV1 is a SD service instance that is consumed by this ECU. This is the old V1 version of the service definition.","title":"ConsumedServiceInstanceV1"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstanceV1.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstanceV1.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstanceV1.provided_service_instance","text":"provided_service_instance: Optional[ ProvidedServiceInstanceV1 ] get the ProvidedServiceInstanceV1 referenced by this ConsumedServiceInstanceV1","title":"provided_service_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstanceV1.consumed_event_groups","text":"consumed_event_groups() -> Iterator[ConsumedEventGroupV1] get the ConsumedEventGroup s in this ConsumedServiceInstanceV1","title":"consumed_event_groups"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstanceV1.create_consumed_event_group","text":"create_consumed_event_group( name: str, event_group_identifier: int, event_handler: EventHandlerV1, ) -> ConsumedEventGroupV1 create a new ConsumedEventGroupV1 in this ConsumedServiceInstanceV1","title":"create_consumed_event_group"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstanceV1.sd_client_config","text":"sd_client_config() -> Optional[SdConfig] get the SD client configuration for this ConsumedServiceInstanceV1","title":"sd_client_config"},{"location":"communication_api/#autosar_data.abstraction.communication.ConsumedServiceInstanceV1.set_sd_client_config","text":"set_sd_client_config(sd_client_config: SdConfig) -> None set the SD client configuration for this ConsumedServiceInstanceV1","title":"set_sd_client_config"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainedIPduCollectionSemantics","text":"collection semantics for the ContainedIPdu","title":"ContainedIPduCollectionSemantics"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainedIPduCollectionSemantics.LastIsBest","text":"LastIsBest: ContainedIPduCollectionSemantics","title":"LastIsBest"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainedIPduCollectionSemantics.Queued","text":"Queued: ContainedIPduCollectionSemantics","title":"Queued"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainedIPduProps","text":"ContainedIPduProps( *, collection_semantics: Optional[ ContainedIPduCollectionSemantics ] = None, header_id_long: Optional[int] = None, header_id_short: Optional[int] = None, offset: Optional[int] = None, priority: Optional[int] = None, timeout: Optional[float] = None, trigger: Optional[PduCollectionTrigger] = None, update_indication_bit_position: Optional[int] = None, ) Properties for an IPdu that is transmitted in a container IPdu","title":"ContainedIPduProps"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainedIPduProps.collection_semantics","text":"collection_semantics: Optional[ ContainedIPduCollectionSemantics ] collection semantics: LastIsBest or Queued","title":"collection_semantics"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainedIPduProps.header_id_long","text":"header_id_long: Optional[int] header id of the contained IPdu, used when the header type is LongHeader","title":"header_id_long"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainedIPduProps.header_id_short","text":"header_id_short: Optional[int] header id of the contained IPdu, used when the header type is ShortHeader","title":"header_id_short"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainedIPduProps.offset","text":"offset: Optional[int] offset of the contained IPdu in the container IPdu, used when the header type is NoHeader","title":"offset"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainedIPduProps.priority","text":"priority: Optional[int] priority of the contained IPdu. 255: lowest, 0: highest","title":"priority"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainedIPduProps.timeout","text":"timeout: Optional[float] sender timeout. Ignored on the receiver side","title":"timeout"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainedIPduProps.trigger","text":"trigger: Optional[PduCollectionTrigger] defines whether the contained IPdu triggers transmission of the container IPdu","title":"trigger"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainedIPduProps.update_indication_bit_position","text":"update_indication_bit_position: Optional[int] update indication bit position of the contained IPdu","title":"update_indication_bit_position"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPdu","text":"ContainerIPdu(element: Element) Several IPdus can be collected in one ContainerIPdu based on the headerType","title":"ContainerIPdu"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPdu.contained_ipdu_props","text":"contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu","title":"contained_ipdu_props"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPdu.container_timeout","text":"container_timeout: Optional[float]","title":"container_timeout"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPdu.container_trigger","text":"container_trigger: Optional[ContainerIPduTrigger] get or set the container trigger of this ContainerIPdu","title":"container_trigger"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPdu.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPdu.header_type","text":"header_type: ContainerIPduHeaderType","title":"header_type"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPdu.length","text":"length: Optional[int] get or set the length of this PDU","title":"length"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPdu.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPdu.rx_accept_contained_ipdu","text":"rx_accept_contained_ipdu: Optional[RxAcceptContainedIPdu] get or set the rx accept of this ContainerIPdu","title":"rx_accept_contained_ipdu"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPdu.contained_ipdu_triggerings","text":"contained_ipdu_triggerings() -> Iterator[PduTriggering] iterate over all contained IPdu triggerings","title":"contained_ipdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPdu.map_ipdu","text":"map_ipdu( ipdu: IPdu, physical_channel: PhysicalChannel ) -> PduTriggering map an IPdu to this ContainerIPdu and create a PduTriggering for it in the PhysicalChannel","title":"map_ipdu"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPdu.pdu_triggerings","text":"pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPduHeaderType","text":"The header type of a ContainerIPdu","title":"ContainerIPduHeaderType"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPduHeaderType.LongHeader","text":"LongHeader: ContainerIPduHeaderType","title":"LongHeader"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPduHeaderType.NoHeader","text":"NoHeader: ContainerIPduHeaderType","title":"NoHeader"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPduHeaderType.ShortHeader","text":"ShortHeader: ContainerIPduHeaderType","title":"ShortHeader"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPduTrigger","text":"Defines when the transmission of the ContainerIPdu shall be requested","title":"ContainerIPduTrigger"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPduTrigger.DefaultTrigger","text":"DefaultTrigger: ContainerIPduTrigger","title":"DefaultTrigger"},{"location":"communication_api/#autosar_data.abstraction.communication.ContainerIPduTrigger.FirstContainedTrigger","text":"FirstContainedTrigger: ContainerIPduTrigger","title":"FirstContainedTrigger"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition","text":"The cycle repetition of a Flexray frame, from the Flexray standard","title":"CycleRepetition"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition.C1","text":"C1: CycleRepetition","title":"C1"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition.C10","text":"C10: CycleRepetition","title":"C10"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition.C16","text":"C16: CycleRepetition","title":"C16"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition.C2","text":"C2: CycleRepetition","title":"C2"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition.C20","text":"C20: CycleRepetition","title":"C20"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition.C32","text":"C32: CycleRepetition","title":"C32"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition.C4","text":"C4: CycleRepetition","title":"C4"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition.C40","text":"C40: CycleRepetition","title":"C40"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition.C5","text":"C5: CycleRepetition","title":"C5"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition.C50","text":"C50: CycleRepetition","title":"C50"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition.C64","text":"C64: CycleRepetition","title":"C64"},{"location":"communication_api/#autosar_data.abstraction.communication.CycleRepetition.C8","text":"C8: CycleRepetition","title":"C8"},{"location":"communication_api/#autosar_data.abstraction.communication.CyclicTiming","text":"CyclicTiming( time_period: float, /, *, time_offset: Optional[float] = None, ) Cyclic timing parameters for an IPDU","title":"CyclicTiming"},{"location":"communication_api/#autosar_data.abstraction.communication.CyclicTiming.time_offset","text":"time_offset: Optional[float] delay until the first transmission of the PDU in seconds","title":"time_offset"},{"location":"communication_api/#autosar_data.abstraction.communication.CyclicTiming.time_period","text":"time_period: float period of repetition in seconds","title":"time_period"},{"location":"communication_api/#autosar_data.abstraction.communication.DataIdMode","text":"data ID modes for E2E profiles 01 and 11","title":"DataIdMode"},{"location":"communication_api/#autosar_data.abstraction.communication.DataIdMode.All16Bit","text":"All16Bit: DataIdMode","title":"All16Bit"},{"location":"communication_api/#autosar_data.abstraction.communication.DataIdMode.Alternating8Bit","text":"Alternating8Bit: DataIdMode","title":"Alternating8Bit"},{"location":"communication_api/#autosar_data.abstraction.communication.DataIdMode.Lower12Bit","text":"Lower12Bit: DataIdMode","title":"Lower12Bit"},{"location":"communication_api/#autosar_data.abstraction.communication.DataIdMode.Lower8Bit","text":"Lower8Bit: DataIdMode","title":"Lower8Bit"},{"location":"communication_api/#autosar_data.abstraction.communication.DataTransformation","text":"DataTransformation(element: Element) A DataTransformation is a chain of TransformationTechnology s that are used to transform data","title":"DataTransformation"},{"location":"communication_api/#autosar_data.abstraction.communication.DataTransformation.data_transformation_set","text":"data_transformation_set: Optional[DataTransformationSet] get the DataTransformationSet that contains this DataTransformation","title":"data_transformation_set"},{"location":"communication_api/#autosar_data.abstraction.communication.DataTransformation.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.DataTransformation.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.DataTransformation.transformation_technologies","text":"transformation_technologies() -> Iterator[ TransformationTechnology ] Create an iterator over the TransformationTechnologies in the DataTransformation","title":"transformation_technologies"},{"location":"communication_api/#autosar_data.abstraction.communication.DataTransformationSet","text":"DataTransformationSet(element: Element) A [ DataTransformationSet ] contains DataTransformation s and TransformationTechnology s used in communication Use [ ArPackage::create_data_transformation_set ] to create a new DataTransformationSet","title":"DataTransformationSet"},{"location":"communication_api/#autosar_data.abstraction.communication.DataTransformationSet.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.DataTransformationSet.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.DataTransformationSet.create_data_transformation","text":"create_data_transformation( name: str, transformations: List[TransformationTechnology], execute_despite_data_unavailability: bool, ) -> DataTransformation Create a new DataTransformation in the DataTransformationSet","title":"create_data_transformation"},{"location":"communication_api/#autosar_data.abstraction.communication.DataTransformationSet.create_transformation_technology","text":"create_transformation_technology( name: str, config: TransformationTechnologyConfig ) -> TransformationTechnology Create a new TransformationTechnology in the DataTransformationSet","title":"create_transformation_technology"},{"location":"communication_api/#autosar_data.abstraction.communication.DataTransformationSet.data_transformations","text":"data_transformations() -> Iterator[DataTransformation] Iterate over all DataTransformation s in the DataTransformationSet","title":"data_transformations"},{"location":"communication_api/#autosar_data.abstraction.communication.DataTransformationSet.transformation_technologies","text":"transformation_technologies() -> Iterator[ TransformationTechnology ] Iterate over all TransformationTechnology s in the DataTransformationSet","title":"transformation_technologies"},{"location":"communication_api/#autosar_data.abstraction.communication.DcmIPdu","text":"DcmIPdu(element: Element) Represents the IPdus handled by Dcm","title":"DcmIPdu"},{"location":"communication_api/#autosar_data.abstraction.communication.DcmIPdu.contained_ipdu_props","text":"contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu","title":"contained_ipdu_props"},{"location":"communication_api/#autosar_data.abstraction.communication.DcmIPdu.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.DcmIPdu.length","text":"length: Optional[int] get or set the length of this PDU","title":"length"},{"location":"communication_api/#autosar_data.abstraction.communication.DcmIPdu.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.DcmIPdu.pdu_triggerings","text":"pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpLogicAddress","text":"DoIpLogicAddress(element: Element) This element defines the logical address of a DoIp connection","title":"DoIpLogicAddress"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpLogicAddress.address","text":"address: Optional[int] get or set the address of this DoIpLogicAddress","title":"address"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpLogicAddress.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpLogicAddress.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConfig","text":"DoIpTpConfig(element: Element) Container for DoIp TP configuration","title":"DoIpTpConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConfig.cluster","text":"cluster: Optional[EthernetCluster] get or set the reference to the EthernetCluster for this DoIpTpConfig","title":"cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConfig.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConfig.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConfig.create_doip_logic_address","text":"create_doip_logic_address( name: str, address: int ) -> DoIpLogicAddress create a new DoIpLogicAddress","title":"create_doip_logic_address"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConfig.create_doip_tp_connection","text":"create_doip_tp_connection( name: Optional[str], source: DoIpLogicAddress, target: DoIpLogicAddress, tp_sdu_triggering: PduTriggering, ) -> DoIpTpConnection create a new DoIpTpConnection","title":"create_doip_tp_connection"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConfig.doip_logic_addresses","text":"doip_logic_addresses() -> Iterator[DoIpLogicAddress] iterate over all DoIpLogicAddresss","title":"doip_logic_addresses"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConfig.doip_tp_connections","text":"doip_tp_connections() -> Iterator[DoIpTpConnection] iterate over all DoIpTpConnections","title":"doip_tp_connections"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConnection","text":"DoIpTpConnection(element: Element) The DoIpTpConnection defines a DoIp transport protocol connection","title":"DoIpTpConnection"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConnection.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConnection.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConnection.source","text":"source: Optional[DoIpLogicAddress] get or set the source DoIpLogicAddress","title":"source"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConnection.target","text":"target: Optional[DoIpLogicAddress] get or set the target DoIpLogicAddress","title":"target"},{"location":"communication_api/#autosar_data.abstraction.communication.DoIpTpConnection.tp_sdu_triggering","text":"tp_sdu_triggering: Optional[PduTriggering] get or set the PduTriggering for this connection","title":"tp_sdu_triggering"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile","text":"enumeration of the possible E2E profiles","title":"E2EProfile"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P01","text":"P01: E2EProfile","title":"P01"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P02","text":"P02: E2EProfile","title":"P02"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P04","text":"P04: E2EProfile","title":"P04"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P04m","text":"P04m: E2EProfile","title":"P04m"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P05","text":"P05: E2EProfile","title":"P05"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P06","text":"P06: E2EProfile","title":"P06"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P07","text":"P07: E2EProfile","title":"P07"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P07m","text":"P07m: E2EProfile","title":"P07m"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P08","text":"P08: E2EProfile","title":"P08"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P08m","text":"P08m: E2EProfile","title":"P08m"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P11","text":"P11: E2EProfile","title":"P11"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P22","text":"P22: E2EProfile","title":"P22"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P44","text":"P44: E2EProfile","title":"P44"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfile.P44m","text":"P44m: E2EProfile","title":"P44m"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfileBehavior","text":"there are two standardized behaviors for E2E profiles, which can be selected for each E2E transformation","title":"E2EProfileBehavior"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfileBehavior.PreR4_2","text":"PreR4_2: E2EProfileBehavior","title":"PreR4_2"},{"location":"communication_api/#autosar_data.abstraction.communication.E2EProfileBehavior.R4_2","text":"R4_2: E2EProfileBehavior","title":"R4_2"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig","text":"E2ETransformationTechnologyConfig( *, profile: E2EProfile, zero_header_length: bool, transform_in_place: bool, offset: int, max_delta_counter: int, max_error_state_init: int, max_error_state_invalid: int, max_error_state_valid: int, max_no_new_or_repeated_data: int, min_ok_state_init: int, min_ok_state_invalid: int, min_ok_state_valid: int, window_size: int, window_size_init: Optional[int] = None, window_size_invalid: Optional[int] = None, window_size_valid: Optional[int] = None, profile_behavior: Optional[E2EProfileBehavior] = None, sync_counter_init: Optional[int] = None, data_id_mode: Optional[DataIdMode] = None, data_id_nibble_offset: Optional[int] = None, crc_offset: Optional[int] = None, counter_offset: Optional[int] = None, ) Configuration for an E2E transformation","title":"E2ETransformationTechnologyConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.counter_offset","text":"counter_offset: Optional[int] Offset of the counter in the Data[] array in bits. Required for E2E profiles 01 and 11, unused otherwise","title":"counter_offset"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.crc_offset","text":"crc_offset: Optional[int] Offset of the crc in the Data[] array in bits. Required for E2E profiles 01 and 11, unused otherwise","title":"crc_offset"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.data_id_mode","text":"data_id_mode: Optional[DataIdMode] The data ID mode to use; required for E2E profiles 01 and 11, unused otherwise","title":"data_id_mode"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.data_id_nibble_offset","text":"data_id_nibble_offset: Optional[int] Offset of the data ID in the Data[] array in bits. Required for E2E profiles 01 and 11 when data_id_mode is Lower12Bit , unused otherwise","title":"data_id_nibble_offset"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.max_delta_counter","text":"max_delta_counter: int Maximum jump in the counter value between two consecutive messages","title":"max_delta_counter"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.max_error_state_init","text":"max_error_state_init: int The maximum allowed number of consecutive failed counter checks in the init state","title":"max_error_state_init"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.max_error_state_invalid","text":"max_error_state_invalid: int The maximum allowed number of consecutive failed counter checks in the invalid state","title":"max_error_state_invalid"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.max_error_state_valid","text":"max_error_state_valid: int The maximum allowed number of consecutive failed counter checks in the valid state","title":"max_error_state_valid"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.max_no_new_or_repeated_data","text":"max_no_new_or_repeated_data: int The maximum allowed number of consecutive failed counter checks","title":"max_no_new_or_repeated_data"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.min_ok_state_init","text":"min_ok_state_init: int The minimum allowed number of consecutive successful counter checks in the init state","title":"min_ok_state_init"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.min_ok_state_invalid","text":"min_ok_state_invalid: int The minimum allowed number of consecutive successful counter checks in the invalid state","title":"min_ok_state_invalid"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.min_ok_state_valid","text":"min_ok_state_valid: int The minimum allowed number of consecutive successful counter checks in the valid state","title":"min_ok_state_valid"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.offset","text":"offset: int The offset in bits from the start of the buffer where the E2E data should be placed If E2E is used after COM, the offset should be 0; if E2E is used after SOMEIP, the offset should be 64","title":"offset"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.profile","text":"profile: E2EProfile E2E profile to use","title":"profile"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.profile_behavior","text":"profile_behavior: Optional[E2EProfileBehavior] Behavior of the check functionality","title":"profile_behavior"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.sync_counter_init","text":"sync_counter_init: Optional[int] Number of successful checks required for validating the consistency of the counter","title":"sync_counter_init"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.transform_in_place","text":"transform_in_place: bool Should the E2E transformation take place in the existing buffer or in a separate buffer?","title":"transform_in_place"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.window_size","text":"window_size: int window size: Size of the monitoring window for the E2E state machine. This can be directly set up to AUTOSAR 4.4.0 ( AUTOSAR_00047 ). For newer files this only provides the default if window_size_init , window_size_invalid and window_size_valid are not set","title":"window_size"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.window_size_init","text":"window_size_init: Optional[int] window size in the init state - only valid in AUTOSAR 4.5.0 ( AUTOSAR_00048 ) and newer. if it is not set, this will default to window_size","title":"window_size_init"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.window_size_invalid","text":"window_size_invalid: Optional[int] window size in the invalid state - only valid in AUTOSAR 4.5.0 ( AUTOSAR_00048 ) and newer. if it is not set, this will default to window_size","title":"window_size_invalid"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.window_size_valid","text":"window_size_valid: Optional[int] window size in the valid state - only valid in AUTOSAR 4.5.0 ( AUTOSAR_00048 ) and newer. if it is not set, this will default to window_size","title":"window_size_valid"},{"location":"communication_api/#autosar_data.abstraction.communication.E2ETransformationTechnologyConfig.zero_header_length","text":"zero_header_length: bool When E2E is used in a transformer chain after COM, the header length must be zero. In this configuration you are expected to provide space for the E2E data inside the signal group layout, and zero_header_length should be set to true. If zero_header_length is set to false, the appropriate header length for the chosen E2E profile will be used (e.g. 24 bits for PROFILE_05 )","title":"zero_header_length"},{"location":"communication_api/#autosar_data.abstraction.communication.EndToEndTransformationISignalProps","text":"EndToEndTransformationISignalProps(element: Element) Properties for the End to End transformation of an ISignal(Group)","title":"EndToEndTransformationISignalProps"},{"location":"communication_api/#autosar_data.abstraction.communication.EndToEndTransformationISignalProps.data_ids","text":"data_ids: List[int] get or set the data IDs that are used for the E2E transformation","title":"data_ids"},{"location":"communication_api/#autosar_data.abstraction.communication.EndToEndTransformationISignalProps.data_length","text":"data_length: Optional[int] get or set the length of payload and E2E header in bits","title":"data_length"},{"location":"communication_api/#autosar_data.abstraction.communication.EndToEndTransformationISignalProps.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.EndToEndTransformationISignalProps.max_data_length","text":"max_data_length: Optional[int] get or set the maximum data length","title":"max_data_length"},{"location":"communication_api/#autosar_data.abstraction.communication.EndToEndTransformationISignalProps.min_data_length","text":"min_data_length: Optional[int] get or set the minimum data length","title":"min_data_length"},{"location":"communication_api/#autosar_data.abstraction.communication.EndToEndTransformationISignalProps.source_id","text":"source_id: Optional[int] get or set the source ID","title":"source_id"},{"location":"communication_api/#autosar_data.abstraction.communication.EndToEndTransformationISignalProps.transformer","text":"transformer: Optional[TransformationTechnology] get or set the transformer reference of the E2E transformation properties","title":"transformer"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCluster","text":"EthernetCluster(element: Element) An EthernetCluster contains all configuration items associated with an ethernet network. The cluster connects multiple ECUs.","title":"EthernetCluster"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCluster.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCluster.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCluster.system","text":"system: Optional[System] get the System that this EthernetCluster is part of","title":"system"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCluster.create_physical_channel","text":"create_physical_channel( channel_name: str, /, *, vlan_info: Optional[EthernetVlanInfo] = None, ) -> EthernetPhysicalChannel Create a new physical channel for the cluster The supplied VLAN info must be unique - there cannot be two VLANs with the same vlan identifier. One channel may be created without VLAN information; it carries untagged traffic.","title":"create_physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCluster.physical_channels","text":"physical_channels() -> Iterator[EthernetPhysicalChannel] returns an iterator over all [ EthernetPhysicalChannel ]s in the cluster","title":"physical_channels"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCommunicationConnector","text":"EthernetCommunicationConnector(element: Element) A connector between an [ EthernetCommunicationController ] in an ECU and an [ EthernetPhysicalChannel ]","title":"EthernetCommunicationConnector"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCommunicationConnector.controller","text":"controller: EthernetCommunicationController Get the controller of the CommunicationConnector","title":"controller"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCommunicationConnector.ecu_instance","text":"ecu_instance: EcuInstance Get the EcuInstance that contains this CommunicationConnector","title":"ecu_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCommunicationConnector.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCommunicationConnector.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCommunicationController","text":"EthernetCommunicationController(element: Element) An EcuInstance needs an EthernetCommunicationController in order to connect to an ethernet cluster.","title":"EthernetCommunicationController"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCommunicationController.ecu_instance","text":"ecu_instance: EcuInstance Get the EcuInstance that contains this EthernetCommunicationController","title":"ecu_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCommunicationController.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCommunicationController.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCommunicationController.connect_physical_channel","text":"connect_physical_channel( connection_name: str, eth_channel: EthernetPhysicalChannel, ) -> EthernetCommunicationConnector Connect this [ EthernetCommunicationController ] inside an [ EcuInstance ] to an [ EthernetPhysicalChannel ] in the [ crate::System ] Creates an EthernetCommunicationConnector in the [ EcuInstance ] that contains this [ EthernetCommunicationController ]. This function establishes the relationships [ EthernetPhysicalChannel ] -> EthernetCommunicationConnector EthernetCommunicationConnector -> [ EthernetCommunicationController ]","title":"connect_physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetCommunicationController.connected_channels","text":"connected_channels() -> Iterator[EthernetPhysicalChannel] return an iterator over the [ EthernetPhysicalChannel ]s connected to this controller","title":"connected_channels"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel","text":"EthernetPhysicalChannel(element: Element) The EthernetPhysicalChannel represents a VLAN or untagged traffic","title":"EthernetPhysicalChannel"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.cluster","text":"cluster: EthernetCluster get the cluster containing this physical channel","title":"cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.configure_service_discovery_for_ecu","text":"configure_service_discovery_for_ecu( ecu: EcuInstance, unicast_socket: SocketAddress, unicast_rx_pdu: GeneralPurposePdu, unicast_tx_pdu: GeneralPurposePdu, common_config: CommonServiceDiscoveryConfig, ) -> None configure SOME/IP service discovery (SD) for an ECU connected to this channel SD is used to broadcast service offers on the network and subscribe to services offered by other ECUs. This function configures the ECU to use the SOME/IP SD protocol. SD uses either socket connection bundles or static socket connections to communicate. ecu is the ECU that should be configured for SD. unicast_socket is the socket address used for unicast rx/tx communication by the ECU. unicast_rx_pdu and unicast_tx_pdu are the GeneralPurposePdus used for the unicast communication. common_config contains common configuration settings that can be used for all SD ECUs. - multicast_rx_socket is the socket address used for multicast communication by all SD ECUs. - remote_socket is a socket whose IP is set to ANY with UDP port 0, acting as the remote address in the SD communication. - name_prefix is an optional prefix for the names of the created elements. - prefer_static_socket_connections is a flag that determines if SocketConnectionBundles should be used instead of StaticSocketConnections . This is only relevant if the type can't be detected automatically. - ipdu_identifier_set is contains the IPduIdentifiers that are used in StaticSocketConnections . Note: Usually SomeIP SD is expected to use port 30490, but this is not mandatory. The port number is set in the sockets, and must be the same for all SD sockets.","title":"configure_service_discovery_for_ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.create_network_endpoint","text":"create_network_endpoint( name: str, address: NetworkEndpointAddress, /, *, ecu: Optional[EcuInstance] = None, ) -> NetworkEndpoint create a network endpoint - IPv4 or IPv6 address - for this channel In older versions of the Autosar standard, up to version 4.4.0, the NetworkEndpoint could be linked to an Ecu. The parameter ecu specifies the target. The link is obsoleted in newer versions, and will only be created if the file version allows it.","title":"create_network_endpoint"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.create_socket_address","text":"create_socket_address( name: str, network_endpoint: NetworkEndpoint, tp_config: TpConfig, sa_type: SocketAddressType, ) -> SocketAddress create a socket address in the ethernet channel It contains the settings of the TCP/UDP port and links to a [ NetworkEndpoint ] which contains the IP address. The socket address can either be a unicast adress which is associated with a single ECU, or a multicast address","title":"create_socket_address"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.create_socket_connection_bundle","text":"create_socket_connection_bundle( name: str, server_port: SocketAddress ) -> SocketConnectionBundle create a socket connection bundle The SocketConnectionBundle is the \"old\" way to establish a connection between two sockets. It is deprecated in newer versions of the Autosar standard, but remains available for compatibility.","title":"create_socket_connection_bundle"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.create_static_socket_connection_pair","text":"create_static_socket_connection_pair( name: str, port_1: SocketAddress, port_2: SocketAddress, /, *, tcp_connect_timeout: Optional[float] = None, ) -> Tuple[StaticSocketConnection, StaticSocketConnection] create a pair of static socket connections Static socket connections are usually created as a pair, one on each socket involved on the connection. This helper function creates both at once. To create a single connection, use [ SocketAddress::create_static_socket_connection ]. If the connection is a TCP connection, the first port connects to the second port, and the second port listens for incoming connection. The ordering of port_1 and port_2 has no impact on the direction of the transported PDUs. This is defined in the PduTriggering . StaticSocketConnection s are the \"new\" way to establish a connection between two sockets. It was introduced in Autosar 4.5.0 ( AUTOSAR_00048 ) and is the recommended way to create connections. SocketConnectionBundles (old) and StaticSocketConnections (new) may never be used in the same file.","title":"create_static_socket_connection_pair"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.has_socket_connections","text":"has_socket_connections() -> bool check if the channel contains any SocketConnectionBundles (old) or SocketConnections (very old)","title":"has_socket_connections"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.network_endpoints","text":"network_endpoints() -> Iterator[NetworkEndpoint] create an iterator over all [ NetworkEndpoint ]s in this channel","title":"network_endpoints"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.pdu_triggerings","text":"pdu_triggerings() -> Iterator[PduTriggering] iterate over all PDU triggerings of this physical channel","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.set_vlan_info","text":"set_vlan_info( vlan_info: Optional[EthernetVlanInfo], ) -> None get or set the VLAN information of the channel. In an EthernetCluster, each physical channel must have unique VLAN settings; only one channel can omit VLAN information - it carries untagged traffic. Setting duplicate VLAN information will result in an error.","title":"set_vlan_info"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.signal_triggerings","text":"signal_triggerings() -> Iterator[ISignalTriggering] iterate over all signal triggerings of this physical channel","title":"signal_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.socket_addresses","text":"socket_addresses() -> Iterator[SocketAddress] create an iterator over all [ SocketAddress ]es in this channel","title":"socket_addresses"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.socket_connection_bundles","text":"socket_connection_bundles() -> Iterator[ SocketConnectionBundle ] iterate over all socket connection bundles in this channel The SocketConnectionBundle is the \"old\" way to establish a connection between two sockets. It is deprecated in newer versions of the Autosar standard, but remains available for compatibility.","title":"socket_connection_bundles"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetPhysicalChannel.vlan_info","text":"vlan_info() -> Optional[EthernetVlanInfo] get or set the VLAN information of the channel. In an EthernetCluster, each physical channel must have unique VLAN settings; only one channel can omit VLAN information - it carries untagged traffic. Setting duplicate VLAN information will result in an error.","title":"vlan_info"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetVlanInfo","text":"EthernetVlanInfo(*, vlan_name: str, vlan_id: int) Provides information about the VLAN of an [ EthernetPhysicalChannel ]","title":"EthernetVlanInfo"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetVlanInfo.vlan_id","text":"vlan_id: int","title":"vlan_id"},{"location":"communication_api/#autosar_data.abstraction.communication.EthernetVlanInfo.vlan_name","text":"vlan_name: str","title":"vlan_name"},{"location":"communication_api/#autosar_data.abstraction.communication.EventControlledTiming","text":"EventControlledTiming( number_of_repetitions: int, /, *, repetition_period: Optional[float] = None, ) Event controlled timing parameters for an IPDU","title":"EventControlledTiming"},{"location":"communication_api/#autosar_data.abstraction.communication.EventControlledTiming.number_of_repetitions","text":"number_of_repetitions: int The PDU will be sent (number of repetitions + 1) times. If number of repetitions is 0, then the PDU is sent exactly once.","title":"number_of_repetitions"},{"location":"communication_api/#autosar_data.abstraction.communication.EventControlledTiming.repetition_period","text":"repetition_period: Optional[float] time in seconds between two transmissions of the PDU","title":"repetition_period"},{"location":"communication_api/#autosar_data.abstraction.communication.EventGroupControlType","text":"control types used in routing groups for SOME/IP events","title":"EventGroupControlType"},{"location":"communication_api/#autosar_data.abstraction.communication.EventGroupControlType.ActivationAndTriggerUnicast","text":"ActivationAndTriggerUnicast: EventGroupControlType","title":"ActivationAndTriggerUnicast"},{"location":"communication_api/#autosar_data.abstraction.communication.EventGroupControlType.ActivationMulticast","text":"ActivationMulticast: EventGroupControlType","title":"ActivationMulticast"},{"location":"communication_api/#autosar_data.abstraction.communication.EventGroupControlType.ActivationUnicast","text":"ActivationUnicast: EventGroupControlType","title":"ActivationUnicast"},{"location":"communication_api/#autosar_data.abstraction.communication.EventGroupControlType.TriggerUnicast","text":"TriggerUnicast: EventGroupControlType","title":"TriggerUnicast"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandler","text":"EventHandler(element: Element) An EventHandler describes the handling of a single event in a ProvidedServiceInstance","title":"EventHandler"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandler.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandler.event_group_identifier","text":"event_group_identifier: Optional[int] get or set the event group identifier of this EventHandler","title":"event_group_identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandler.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandler.sd_server_event_group_timing_config","text":"sd_server_event_group_timing_config: Optional[ SomeipSdServerEventGroupTimingConfig ] get or set the SD server event group timing configuration for this EventHandler","title":"sd_server_event_group_timing_config"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandler.create_pdu_activation_routing_group","text":"create_pdu_activation_routing_group( name: str, event_group_control_type: EventGroupControlType, ) -> PduActivationRoutingGroup create a new PduActivationRoutingGroup in this EventHandler","title":"create_pdu_activation_routing_group"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandler.pdu_activation_routing_groups","text":"pdu_activation_routing_groups() -> Iterator[ PduActivationRoutingGroup ] get the PduActivationRoutingGroup s in this EventHandler","title":"pdu_activation_routing_groups"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandlerV1","text":"EventHandlerV1(element: Element) An EventHandlerV1 is a SD event handler that is used to receive events from other ECUs. This is the old V1 version of the service definition.","title":"EventHandlerV1"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandlerV1.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandlerV1.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandlerV1.add_consumed_event_group","text":"add_consumed_event_group( consumed_event_group: ConsumedEventGroupV1, ) -> None add a reference to a ConsumedEventGroupV1 to this EventHandlerV1","title":"add_consumed_event_group"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandlerV1.add_routing_group","text":"add_routing_group(routing_group: SoAdRoutingGroup) -> None add a reference to a SoAdRoutingGroup to this EventHandler","title":"add_routing_group"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandlerV1.consumed_event_groups","text":"consumed_event_groups() -> Iterator[ConsumedEventGroupV1] get the consumed event groups referenced by this EventHandler","title":"consumed_event_groups"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandlerV1.routing_groups","text":"routing_groups() -> Iterator[SoAdRoutingGroup] get the routing groups referenced by this EventHandler","title":"routing_groups"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandlerV1.sd_server_config","text":"sd_server_config() -> Optional[SdEventConfig] get the SD server event configuration for this EventHandlerV1","title":"sd_server_config"},{"location":"communication_api/#autosar_data.abstraction.communication.EventHandlerV1.set_sd_server_config","text":"set_sd_server_config( sd_event_config: SdEventConfig, ) -> None set the SD server event configuration for this EventHandlerV1","title":"set_sd_server_config"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpChannel","text":"FlexrayArTpChannel(element: Element) The FlexrayArTpChannel represents a channel in the Flexray Autosar Transport Protocol","title":"FlexrayArTpChannel"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpChannel.ack_type","text":"ack_type: Optional[FrArTpAckType] get or set the ack type of the channel","title":"ack_type"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpChannel.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpChannel.extended_addressing","text":"extended_addressing: Optional[bool] get or set the extended addressing attribute","title":"extended_addressing"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpChannel.maximum_message_length","text":"maximum_message_length: Optional[MaximumMessageLengthType] get or set the maximum message length type","title":"maximum_message_length"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpChannel.minimum_separation_time","text":"minimum_separation_time: Optional[float] get or set the minimum separation time","title":"minimum_separation_time"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpChannel.multicast_segmentation","text":"multicast_segmentation: Optional[bool] get or set the multicast segmentation","title":"multicast_segmentation"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpChannel.add_n_pdu","text":"add_n_pdu(n_pdu: NPdu) -> None add an N-PDU to the channel The NPdus are logically assembled into a pool of Rx NPdus and another pool of Tx NPdus . This function is supported on autosar 4.1 and later, while Autosar 4.0 uses a different approach.","title":"add_n_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpChannel.create_flexray_ar_tp_connection","text":"create_flexray_ar_tp_connection( name: Optional[str], direct_tp_sdu: IPdu, source: FlexrayArTpNode, target: FlexrayArTpNode, ) -> FlexrayArTpConnection create a new FlexrayArTpConnection for this channel","title":"create_flexray_ar_tp_connection"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpChannel.flexray_ar_tp_connections","text":"flexray_ar_tp_connections() -> Iterator[ FlexrayArTpConnection ] get an iterator over the connections in the channel","title":"flexray_ar_tp_connections"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpChannel.n_pdus","text":"n_pdus() -> Iterator[NPdu] iterate over the NPdus of the channel","title":"n_pdus"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConfig","text":"FlexrayArTpConfig(element: Element) The FlexrayArTpConfig represents the configuration of the Flexray Autosar Transport Protocol","title":"FlexrayArTpConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConfig.cluster","text":"cluster: Optional[FlexrayCluster] get or set the Flexray cluster for the configuration","title":"cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConfig.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConfig.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConfig.create_flexray_ar_tp_channel","text":"create_flexray_ar_tp_channel( ack_type: FrArTpAckType, extended_addressing: bool, maximum_message_length: MaximumMessageLengthType, minimum_separation_time: float, multicast_segmentation: bool, ) -> FlexrayArTpChannel create a new FlexrayArTpChannel","title":"create_flexray_ar_tp_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConfig.create_flexray_ar_tp_node","text":"create_flexray_ar_tp_node(name: str) -> FlexrayArTpNode create a new FlexrayArTpNode","title":"create_flexray_ar_tp_node"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConfig.create_tp_address","text":"create_tp_address(name: str, address: int) -> TpAddress create a new TpAddress","title":"create_tp_address"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConfig.flexray_ar_tp_channels","text":"flexray_ar_tp_channels() -> Iterator[FlexrayArTpChannel] get an iterator over the channels in the configuration","title":"flexray_ar_tp_channels"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConfig.flexray_ar_tp_nodes","text":"flexray_ar_tp_nodes() -> Iterator[FlexrayArTpNode] get an iterator over the nodes","title":"flexray_ar_tp_nodes"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConfig.tp_addresses","text":"tp_addresses() -> Iterator[TpAddress] iterate over all TpAddresses","title":"tp_addresses"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConnection","text":"FlexrayArTpConnection(element: Element) FlexrayArTpConnection represents a connection within a FlexrayArTpChannel The connection identifies the sender and the receiver of this particular communication. The Flexray Autosar Tp module routes a Pdu through this connection.","title":"FlexrayArTpConnection"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConnection.direct_tp_sdu","text":"direct_tp_sdu: Optional[IPdu] get or set the direct TP SDU","title":"direct_tp_sdu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConnection.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConnection.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConnection.reversed_tp_sdu","text":"reversed_tp_sdu: Optional[IPdu] get or set or remove the reversed TP SDU If the connection supports both directions, then the reversed TP SDU is required. if Some(value) is passed, the reversed TP SDU is set to the given value, otherwise it is removed.","title":"reversed_tp_sdu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConnection.source","text":"source: Optional[FlexrayArTpNode] get or set the source of the connection","title":"source"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConnection.add_target","text":"add_target(target: FlexrayArTpNode) -> None add a target to the connection The connection can have multiple targets, but at least one target is required.","title":"add_target"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpConnection.targets","text":"targets() -> Iterator[FlexrayArTpNode] get the targets","title":"targets"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpNode","text":"FlexrayArTpNode(element: Element) FlexrayArTpNode represents a node in the Flexray Autosar Transport Protocol A TP node (sender or receiver) provides the TP address and the connection to the topology description","title":"FlexrayArTpNode"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpNode.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpNode.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpNode.tp_address","text":"tp_address: Optional[TpAddress] set or remove the TP address if Some(value) is passed, the TP address is set to the given value, otherwise it is removed.","title":"tp_address"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpNode.add_communication_connector","text":"add_communication_connector( connector: FlexrayCommunicationConnector, ) -> None add a reference to a FlexrayCommunicationConnector The connectors define the association with a PhysicalChannel and an ECU. In a SystemDescription , this reference is mandatory, but in an ECUExtract it is optional. Up to 2 connectors can be added to a node.","title":"add_communication_connector"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayArTpNode.communication_connectors","text":"communication_connectors() -> Iterator[ FlexrayCommunicationConnector ] get the connectors","title":"communication_connectors"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayChannelName","text":"A flexray cluster may contain the channels A and/or B. This enum is an abstraction over the element.","title":"FlexrayChannelName"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayChannelName.A","text":"A: FlexrayChannelName","title":"A"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayChannelName.B","text":"B: FlexrayChannelName","title":"B"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCluster","text":"FlexrayCluster(element: Element) A FlexrayCluster contains all configuration items associated with a Flexray network. The cluster connects multiple ECUs.","title":"FlexrayCluster"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCluster.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCluster.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCluster.physical_channels","text":"physical_channels: FlexrayPhysicalChannelsInfo get the physical channels of this cluster","title":"physical_channels"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCluster.system","text":"system: Optional[System] get the system that contains this cluster","title":"system"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCluster.create_physical_channel","text":"create_physical_channel( name: str, channel_name: FlexrayChannelName ) -> FlexrayPhysicalChannel Create a new physical channel for the cluster A cluster may contain channel A, channel B, or both A and B.","title":"create_physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCluster.set_settings","text":"set_settings(settings: FlexrayClusterSettings) -> None set the current flexray cluster settings","title":"set_settings"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCluster.settings","text":"settings() -> Optional[FlexrayClusterSettings] get the current flexray cluster settings","title":"settings"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings","text":"","title":"FlexrayClusterSettings"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.action_point_offset","text":"action_point_offset: float get or set the action point offset of the cluster","title":"action_point_offset"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.baudrate","text":"baudrate: int get or set the baudrate of the cluster","title":"baudrate"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.bit","text":"bit: float get or set the bit time of the cluster","title":"bit"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.cas_rx_low_max","text":"cas_rx_low_max: int get or set the cas rx low max of the cluster","title":"cas_rx_low_max"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.cold_start_attempts","text":"cold_start_attempts: int get or set the cold start attempts of the cluster","title":"cold_start_attempts"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.cycle","text":"cycle: float get or set the cycle time of the cluster (in seconds)","title":"cycle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.cycle_count_max","text":"cycle_count_max: int get or set the cycle count max of the cluster","title":"cycle_count_max"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.detect_nit_error","text":"detect_nit_error: bool get or set the detect nit error status of the cluster","title":"detect_nit_error"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.dynamic_slot_idle_phase","text":"dynamic_slot_idle_phase: int get or set the dynamic slot idle phase of the cluster","title":"dynamic_slot_idle_phase"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.ignore_after_tx","text":"ignore_after_tx: int get or set the ignore after tx duration of the cluster","title":"ignore_after_tx"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.listen_noise","text":"listen_noise: int get or set the listen noise of the cluster","title":"listen_noise"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.macro_per_cycle","text":"macro_per_cycle: int get or set the macro per cycle of the cluster","title":"macro_per_cycle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.macrotick_duration","text":"macrotick_duration: float get or set the macrotick duration of the cluster","title":"macrotick_duration"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.max_without_clock_correction_fatal","text":"max_without_clock_correction_fatal: int get or set the max without clock correction fatal of the cluster","title":"max_without_clock_correction_fatal"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.max_without_clock_correction_passive","text":"max_without_clock_correction_passive: int get or set the max without clock correction passive of the cluster","title":"max_without_clock_correction_passive"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.minislot_action_point_offset","text":"minislot_action_point_offset: int get or set the minislot action point offset of the cluster","title":"minislot_action_point_offset"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.minislot_duration","text":"minislot_duration: int get or set the minislot duration of the cluster","title":"minislot_duration"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.network_idle_time","text":"network_idle_time: int get or set the network idle time of the cluster","title":"network_idle_time"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.network_management_vector_length","text":"network_management_vector_length: int get or set the network management vector length of the cluster","title":"network_management_vector_length"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.number_of_minislots","text":"number_of_minislots: int get or set the number of minislots of the cluster","title":"number_of_minislots"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.number_of_static_slots","text":"number_of_static_slots: int get or set the number of static slots of the cluster","title":"number_of_static_slots"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.offset_correction_start","text":"offset_correction_start: int get or set the offset correction start of the cluster","title":"offset_correction_start"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.payload_length_static","text":"payload_length_static: int get or set the payload length static of the cluster","title":"payload_length_static"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.safety_margin","text":"safety_margin: int get or set the safety margin of the cluster","title":"safety_margin"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.sample_clock_period","text":"sample_clock_period: Optional[float] get or set the sample clock period of the cluster","title":"sample_clock_period"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.static_slot_duration","text":"static_slot_duration: int get or set the static slot duration of the cluster","title":"static_slot_duration"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.symbol_window","text":"symbol_window: int get or set the symbol window of the cluster","title":"symbol_window"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.symbol_window_action_point_offset","text":"symbol_window_action_point_offset: int get or set the symbol window action point offset of the cluster","title":"symbol_window_action_point_offset"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.sync_frame_id_count_max","text":"sync_frame_id_count_max: int get or set the sync frame id count max of the cluster","title":"sync_frame_id_count_max"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.transceiver_standby_delay","text":"transceiver_standby_delay: Optional[float] get or set the transceiver standby delay of the cluster","title":"transceiver_standby_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.transmission_start_sequence_duration","text":"transmission_start_sequence_duration: int get or set the transmission start sequence duration of the cluster","title":"transmission_start_sequence_duration"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.wakeup_rx_idle","text":"wakeup_rx_idle: int get or set the wakeup rx idle of the cluster","title":"wakeup_rx_idle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.wakeup_rx_low","text":"wakeup_rx_low: int get or set the wakeup rx low of the cluster","title":"wakeup_rx_low"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.wakeup_rx_window","text":"wakeup_rx_window: int get or set the wakeup rx window of the cluster","title":"wakeup_rx_window"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.wakeup_tx_active","text":"wakeup_tx_active: int get or set the wakeup tx active of the cluster","title":"wakeup_tx_active"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.wakeup_tx_idle","text":"wakeup_tx_idle: int get or set the wakeup tx idle of the cluster","title":"wakeup_tx_idle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayClusterSettings.verify","text":"verify() -> bool verify the settings of a flexray cluster","title":"verify"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationConnector","text":"FlexrayCommunicationConnector(element: Element) A connector between a [ FlexrayCommunicationController ] in an ECU and a [ FlexrayPhysicalChannel ]","title":"FlexrayCommunicationConnector"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationConnector.controller","text":"controller: FlexrayCommunicationController Get or set the controller of the CommunicationConnector","title":"controller"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationConnector.ecu_instance","text":"ecu_instance: EcuInstance Get the EcuInstance that contains this CommunicationConnector","title":"ecu_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationConnector.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationConnector.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationController","text":"FlexrayCommunicationController(element: Element) An EcuInstance needs a FlexrayCommunicationController in order to connect to a Flexray cluster.","title":"FlexrayCommunicationController"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationController.ecu_instance","text":"ecu_instance: EcuInstance Get the EcuInstance that contains this FlexrayCommunicationController","title":"ecu_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationController.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationController.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationController.connect_physical_channel","text":"connect_physical_channel( connection_name: str, flx_channel: FlexrayPhysicalChannel, ) -> FlexrayCommunicationConnector Connect this [ FlexrayCommunicationController ] inside an [ EcuInstance ] to a [ FlexrayPhysicalChannel ] in the [ crate::System ] Creates a FlexrayCommunicationConnector in the [ EcuInstance ] that contains this [ FlexrayCommunicationController ]. This function establishes the relationships [ FlexrayPhysicalChannel ] -> FlexrayCommunicationConnector FlexrayCommunicationConnector -> [ FlexrayCommunicationController ]","title":"connect_physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationController.connected_channels","text":"connected_channels() -> Iterator[FlexrayPhysicalChannel] return an iterator over the [ FlexrayPhysicalChannel ]s connected to this controller","title":"connected_channels"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationCycle","text":"The timing settings of a Flexray frame","title":"FlexrayCommunicationCycle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationCycle.Counter","text":"Counter: Type[FlexrayCommunicationCycle_Counter]","title":"Counter"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationCycle.Repetition","text":"Repetition: Type[FlexrayCommunicationCycle_Repetition]","title":"Repetition"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationCycle_Counter","text":"FlexrayCommunicationCycle_Counter(cycle_counter: int) Bases: FlexrayCommunicationCycle","title":"FlexrayCommunicationCycle_Counter"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationCycle_Counter.cycle_counter","text":"cycle_counter: int","title":"cycle_counter"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationCycle_Repetition","text":"FlexrayCommunicationCycle_Repetition( base_cycle: int, cycle_repetition: CycleRepetition ) Bases: FlexrayCommunicationCycle","title":"FlexrayCommunicationCycle_Repetition"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationCycle_Repetition.base_cycle","text":"base_cycle: int","title":"base_cycle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayCommunicationCycle_Repetition.cycle_repetition","text":"cycle_repetition: CycleRepetition","title":"cycle_repetition"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrame","text":"FlexrayFrame(element: Element) a Flexray frame","title":"FlexrayFrame"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrame.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrame.length","text":"length: Optional[int] get or set the length of the frame","title":"length"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrame.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrame.frame_triggerings","text":"frame_triggerings() -> List[FlexrayFrameTriggering] List all FlexrayFrameTriggering s using this frame","title":"frame_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrame.map_pdu","text":"map_pdu( pdu: Pdu, start_position: int, byte_order: ByteOrder, /, *, update_bit: Optional[int] = None, ) -> FlexrayFrameTriggering map a PDU to the frame","title":"map_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrame.mapped_pdus","text":"mapped_pdus() -> Iterator[Pdu] returns an iterator over all PDUs in the frame","title":"mapped_pdus"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrameTriggering","text":"FlexrayFrameTriggering(element: Element) Iterator over all [ FlexrayFrameTriggering ]s using this frame map a PDU to the frame The frame triggering connects a frame to a physical channel","title":"FlexrayFrameTriggering"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrameTriggering.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrameTriggering.frame","text":"frame: Optional[FlexrayFrame] get the frame triggered by the frame triggering","title":"frame"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrameTriggering.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrameTriggering.physical_channel","text":"physical_channel: FlexrayPhysicalChannel get the physical channel that contains this frame triggering","title":"physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrameTriggering.slot","text":"slot: Optional[int] get or set the slot id for the flexray frame triggering","title":"slot"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrameTriggering.connect_to_ecu","text":"connect_to_ecu( ecu: EcuInstance, direction: CommunicationDirection ) -> FramePort connect this frame triggering to an ECU The frame triggering may be connected to any number of ECUs.","title":"connect_to_ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrameTriggering.frame_ports","text":"frame_ports() -> Iterator[FramePort] get the frame ports connected to this frame triggering","title":"frame_ports"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrameTriggering.pdu_triggerings","text":"pdu_triggerings() -> Iterator[PduTriggering] get the PDU triggerings referenced by this frame triggering","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrameTriggering.set_timing","text":"set_timing(timing: FlexrayCommunicationCycle) -> None set the timing of the flexray frame","title":"set_timing"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayFrameTriggering.timing","text":"timing() -> Optional[FlexrayCommunicationCycle] get the timing of the flexray frame In a well-formed file this should always return a value","title":"timing"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster","text":"FlexrayNmCluster(element: Element) Flexray specific NmCluster","title":"FlexrayNmCluster"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.channel_sleep_master","text":"channel_sleep_master: Optional[bool] get or set or remove the nmChannelSleepMaster flag","title":"channel_sleep_master"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.communication_cluster","text":"communication_cluster: Optional[FlexrayCluster] get or set the referenced FlexrayCluster","title":"communication_cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.nm_data_cycle","text":"nm_data_cycle: Optional[int] get or set the nmDataCycle Number of Flexray Communication Cycles needed to transmit the Nm Data PDUs of all Flexray Nm Ecus of this FlexrayNmCluster .","title":"nm_data_cycle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.nm_remote_sleep_indication_time","text":"nm_remote_sleep_indication_time: Optional[float] get or set the nmRemoteSleepIndicationTime Timeout for Remote Sleep Indication in seconds.","title":"nm_remote_sleep_indication_time"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.nm_repeat_message_time","text":"nm_repeat_message_time: Optional[float] get or set the nmRepeatMessageTime Timeout for Repeat Message State in seconds.","title":"nm_repeat_message_time"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.nm_repetition_cycle","text":"nm_repetition_cycle: Optional[int] get or set the nmRepetitionCycle Number of Flexray Communication Cycles used to repeat the transmission of the Nm vote Pdus of all Flexray NmEcus of this FlexrayNmCluster . This value shall be an integral multiple of nmVotingCycle.","title":"nm_repetition_cycle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.nm_voting_cycle","text":"nm_voting_cycle: Optional[int] get or set the nmVotingCycle The number of Flexray Communication Cycles used to transmit the Nm Vote PDUs of all Flexray Nm Ecus of this FlexrayNmCluster .","title":"nm_voting_cycle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.node_detection_enabled","text":"node_detection_enabled: Optional[bool] get or set the nmNodeDetectionEnabled flag","title":"node_detection_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.node_id_enabled","text":"node_id_enabled: Optional[bool] get or set the nmNodeIdEnabled flag","title":"node_id_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.pnc_cluster_vector_length","text":"pnc_cluster_vector_length: Optional[int] get or set the pncClusterVectorLength","title":"pnc_cluster_vector_length"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.pnc_participation","text":"pnc_participation: Optional[bool] get or set the nmPncParticipation flag","title":"pnc_participation"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.repeat_msg_ind_enabled","text":"repeat_msg_ind_enabled: Optional[bool] get or set the nmRepeatMsgIndEnabled flag","title":"repeat_msg_ind_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.synchronizing_network","text":"synchronizing_network: Optional[bool] get or set the nmSynchronizingNetwork flag","title":"synchronizing_network"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.create_flexray_nm_node","text":"create_flexray_nm_node( name: str, controller: FlexrayCommunicationController, nm_ecu: NmEcu, ) -> FlexrayNmNode add a FlexrayNmNode to the cluster","title":"create_flexray_nm_node"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmCluster.nm_nodes","text":"nm_nodes() -> Iterator[FlexrayNmNode] iterate over all NmNodes in this cluster","title":"nm_nodes"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmClusterCoupling","text":"FlexrayNmClusterCoupling(element: Element) A FlexrayNmClusterCoupling couples multiple FlexrayNmCluster`s.","title":"FlexrayNmClusterCoupling"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmClusterCoupling.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmClusterCoupling.nm_schedule_variant","text":"nm_schedule_variant: Optional[FlexrayNmScheduleVariant] get or set the nmScheduleVariant","title":"nm_schedule_variant"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmClusterCoupling.add_coupled_cluster","text":"add_coupled_cluster(cluster: FlexrayNmCluster) -> None add a reference to a coupled NmCluster","title":"add_coupled_cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmClusterCoupling.coupled_clusters","text":"coupled_clusters() -> Iterator[FlexrayNmCluster] iterate over all coupled NmClusters","title":"coupled_clusters"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmClusterSettings","text":"FlexrayNmClusterSettings( *, nm_data_cycle: int, nm_remote_sleep_indication_time: float, nm_repeat_message_time: float, nm_repetition_cycle: int, nm_voting_cycle: int, ) Mandatory settings for a FlexrayNmCluster These settings must be provided when creating a new FlexrayNmCluster . Additional optional settings can be set using FlexrayNmCluster methods.","title":"FlexrayNmClusterSettings"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmClusterSettings.nm_data_cycle","text":"nm_data_cycle: Optional[int] nmDataCycle: Number of Flexray Communication Cycles needed to transmit the Nm Data PDUs of all Flexray Nm Ecus of this FlexrayNmCluster .","title":"nm_data_cycle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmClusterSettings.nm_remote_sleep_indication_time","text":"nm_remote_sleep_indication_time: Optional[float] nmRemoteSleepIndicationTime: Timeout for Remote Sleep Indication in seconds.","title":"nm_remote_sleep_indication_time"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmClusterSettings.nm_repeat_message_time","text":"nm_repeat_message_time: Optional[float] nmRepeatMessageTime: Timeout for Repeat Message State in seconds.","title":"nm_repeat_message_time"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmClusterSettings.nm_repetition_cycle","text":"nm_repetition_cycle: Optional[int] nmRepetitionCycle: Number of Flexray Communication Cycles used to repeat the transmission of the Nm vote Pdus of all Flexray NmEcus of this FlexrayNmCluster . This value shall be an integral multiple of nmVotingCycle.","title":"nm_repetition_cycle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmClusterSettings.nm_voting_cycle","text":"nm_voting_cycle: Optional[int] nmVotingCycle: The number of Flexray Communication Cycles used to transmit the Nm Vote PDUs of all Flexray Nm Ecus of this FlexrayNmCluster .","title":"nm_voting_cycle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmNode","text":"FlexrayNmNode(element: Element) A FlexrayNmNode represents a Flexray specific NmNode . It connects a FlexrayCommunicationController with a NmEcu .","title":"FlexrayNmNode"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmNode.communication_controller","text":"communication_controller: Optional[ FlexrayCommunicationController ] get or set the referenced FlexrayCommunicationController","title":"communication_controller"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmNode.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmNode.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmNode.nm_ecu","text":"nm_ecu: Optional[NmEcu] get or set the referenced NmEcu","title":"nm_ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmNode.node_id","text":"node_id: Optional[int] get or set the nmNodeId This value is optional; if it is set to Some(x) the value is created, if it is set to None the value is removed.","title":"node_id"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmNode.passive_mode","text":"passive_mode: Optional[bool] get or set ot remove the nmPassiveModeEnabled flag This flag is optional; if it is set to Some(x) the value is created, if it is set to None the value is removed.","title":"passive_mode"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmNode.add_rx_nm_pdu","text":"add_rx_nm_pdu(nm_pdu: NmPdu) -> None add an Rx NmPdu Every NmNode must have at least one Rx NmPdu","title":"add_rx_nm_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmNode.add_tx_nm_pdu","text":"add_tx_nm_pdu(nm_pdu: NmPdu) -> None add a Tx NmPdu Active NmNodes must have at least one Tx NmPdu , while passive NmNodes may have none.","title":"add_tx_nm_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmNode.rx_nm_pdus","text":"rx_nm_pdus() -> Iterator[NmPdu] iterate over all RX NmPdus","title":"rx_nm_pdus"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmNode.tx_nm_pdus","text":"tx_nm_pdus() -> Iterator[NmPdu] iterate over all TX NmPdus","title":"tx_nm_pdus"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmScheduleVariant","text":"The FlexrayNmScheduleVariant defines the way the NM-Vote and NM-Data are transmitted within the Flexray network.","title":"FlexrayNmScheduleVariant"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmScheduleVariant.ScheduleVariant1","text":"ScheduleVariant1: FlexrayNmScheduleVariant","title":"ScheduleVariant1"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmScheduleVariant.ScheduleVariant2","text":"ScheduleVariant2: FlexrayNmScheduleVariant","title":"ScheduleVariant2"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmScheduleVariant.ScheduleVariant3","text":"ScheduleVariant3: FlexrayNmScheduleVariant","title":"ScheduleVariant3"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmScheduleVariant.ScheduleVariant4","text":"ScheduleVariant4: FlexrayNmScheduleVariant","title":"ScheduleVariant4"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmScheduleVariant.ScheduleVariant5","text":"ScheduleVariant5: FlexrayNmScheduleVariant","title":"ScheduleVariant5"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmScheduleVariant.ScheduleVariant6","text":"ScheduleVariant6: FlexrayNmScheduleVariant","title":"ScheduleVariant6"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayNmScheduleVariant.ScheduleVariant7","text":"ScheduleVariant7: FlexrayNmScheduleVariant","title":"ScheduleVariant7"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayPhysicalChannel","text":"FlexrayPhysicalChannel(element: Element) the FlexrayPhysicalChannel represents either channel A or B of Flexray cluster","title":"FlexrayPhysicalChannel"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayPhysicalChannel.channel_name","text":"channel_name: Optional[FlexrayChannelName] get the channel name of a FlexrayPhysicalChannel","title":"channel_name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayPhysicalChannel.cluster","text":"cluster: FlexrayCluster get the cluster containing this physical channel","title":"cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayPhysicalChannel.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayPhysicalChannel.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayPhysicalChannel.frame_triggerings","text":"frame_triggerings() -> Iterator[FlexrayFrameTriggering] iterate over all frame triggerings of this physical channel","title":"frame_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayPhysicalChannel.pdu_triggerings","text":"pdu_triggerings() -> Iterator[PduTriggering] iterate over all PDU triggerings of this physical channel","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayPhysicalChannel.signal_triggerings","text":"signal_triggerings() -> Iterator[ISignalTriggering] iterate over all signal triggerings of this physical channel","title":"signal_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayPhysicalChannel.trigger_frame","text":"trigger_frame( frame: FlexrayFrame, slot_id: int, timing: FlexrayCommunicationCycle, ) -> FlexrayFrameTriggering add a trigger for a flexray frame in this physical channel","title":"trigger_frame"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayPhysicalChannelsInfo","text":"Information about the flexray physical channels present inside a cluster","title":"FlexrayPhysicalChannelsInfo"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayPhysicalChannelsInfo.channel_a","text":"channel_a: Optional[FlexrayPhysicalChannel] get the channel A of the cluster","title":"channel_a"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayPhysicalChannelsInfo.channel_b","text":"channel_b: Optional[FlexrayPhysicalChannel] get the channel B of the cluster","title":"channel_b"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig","text":"FlexrayTpConfig(element: Element) FlexrayTpConfig defines exactly one Flexray ISO TP Configuration","title":"FlexrayTpConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.cluster","text":"cluster: Optional[FlexrayCluster] get or set the FlexrayCluster of the FlexrayTpConfig","title":"cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.create_flexray_tp_connection","text":"create_flexray_tp_connection( name: Optional[str], transmitter: FlexrayTpNode, direct_tp_sdu: IPdu, connection_control: FlexrayTpConnectionControl, ) -> FlexrayTpConnection create a new FlexrayTpConnection","title":"create_flexray_tp_connection"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.create_flexray_tp_connection_control","text":"create_flexray_tp_connection_control( name: str, ) -> FlexrayTpConnectionControl create a new FlexrayTpConnectionControl","title":"create_flexray_tp_connection_control"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.create_flexray_tp_ecu","text":"create_flexray_tp_ecu( ecu_instance: EcuInstance, full_duplex_enabled: bool ) -> FlexrayTpEcu add a FlexrayTpEcu to the FlexrayTpConfig","title":"create_flexray_tp_ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.create_flexray_tp_node","text":"create_flexray_tp_node(name: str) -> FlexrayTpNode create a new FlexrayTpNode","title":"create_flexray_tp_node"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.create_flexray_tp_pdu_pool","text":"create_flexray_tp_pdu_pool(name: str) -> FlexrayTpPduPool create a new FlexrayTpPduPool","title":"create_flexray_tp_pdu_pool"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.create_tp_address","text":"create_tp_address(name: str, address: int) -> TpAddress create a new TpAddress","title":"create_tp_address"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.flexray_tp_connection_controls","text":"flexray_tp_connection_controls() -> Iterator[ FlexrayTpConnectionControl ] iterate over all FlexrayTpConnectionControls","title":"flexray_tp_connection_controls"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.flexray_tp_connections","text":"flexray_tp_connections() -> Iterator[FlexrayTpConnection] iterate over all FlexrayTpConnections","title":"flexray_tp_connections"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.flexray_tp_ecus","text":"flexray_tp_ecus() -> Iterator[FlexrayTpEcu] iterate over all FlexrayTpEcus","title":"flexray_tp_ecus"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.flexray_tp_nodes","text":"flexray_tp_nodes() -> Iterator[FlexrayTpNode] iterate over all FlexrayTpNodes","title":"flexray_tp_nodes"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.flexray_tp_pdu_pools","text":"flexray_tp_pdu_pools() -> Iterator[FlexrayTpPduPool] iterate over all FlexrayTpPduPools","title":"flexray_tp_pdu_pools"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConfig.tp_addresses","text":"tp_addresses() -> Iterator[TpAddress] iterate over all TpAddresses","title":"tp_addresses"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnection","text":"FlexrayTpConnection(element: Element) A FlexrayTpConnection defines a connection between FlexrayTpNodes","title":"FlexrayTpConnection"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnection.connection_control","text":"connection_control: Optional[FlexrayTpConnectionControl] get or set the connection control of the connection","title":"connection_control"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnection.direct_tp_sdu","text":"direct_tp_sdu: Optional[IPdu] get or set the direct TP SDU of the connection","title":"direct_tp_sdu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnection.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnection.multicast_address","text":"multicast_address: Optional[TpAddress] get or set the multicast TpAddress of the connection","title":"multicast_address"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnection.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnection.reversed_tp_sdu","text":"reversed_tp_sdu: Optional[IPdu] get or set the reversed TP SDU of the connection This is used if the connection supports both sending and receiving","title":"reversed_tp_sdu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnection.rx_pdu_pool","text":"rx_pdu_pool: Optional[FlexrayTpPduPool] get or set the RX FlexrayTpPduPool of the connection","title":"rx_pdu_pool"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnection.transmitter","text":"transmitter: Optional[FlexrayTpNode] get or set the transmitter of the connection","title":"transmitter"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnection.tx_pdu_pool","text":"tx_pdu_pool: Optional[FlexrayTpPduPool] get or set the TX FlexrayTpPduPool of the connection","title":"tx_pdu_pool"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnection.add_receiver","text":"add_receiver(receiver: FlexrayTpNode) -> None add a receiver to the connection","title":"add_receiver"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnection.receivers","text":"receivers() -> Iterator[FlexrayTpNode] iterate over all receivers of the connection","title":"receivers"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnectionControl","text":"FlexrayTpConnectionControl(element: Element) A FlexrayTpConnectionControl defines the connection control parameters for a FlexrayTpConnection","title":"FlexrayTpConnectionControl"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnectionControl.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnectionControl.max_fc_wait","text":"max_fc_wait: Optional[int] get or set the maxFcWait value","title":"max_fc_wait"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnectionControl.max_number_of_npdu_per_cycle","text":"max_number_of_npdu_per_cycle: Optional[int] get or set the maxNumberOfNpduPerCycle value","title":"max_number_of_npdu_per_cycle"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnectionControl.max_retries","text":"max_retries: Optional[int] get or set the maxRetries value","title":"max_retries"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnectionControl.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpConnectionControl.separation_cycle_exponent","text":"separation_cycle_exponent: Optional[int] get or set the separationCycleExponent value","title":"separation_cycle_exponent"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpEcu","text":"FlexrayTpEcu(element: Element) A FlexrayTpEcu represents an ECU within the FlexrayTpConfig","title":"FlexrayTpEcu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpEcu.cancellation","text":"cancellation: Optional[bool] get or set the cancellation status of the FlexrayTpEcu","title":"cancellation"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpEcu.cycle_time_main_function","text":"cycle_time_main_function: Optional[float] get or set the cycle time of the TP main function in seconds","title":"cycle_time_main_function"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpEcu.ecu_instance","text":"ecu_instance: Optional[EcuInstance] get or set the ECU instance of the FlexrayTpEcu","title":"ecu_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpEcu.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpEcu.full_duplex_enabled","text":"full_duplex_enabled: Optional[bool] get or set the full duplex enabled flag of the FlexrayTpEcu","title":"full_duplex_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpNode","text":"FlexrayTpNode(element: Element) A FlexrayTpNode provides the TP address and the connection to the topology description in a FlexrayTpConfig","title":"FlexrayTpNode"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpNode.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpNode.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpNode.tp_address","text":"tp_address: Optional[TpAddress] set or remove FlexrayTpAddress of the node A TP address is mandatory for unicast nodes, but optional for multicast nodes Setting None will remove the element","title":"tp_address"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpNode.add_communication_connector","text":"add_communication_connector( connector: FlexrayCommunicationConnector, ) -> None add a FlexrayCommunicationConnector to the node The node can be associated with up to 2 connectors. In a system description this reference is mandatory.","title":"add_communication_connector"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpNode.communication_connectors","text":"communication_connectors() -> Iterator[ FlexrayCommunicationConnector ] iterate over all FlexrayCommunicationConnectors of the node","title":"communication_connectors"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpPduPool","text":"FlexrayTpPduPool(element: Element) A FlexrayTpPduPool contains a set of NPdus that can be used for sending and receiving","title":"FlexrayTpPduPool"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpPduPool.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpPduPool.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpPduPool.add_n_pdu","text":"add_n_pdu(n_pdu: NPdu) -> None add an NPdu to the PduPool","title":"add_n_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.FlexrayTpPduPool.n_pdus","text":"n_pdus() -> Iterator[NPdu] iterate over all referenced NPdus","title":"n_pdus"},{"location":"communication_api/#autosar_data.abstraction.communication.FrArTpAckType","text":"Types of Acknowledgement that can be used in an FlexrayArTpChannel","title":"FrArTpAckType"},{"location":"communication_api/#autosar_data.abstraction.communication.FrArTpAckType.AckWithRt","text":"AckWithRt: FrArTpAckType","title":"AckWithRt"},{"location":"communication_api/#autosar_data.abstraction.communication.FrArTpAckType.AckWithoutRt","text":"AckWithoutRt: FrArTpAckType","title":"AckWithoutRt"},{"location":"communication_api/#autosar_data.abstraction.communication.FrArTpAckType.NoAck","text":"NoAck: FrArTpAckType","title":"NoAck"},{"location":"communication_api/#autosar_data.abstraction.communication.FramePort","text":"FramePort(element: Element) The FramePort allows an ECU to send or receive a frame","title":"FramePort"},{"location":"communication_api/#autosar_data.abstraction.communication.FramePort.communication_direction","text":"communication_direction: Optional[CommunicationDirection] get or set the communication direction of the frame port","title":"communication_direction"},{"location":"communication_api/#autosar_data.abstraction.communication.FramePort.ecu","text":"ecu: EcuInstance get the ECU instance that contains this frame port","title":"ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.FramePort.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.FramePort.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposeIPdu","text":"GeneralPurposeIPdu(element: Element) This element is used for AUTOSAR Pdus without attributes that are routed by the PduR","title":"GeneralPurposeIPdu"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposeIPdu.category","text":"category: Optional[GeneralPurposeIPduCategory] get the category of this PDU","title":"category"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposeIPdu.contained_ipdu_props","text":"contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu","title":"contained_ipdu_props"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposeIPdu.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposeIPdu.length","text":"length: Optional[int] get or set the length of this PDU","title":"length"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposeIPdu.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposeIPdu.pdu_triggerings","text":"pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposeIPduCategory","text":"The category of a GeneralPurposeIPdu The Autosar standard defines the following categories: - XCP - SOMEIP_SEGMENTED_IPDU - DLT","title":"GeneralPurposeIPduCategory"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposeIPduCategory.Dlt","text":"Dlt: GeneralPurposeIPduCategory","title":"Dlt"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposeIPduCategory.SomeipSegmentedIpdu","text":"SomeipSegmentedIpdu: GeneralPurposeIPduCategory","title":"SomeipSegmentedIpdu"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposeIPduCategory.Xcp","text":"Xcp: GeneralPurposeIPduCategory","title":"Xcp"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposePdu","text":"GeneralPurposePdu(element: Element) This element is used for AUTOSAR Pdus without additional attributes that are routed by a bus interface","title":"GeneralPurposePdu"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposePdu.category","text":"category: Optional[GeneralPurposePduCategory] get or set the category of this PDU","title":"category"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposePdu.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposePdu.length","text":"length: Optional[int] get or set the length of this PDU","title":"length"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposePdu.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposePdu.pdu_triggerings","text":"pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposePduCategory","text":"The category of a GeneralPurposePdu The Autosar standard defines the following categories: - SD - GLOBAL_TIME - DOIP","title":"GeneralPurposePduCategory"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposePduCategory.DoIp","text":"DoIp: GeneralPurposePduCategory","title":"DoIp"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposePduCategory.GlobalTime","text":"GlobalTime: GeneralPurposePduCategory","title":"GlobalTime"},{"location":"communication_api/#autosar_data.abstraction.communication.GeneralPurposePduCategory.Sd","text":"Sd: GeneralPurposePduCategory","title":"Sd"},{"location":"communication_api/#autosar_data.abstraction.communication.GenericTransformationTechnologyConfig","text":"GenericTransformationTechnologyConfig( *, protocol_name: str, protocol_version: str, header_length: int, in_place: bool, ) Configuration for a generic transformation technology For a generic trasformation, the mandatory values must be chosen by the user","title":"GenericTransformationTechnologyConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.GenericTransformationTechnologyConfig.header_length","text":"header_length: int The length of the header in bits","title":"header_length"},{"location":"communication_api/#autosar_data.abstraction.communication.GenericTransformationTechnologyConfig.in_place","text":"in_place: bool Should the transformation take place in the existing buffer or in a separate buffer?","title":"in_place"},{"location":"communication_api/#autosar_data.abstraction.communication.GenericTransformationTechnologyConfig.protocol_name","text":"protocol_name: str The name of the custom protocol","title":"protocol_name"},{"location":"communication_api/#autosar_data.abstraction.communication.GenericTransformationTechnologyConfig.protocol_version","text":"protocol_version: str The version of the custom protocol","title":"protocol_version"},{"location":"communication_api/#autosar_data.abstraction.communication.IPduPort","text":"IPduPort(element: Element) The IPduPort allows an ECU to send or receive a PDU","title":"IPduPort"},{"location":"communication_api/#autosar_data.abstraction.communication.IPduPort.communication_direction","text":"communication_direction: Optional[CommunicationDirection] get or set the communication direction of this IPduPort","title":"communication_direction"},{"location":"communication_api/#autosar_data.abstraction.communication.IPduPort.ecu","text":"ecu: EcuInstance get the ECU instance that contains this IPduPort","title":"ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.IPduPort.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.IPduPort.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.IPv4AddressSource","text":"IPv4AddressSource defines how the address of an IPv4 NetworkEndpoint is obtained","title":"IPv4AddressSource"},{"location":"communication_api/#autosar_data.abstraction.communication.IPv4AddressSource.AutoIp","text":"AutoIp: IPv4AddressSource","title":"AutoIp"},{"location":"communication_api/#autosar_data.abstraction.communication.IPv4AddressSource.AutoIpDoIp","text":"AutoIpDoIp: IPv4AddressSource","title":"AutoIpDoIp"},{"location":"communication_api/#autosar_data.abstraction.communication.IPv4AddressSource.DHCPv4","text":"DHCPv4: IPv4AddressSource","title":"DHCPv4"},{"location":"communication_api/#autosar_data.abstraction.communication.IPv4AddressSource.Fixed","text":"Fixed: IPv4AddressSource","title":"Fixed"},{"location":"communication_api/#autosar_data.abstraction.communication.IPv6AddressSource","text":"IPv6AddressSource defines how the address of an IPv6 NetworkEndpoint is obtained","title":"IPv6AddressSource"},{"location":"communication_api/#autosar_data.abstraction.communication.IPv6AddressSource.DHCPv6","text":"DHCPv6: IPv6AddressSource","title":"DHCPv6"},{"location":"communication_api/#autosar_data.abstraction.communication.IPv6AddressSource.Fixed","text":"Fixed: IPv6AddressSource","title":"Fixed"},{"location":"communication_api/#autosar_data.abstraction.communication.IPv6AddressSource.LinkLocal","text":"LinkLocal: IPv6AddressSource","title":"LinkLocal"},{"location":"communication_api/#autosar_data.abstraction.communication.IPv6AddressSource.LinkLocalDoIp","text":"LinkLocalDoIp: IPv6AddressSource","title":"LinkLocalDoIp"},{"location":"communication_api/#autosar_data.abstraction.communication.IPv6AddressSource.RouterAdvertisement","text":"RouterAdvertisement: IPv6AddressSource","title":"RouterAdvertisement"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal","text":"ISignal(element: Element) Signal of the Interaction Layer","title":"ISignal"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.datatype","text":"datatype: Optional[SwBaseType] get or set the data type for this signal","title":"datatype"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.init_value","text":"init_value: Optional[ValueSpecification] get or set the initial value of the signal","title":"init_value"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.length","text":"length: Optional[int] set the length of this signal in bits","title":"length"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.signal_group","text":"signal_group: Optional[ISignalGroup] get the signal group that contains this signal, if any","title":"signal_group"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.system_signal","text":"system_signal: Optional[SystemSignal] get the system signal that corresponds to this isignal","title":"system_signal"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.add_data_transformation","text":"add_data_transformation( data_transformation: DataTransformation, ) -> None add a data transformation to this signal","title":"add_data_transformation"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.create_e2e_transformation_isignal_props","text":"create_e2e_transformation_isignal_props( transformer: TransformationTechnology, ) -> EndToEndTransformationISignalProps create E2E transformation properties for this signal","title":"create_e2e_transformation_isignal_props"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.create_someip_transformation_isignal_props","text":"create_someip_transformation_isignal_props( transformer: TransformationTechnology, ) -> SomeIpTransformationISignalProps create SomeIp transformation properties for this signal","title":"create_someip_transformation_isignal_props"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.data_transformations","text":"data_transformations() -> Iterator[DataTransformation] get all data transformations that are applied to this signal","title":"data_transformations"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.mappings","text":"mappings() -> List[ISignalToIPduMapping] list all ISignalToIPduMapping for this signal Usually a signal should only be mapped to a single PDU, so this list is expected to contain either zero or one items in ordinary cases.","title":"mappings"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.signal_triggerings","text":"signal_triggerings() -> List[ISignalTriggering] list all ISignalTriggering s that trigger this signal","title":"signal_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignal.transformation_isignal_props","text":"transformation_isignal_props() -> Iterator[ Union[ EndToEndTransformationISignalProps, SomeIpTransformationISignalProps, ] ] get all transformation properties that are applied to this signal","title":"transformation_isignal_props"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalGroup","text":"ISignalGroup(element: Element) An ISignalGroup groups signals that should always be kept together","title":"ISignalGroup"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalGroup.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalGroup.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalGroup.system_signal_group","text":"system_signal_group: Optional[SystemSignalGroup] get the system signal group that is associated with this signal group","title":"system_signal_group"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalGroup.add_data_transformation","text":"add_data_transformation( data_transformation: DataTransformation, ) -> None add a data transformation to this signal group","title":"add_data_transformation"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalGroup.add_signal","text":"add_signal(signal: ISignal) -> None Add a signal to the signal group","title":"add_signal"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalGroup.create_e2e_transformation_isignal_props","text":"create_e2e_transformation_isignal_props( transformer: TransformationTechnology, ) -> EndToEndTransformationISignalProps create E2E transformation properties for this signal group","title":"create_e2e_transformation_isignal_props"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalGroup.create_someip_transformation_isignal_props","text":"create_someip_transformation_isignal_props( transformer: TransformationTechnology, ) -> SomeIpTransformationISignalProps create SomeIp transformation properties for this signal group","title":"create_someip_transformation_isignal_props"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalGroup.data_transformations","text":"data_transformations() -> Iterator[DataTransformation] iterate over all data transformations that are applied to this signal group","title":"data_transformations"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalGroup.signals","text":"signals() -> Iterator[ISignal] Iterator over all [ ISignal ]s in this group","title":"signals"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalGroup.signals--example","text":"","title":"Example"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalGroup.transformation_isignal_props","text":"transformation_isignal_props() -> Iterator[ Union[ EndToEndTransformationISignalProps, SomeIpTransformationISignalProps, ] ] get all transformation properties that are applied to this signal group","title":"transformation_isignal_props"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalIPdu","text":"ISignalIPdu(element: Element) Represents the IPdus handled by Com","title":"ISignalIPdu"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalIPdu.contained_ipdu_props","text":"contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu","title":"contained_ipdu_props"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalIPdu.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalIPdu.length","text":"length: Optional[int] get or set the length of this PDU","title":"length"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalIPdu.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalIPdu.map_signal","text":"map_signal( signal: ISignal, start_position: int, byte_order: ByteOrder, /, *, update_bit: Optional[int] = None, transfer_property: TransferProperty = TransferProperty.Pending, ) -> ISignalToIPduMapping map a signal to the ISignalIPdu If this signal is part of a signal group, then the group must be mapped first","title":"map_signal"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalIPdu.map_signal_group","text":"map_signal_group( signal_group: ISignalGroup, ) -> ISignalToIPduMapping map a signal group to the PDU","title":"map_signal_group"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalIPdu.mapped_signals","text":"mapped_signals() -> Iterator[Union[ISignal, ISignalGroup]] returns an iterator over all signals and signal groups mapped to the PDU","title":"mapped_signals"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalIPdu.pdu_triggerings","text":"pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalIPdu.set_timing","text":"set_timing(timing_spec: IpduTiming) -> None set the transmission timing of the PDU","title":"set_timing"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalIPdu.timing","text":"timing() -> IpduTiming Helper function to set the transmission mode timing, used by ISignalIPdu::set_timing for both true and false timing get the transmission timing of the PDU","title":"timing"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalPort","text":"ISignalPort(element: Element) The ISignalPort allows an ECU to send or receive a Signal","title":"ISignalPort"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalPort.communication_direction","text":"communication_direction: Optional[CommunicationDirection] get or set the communication direction of this port","title":"communication_direction"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalPort.ecu","text":"ecu: EcuInstance get the ECU that is connected to this signal port","title":"ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalPort.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalPort.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalToIPduMapping","text":"ISignalToIPduMapping(element: Element) ISignalToIPduMapping connects an ISignal or ISignalGroup to an ISignalToIPdu","title":"ISignalToIPduMapping"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalToIPduMapping.byte_order","text":"byte_order: Optional[ByteOrder] get or set the byte order of the data in the mapped signal.","title":"byte_order"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalToIPduMapping.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalToIPduMapping.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalToIPduMapping.signal","text":"signal: Optional[ISignal] Reference to the signal that is mapped to the PDU. Every mapping contains either a signal or a signal group.","title":"signal"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalToIPduMapping.signal_group","text":"signal_group: Optional[ISignalGroup] Reference to the signal group that is mapped to the PDU. Every mapping contains either a signal or a signal group.","title":"signal_group"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalToIPduMapping.start_position","text":"start_position: Optional[int] Start position of the signal data within the PDU (bit position). The start position is mandatory if the mapping describes a signal.","title":"start_position"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalToIPduMapping.transfer_property","text":"transfer_property: Optional[TransferProperty] Set the transfer property of the mapped signal","title":"transfer_property"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalToIPduMapping.update_bit","text":"update_bit: Optional[int] Bit position of the update bit for the mapped signal. Not all signals use an update bit. This is never used for signal groups","title":"update_bit"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalTriggering","text":"ISignalTriggering(element: Element) an ISignalTriggering triggers a signal in a PDU","title":"ISignalTriggering"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalTriggering.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalTriggering.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalTriggering.physical_channel","text":"physical_channel: PhysicalChannel get the physical channel that contains this signal triggering","title":"physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalTriggering.connect_to_ecu","text":"connect_to_ecu( ecu: EcuInstance, direction: CommunicationDirection ) -> ISignalPort connect this signal triggering to an ECU","title":"connect_to_ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.ISignalTriggering.signal_ports","text":"signal_ports() -> Iterator[ISignalPort] create an iterator over all signal ports that are connected to this signal triggering","title":"signal_ports"},{"location":"communication_api/#autosar_data.abstraction.communication.InitialSdDelayConfig","text":"InitialSdDelayConfig( *, initial_delay_max_value: float, initial_delay_min_value: float, initial_repetitions_base_delay: Optional[float] = None, initial_repetitions_max: Optional[int] = None, ) A InitialSdDelayConfig contains the configuration for the initial delay of an SD client or server","title":"InitialSdDelayConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.InitialSdDelayConfig.initial_delay_max_value","text":"initial_delay_max_value: float maximum value of the randomized delay in seconds","title":"initial_delay_max_value"},{"location":"communication_api/#autosar_data.abstraction.communication.InitialSdDelayConfig.initial_delay_min_value","text":"initial_delay_min_value: float minimum value of the randomized delay in seconds","title":"initial_delay_min_value"},{"location":"communication_api/#autosar_data.abstraction.communication.InitialSdDelayConfig.initial_repetitions_base_delay","text":"initial_repetitions_base_delay: Optional[float] base delay for repetitions in seconds","title":"initial_repetitions_base_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.InitialSdDelayConfig.initial_repetitions_max","text":"initial_repetitions_max: Optional[int] maximum number of repetitions","title":"initial_repetitions_max"},{"location":"communication_api/#autosar_data.abstraction.communication.IpduTiming","text":"IpduTiming( *, minimum_delay: Optional[float] = None, transmission_mode_true_timing: Optional[ TransmissionModeTiming ] = None, transmission_mode_false_timing: Optional[ TransmissionModeTiming ] = None, ) Timing specification for an IPDU","title":"IpduTiming"},{"location":"communication_api/#autosar_data.abstraction.communication.IpduTiming.minimum_delay","text":"minimum_delay: Optional[float] minimum delay in seconds between two transmissions of the PDU","title":"minimum_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.IpduTiming.transmission_mode_false_timing","text":"transmission_mode_false_timing: Optional[ TransmissionModeTiming ] timing specification if the COM transmission mode is false","title":"transmission_mode_false_timing"},{"location":"communication_api/#autosar_data.abstraction.communication.IpduTiming.transmission_mode_true_timing","text":"transmission_mode_true_timing: Optional[ TransmissionModeTiming ] timing specification if the COM transmission mode is true","title":"transmission_mode_true_timing"},{"location":"communication_api/#autosar_data.abstraction.communication.LocalUnicastAddress","text":"A LocalUnicastAddress is a local address (TCP or UDP) that can be used for a ProvidedServiceInstance or ConsumedServiceInstance","title":"LocalUnicastAddress"},{"location":"communication_api/#autosar_data.abstraction.communication.LocalUnicastAddress.Tcp","text":"Tcp: Type[LocalUnicastAddress_Tcp]","title":"Tcp"},{"location":"communication_api/#autosar_data.abstraction.communication.LocalUnicastAddress.Udp","text":"Udp: Type[LocalUnicastAddress_Udp]","title":"Udp"},{"location":"communication_api/#autosar_data.abstraction.communication.LocalUnicastAddress_Tcp","text":"LocalUnicastAddress_Tcp(address: SocketAddress) Bases: LocalUnicastAddress","title":"LocalUnicastAddress_Tcp"},{"location":"communication_api/#autosar_data.abstraction.communication.LocalUnicastAddress_Tcp.address","text":"address: SocketAddress","title":"address"},{"location":"communication_api/#autosar_data.abstraction.communication.LocalUnicastAddress_Udp","text":"LocalUnicastAddress_Udp(address: SocketAddress) Bases: LocalUnicastAddress","title":"LocalUnicastAddress_Udp"},{"location":"communication_api/#autosar_data.abstraction.communication.LocalUnicastAddress_Udp.address","text":"address: SocketAddress","title":"address"},{"location":"communication_api/#autosar_data.abstraction.communication.MaximumMessageLengthType","text":"Types of Maximum Message Length that can be used in an FlexrayArTpChannel","title":"MaximumMessageLengthType"},{"location":"communication_api/#autosar_data.abstraction.communication.MaximumMessageLengthType.I4g","text":"I4g: MaximumMessageLengthType","title":"I4g"},{"location":"communication_api/#autosar_data.abstraction.communication.MaximumMessageLengthType.Iso","text":"Iso: MaximumMessageLengthType","title":"Iso"},{"location":"communication_api/#autosar_data.abstraction.communication.MaximumMessageLengthType.Iso6","text":"Iso6: MaximumMessageLengthType","title":"Iso6"},{"location":"communication_api/#autosar_data.abstraction.communication.MultiplexedIPdu","text":"MultiplexedIPdu(element: Element) The multiplexed pdu contains one of serveral signal pdus","title":"MultiplexedIPdu"},{"location":"communication_api/#autosar_data.abstraction.communication.MultiplexedIPdu.contained_ipdu_props","text":"contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu","title":"contained_ipdu_props"},{"location":"communication_api/#autosar_data.abstraction.communication.MultiplexedIPdu.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.MultiplexedIPdu.length","text":"length: Optional[int] get or set the length of this PDU","title":"length"},{"location":"communication_api/#autosar_data.abstraction.communication.MultiplexedIPdu.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.MultiplexedIPdu.pdu_triggerings","text":"pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.NPdu","text":"NPdu(element: Element) This is a Pdu of the transport layer. The main purpose of the TP layer is to segment and reassemble IPdus .","title":"NPdu"},{"location":"communication_api/#autosar_data.abstraction.communication.NPdu.contained_ipdu_props","text":"contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu","title":"contained_ipdu_props"},{"location":"communication_api/#autosar_data.abstraction.communication.NPdu.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.NPdu.length","text":"length: Optional[int] get or set the length of this PDU","title":"length"},{"location":"communication_api/#autosar_data.abstraction.communication.NPdu.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.NPdu.pdu_triggerings","text":"pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpoint","text":"NetworkEndpoint(element: Element) A network endpoint contains address information for a connection","title":"NetworkEndpoint"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpoint.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpoint.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpoint.add_network_endpoint_address","text":"add_network_endpoint_address( address: NetworkEndpointAddress, ) -> None add a network endpoint address to this NetworkEndpoint A NetworkEndpoint may have multiple sets of address information. The following restrictions apply: all addresses must have the same type, i.e. all IPv4 or all IPv6 only one of them may be a Fixed address, all others must be dynamic (DHCP, automatic link local, etc.)","title":"add_network_endpoint_address"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpoint.addresses","text":"addresses() -> Iterator[NetworkEndpointAddress] iterator over all addresses in the NetworkEndpoint","title":"addresses"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpointAddress","text":"address information for a network endpoint","title":"NetworkEndpointAddress"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpointAddress.IPv4","text":"IPv4: Type[NetworkEndpointAddress_IPv4]","title":"IPv4"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpointAddress.IPv6","text":"IPv6: Type[NetworkEndpointAddress_IPv6]","title":"IPv6"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpointAddress_IPv4","text":"NetworkEndpointAddress_IPv4( *, address: Optional[str] = None, address_source: Optional[IPv4AddressSource] = None, default_gateway: Optional[str] = None, network_mask: Optional[str] = None, ) Bases: NetworkEndpointAddress","title":"NetworkEndpointAddress_IPv4"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpointAddress_IPv4.address","text":"address: Optional[str]","title":"address"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpointAddress_IPv4.address_source","text":"address_source: Optional[IPv4AddressSource]","title":"address_source"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpointAddress_IPv4.default_gateway","text":"default_gateway: Optional[str]","title":"default_gateway"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpointAddress_IPv4.network_mask","text":"network_mask: Optional[str]","title":"network_mask"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpointAddress_IPv6","text":"NetworkEndpointAddress_IPv6( *, address: Optional[str] = None, address_source: Optional[IPv6AddressSource] = None, default_router: Optional[str] = None, ) Bases: NetworkEndpointAddress","title":"NetworkEndpointAddress_IPv6"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpointAddress_IPv6.address","text":"address: Optional[str]","title":"address"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpointAddress_IPv6.address_source","text":"address_source: Optional[IPv6AddressSource]","title":"address_source"},{"location":"communication_api/#autosar_data.abstraction.communication.NetworkEndpointAddress_IPv6.default_router","text":"default_router: Optional[str]","title":"default_router"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig","text":"NmConfig(element: Element) The NmConfig is the root element for the network management configuration. Only one config may exist per System , and this configuration may contain multiple NmClusters for different bus types. Use System::create_nm_config to create a new NmConfig in a System .","title":"NmConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig.create_can_nm_cluster","text":"create_can_nm_cluster( name: str, settings: CanNmClusterSettings, can_cluster: CanCluster, ) -> CanNmCluster create a new CanNmCluster","title":"create_can_nm_cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig.create_can_nm_cluster_coupling","text":"create_can_nm_cluster_coupling( nm_busload_reduction_enabled: bool, nm_immediate_restart_enabled: bool, ) -> CanNmClusterCoupling create a new CanNmClusterCoupling","title":"create_can_nm_cluster_coupling"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig.create_flexray_nm_cluster","text":"create_flexray_nm_cluster( name: str, settings: FlexrayNmClusterSettings, flexray_cluster: FlexrayCluster, ) -> FlexrayNmCluster create a new FlexrayNmCluster","title":"create_flexray_nm_cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig.create_flexray_nm_cluster_coupling","text":"create_flexray_nm_cluster_coupling( nm_schedule_variant: FlexrayNmScheduleVariant, ) -> FlexrayNmClusterCoupling create a new FlexrayNmClusterCoupling","title":"create_flexray_nm_cluster_coupling"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig.create_nm_ecu","text":"create_nm_ecu( name: str, ecu_instance: EcuInstance ) -> NmEcu create a new NmEcu","title":"create_nm_ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig.create_udp_nm_cluster","text":"create_udp_nm_cluster( name: str, settings: UdpNmClusterSettings, ethernet_cluster: EthernetCluster, ) -> UdpNmCluster create a new UdpNmCluster","title":"create_udp_nm_cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig.create_udp_nm_cluster_coupling","text":"create_udp_nm_cluster_coupling() -> UdpNmClusterCoupling create a new UdpNmClusterCoupling","title":"create_udp_nm_cluster_coupling"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig.nm_cluster_couplings","text":"nm_cluster_couplings() -> Iterator[ Union[ CanNmClusterCoupling, FlexrayNmClusterCoupling, UdpNmClusterCoupling, ] ] iterate over all NmClusterCouplings","title":"nm_cluster_couplings"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig.nm_clusters","text":"nm_clusters() -> Iterator[ Union[CanNmCluster, FlexrayNmCluster, UdpNmCluster] ] get all NmClusters","title":"nm_clusters"},{"location":"communication_api/#autosar_data.abstraction.communication.NmConfig.nm_ecus","text":"nm_ecus() -> Iterator[NmEcu] iterate over all NmEcus","title":"nm_ecus"},{"location":"communication_api/#autosar_data.abstraction.communication.NmEcu","text":"NmEcu(element: Element) The NmEcu represents an EcuInstance wich participates in network management.","title":"NmEcu"},{"location":"communication_api/#autosar_data.abstraction.communication.NmEcu.cycle_time_main_function","text":"cycle_time_main_function: Optional[float] get or set or remove the nmCycletimeMainFunction value","title":"cycle_time_main_function"},{"location":"communication_api/#autosar_data.abstraction.communication.NmEcu.ecu_instance","text":"ecu_instance: Optional[EcuInstance] get or set the referenced EcuInstance","title":"ecu_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.NmEcu.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.NmEcu.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.NmEcu.nm_bus_synchronization_enabled","text":"nm_bus_synchronization_enabled: Optional[bool] get or set the nmBusSynchronizationEnabled flag","title":"nm_bus_synchronization_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.NmEcu.nm_com_control_enabled","text":"nm_com_control_enabled: Optional[bool] get or set the nmComControlEnabled flag","title":"nm_com_control_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.NmPdu","text":"NmPdu(element: Element) Network Management Pdu","title":"NmPdu"},{"location":"communication_api/#autosar_data.abstraction.communication.NmPdu.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.NmPdu.length","text":"length: Optional[int] get or set the length of this PDU","title":"length"},{"location":"communication_api/#autosar_data.abstraction.communication.NmPdu.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.NmPdu.pdu_triggerings","text":"pdu_triggerings() -> List[PduTriggering] List all PduTriggerings that trigger this PDU","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.PduActivationRoutingGroup","text":"PduActivationRoutingGroup(element: Element) A group of Pdus that can be activated or deactivated for transmission over a socket connection. It is used by EventHandler s in ProvidedServiceInstance s and ConsumedServiceInstance s.","title":"PduActivationRoutingGroup"},{"location":"communication_api/#autosar_data.abstraction.communication.PduActivationRoutingGroup.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.PduActivationRoutingGroup.event_group_control_type","text":"event_group_control_type: Optional[EventGroupControlType] get or set the event group control type of this PduActivationRoutingGroup","title":"event_group_control_type"},{"location":"communication_api/#autosar_data.abstraction.communication.PduActivationRoutingGroup.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.PduActivationRoutingGroup.add_ipdu_identifier_tcp","text":"add_ipdu_identifier_tcp( ipdu_identifier: SoConIPduIdentifier, ) -> None add a reference to a SoConIPduIdentifier for TCP communication to this PduActivationRoutingGroup","title":"add_ipdu_identifier_tcp"},{"location":"communication_api/#autosar_data.abstraction.communication.PduActivationRoutingGroup.add_ipdu_identifier_udp","text":"add_ipdu_identifier_udp( ipdu_identifier: SoConIPduIdentifier, ) -> None add a reference to a SoConIPduIdentifier for UDP communication to this PduActivationRoutingGroup","title":"add_ipdu_identifier_udp"},{"location":"communication_api/#autosar_data.abstraction.communication.PduActivationRoutingGroup.ipdu_identifiers_tcp","text":"ipdu_identifiers_tcp() -> Iterator[SoConIPduIdentifier] get all SoConIPduIdentifier s for TCP communication in this PduActivationRoutingGroup","title":"ipdu_identifiers_tcp"},{"location":"communication_api/#autosar_data.abstraction.communication.PduActivationRoutingGroup.ipdu_identifiers_udp","text":"ipdu_identifiers_udp() -> Iterator[SoConIPduIdentifier] get all SoConIPduIdentifier s for UDP communication in this PduActivationRoutingGroup","title":"ipdu_identifiers_udp"},{"location":"communication_api/#autosar_data.abstraction.communication.PduCollectionTrigger","text":"The collction trigger defines whether a Pdu contributes to the triggering of the data transmission if Pdu collection is enabled","title":"PduCollectionTrigger"},{"location":"communication_api/#autosar_data.abstraction.communication.PduCollectionTrigger.Always","text":"Always: PduCollectionTrigger","title":"Always"},{"location":"communication_api/#autosar_data.abstraction.communication.PduCollectionTrigger.Never","text":"Never: PduCollectionTrigger","title":"Never"},{"location":"communication_api/#autosar_data.abstraction.communication.PduToFrameMapping","text":"PduToFrameMapping(element: Element) PduToFrameMapping connects a PDU to a frame","title":"PduToFrameMapping"},{"location":"communication_api/#autosar_data.abstraction.communication.PduToFrameMapping.byte_order","text":"byte_order: Optional[ByteOrder] get or set the byte order of the data in the PDU. All PduToFrameMappings within a frame must have the same byte order. PDUs may not use the byte order value Opaque . Note: If the byte order is swapped, then the start position must be adjusted accordingly.","title":"byte_order"},{"location":"communication_api/#autosar_data.abstraction.communication.PduToFrameMapping.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.PduToFrameMapping.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.PduToFrameMapping.pdu","text":"pdu: Optional[Pdu] Reference to the PDU that is mapped into the frame. The PDU reference is mandatory.","title":"pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.PduToFrameMapping.start_position","text":"start_position: Optional[int] set the start position of the PDU data within the frame (bit position). PDUs are byte aligned. For little-endian data the values 0, 8, 16, ... are allowed; for big-endian data the values 7, 15, 23, ... are allowed. Note: if you intend to change both the byte order and the start position, then you should change the byte order first. New values set here must match the configured byte order.","title":"start_position"},{"location":"communication_api/#autosar_data.abstraction.communication.PduToFrameMapping.update_bit","text":"update_bit: Optional[int] set or clear the bit position of the update bit for the mapped PDU.","title":"update_bit"},{"location":"communication_api/#autosar_data.abstraction.communication.PduTriggering","text":"PduTriggering(element: Element) a PduTriggering triggers a PDU in a frame or ethernet connection","title":"PduTriggering"},{"location":"communication_api/#autosar_data.abstraction.communication.PduTriggering.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.PduTriggering.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.PduTriggering.pdu","text":"pdu: Optional[Pdu] get the Pdu that is triggered by this pdu triggering","title":"pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.PduTriggering.physical_channel","text":"physical_channel: PhysicalChannel get the physical channel that contains this pdu triggering","title":"physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.PduTriggering.create_pdu_port","text":"create_pdu_port( ecu: EcuInstance, direction: CommunicationDirection ) -> IPduPort create an IPduPort to connect a PduTriggering to an EcuInstance","title":"create_pdu_port"},{"location":"communication_api/#autosar_data.abstraction.communication.PduTriggering.pdu_ports","text":"pdu_ports() -> Iterator[IPduPort] create an iterator over the IPduPorts that are connected to this PduTriggering","title":"pdu_ports"},{"location":"communication_api/#autosar_data.abstraction.communication.PduTriggering.signal_triggerings","text":"signal_triggerings() -> Iterator[ISignalTriggering] create an iterator over the ISignalTriggerings that are triggered by this PduTriggering","title":"signal_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstance","text":"ProvidedServiceInstance(element: Element) A ProvidedServiceInstance is a service that is provided by an ECU","title":"ProvidedServiceInstance"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstance.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstance.instance_identifier","text":"instance_identifier: Optional[int] get or set the instance identifier of this ProvidedServiceInstance","title":"instance_identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstance.major_version","text":"major_version: Optional[int] get or set the major version of this ProvidedServiceInstance","title":"major_version"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstance.minor_version","text":"minor_version: Optional[int] get or set the minor version of this ProvidedServiceInstance","title":"minor_version"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstance.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstance.sd_server_instance_config","text":"sd_server_instance_config: Optional[ SomeipSdServerServiceInstanceConfig ] get or set the SD server instance configuration for this ProvidedServiceInstance","title":"sd_server_instance_config"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstance.service_identifier","text":"service_identifier: Optional[int] get or set the service identifier of this ProvidedServiceInstance","title":"service_identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstance.create_event_handler","text":"create_event_handler( name: str, event_group_identifier: int ) -> EventHandler create a new EventHandler in this ProvidedServiceInstance","title":"create_event_handler"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstance.event_handlers","text":"event_handlers() -> Iterator[EventHandler] get the EventHandler s in this ProvidedServiceInstance","title":"event_handlers"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstance.local_unicast_addresses","text":"local_unicast_addresses() -> Iterator[LocalUnicastAddress] iterate over the local unicast addresses","title":"local_unicast_addresses"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstance.set_local_unicast_address","text":"set_local_unicast_address(address: SocketAddress) -> None set a local unicast address for this ProvidedServiceInstance The PSI may use two local unicast addresses, one each for UDP and TCP. The unicast address is used to assign the service to a specific ECU, and may not be empty.","title":"set_local_unicast_address"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstanceV1","text":"ProvidedServiceInstanceV1(element: Element) A ProvidedServiceInstanceV1 is a SD service instance that is provided by this ECU. This is the old V1 version of the service definition.","title":"ProvidedServiceInstanceV1"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstanceV1.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstanceV1.instance_identifier","text":"instance_identifier: Optional[int] get or set the instance identifier of this ProvidedServiceInstance","title":"instance_identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstanceV1.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstanceV1.service_identifier","text":"service_identifier: Optional[int] get or set the service identifier of this ProvidedServiceInstance","title":"service_identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstanceV1.create_event_handler","text":"create_event_handler(name: str) -> EventHandlerV1 create a new EventHandlerV1 in this ProvidedServiceInstance","title":"create_event_handler"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstanceV1.event_handlers","text":"event_handlers() -> Iterator[EventHandlerV1] get the EventHandlerV1 s in this ProvidedServiceInstance","title":"event_handlers"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstanceV1.sd_server_config","text":"sd_server_config() -> Optional[SdConfig] get or set the SD server configuration for this ProvidedServiceInstance","title":"sd_server_config"},{"location":"communication_api/#autosar_data.abstraction.communication.ProvidedServiceInstanceV1.set_sd_server_config","text":"set_sd_server_config(sd_server_config: SdConfig) -> None get or set the SD server configuration for this ProvidedServiceInstance","title":"set_sd_server_config"},{"location":"communication_api/#autosar_data.abstraction.communication.RequestResponseDelay","text":"RequestResponseDelay(*, min_value: float, max_value: float) A RequestResponseDelay contains the minimum and maximum delay for a request-response cycle","title":"RequestResponseDelay"},{"location":"communication_api/#autosar_data.abstraction.communication.RequestResponseDelay.max_value","text":"max_value: float set the maximum value of this RequestResponseDelay","title":"max_value"},{"location":"communication_api/#autosar_data.abstraction.communication.RequestResponseDelay.min_value","text":"min_value: float set the minimum value of this RequestResponseDelay","title":"min_value"},{"location":"communication_api/#autosar_data.abstraction.communication.RxAcceptContainedIPdu","text":"The RxAcceptContainedIPdu enum defines whether a fixed set of contained IPdus is accepted or all contained IPdus","title":"RxAcceptContainedIPdu"},{"location":"communication_api/#autosar_data.abstraction.communication.RxAcceptContainedIPdu.AcceptAll","text":"AcceptAll: RxAcceptContainedIPdu","title":"AcceptAll"},{"location":"communication_api/#autosar_data.abstraction.communication.RxAcceptContainedIPdu.AcceptConfigured","text":"AcceptConfigured: RxAcceptContainedIPdu","title":"AcceptConfigured"},{"location":"communication_api/#autosar_data.abstraction.communication.SdConfig","text":"SdConfig( *, service_major_version: int, service_minor_version: int, initial_delay_max_value: float, initial_delay_min_value: float, initial_repetitions_base_delay: Optional[float] = None, initial_repetitions_max: int, offer_cyclic_delay: Optional[float] = None, request_response_delay_max_value: float, request_response_delay_min_value: float, ttl: int, ) SD configuration for a service instance This struct is used to configure the SD server and client behavior for a service instance. it is used for the old V1 service definitions.","title":"SdConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.SdConfig.initial_delay_max_value","text":"initial_delay_max_value: float The maximum delay for the initial offer","title":"initial_delay_max_value"},{"location":"communication_api/#autosar_data.abstraction.communication.SdConfig.initial_delay_min_value","text":"initial_delay_min_value: float The minimum delay for the initial offer","title":"initial_delay_min_value"},{"location":"communication_api/#autosar_data.abstraction.communication.SdConfig.initial_repetitions_base_delay","text":"initial_repetitions_base_delay: Optional[float] The base delay for offer repetitions (if aggregated by SdServerConfig ) or find repetitions (if aggregated by SdClientConfig )","title":"initial_repetitions_base_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.SdConfig.initial_repetitions_max","text":"initial_repetitions_max: int The maximum number of repetitions for the initial offer or find","title":"initial_repetitions_max"},{"location":"communication_api/#autosar_data.abstraction.communication.SdConfig.offer_cyclic_delay","text":"offer_cyclic_delay: Optional[float] The delay between two offers (if aggregated by SdServerConfig ) or finds (if aggregated by SdClientConfig )","title":"offer_cyclic_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.SdConfig.request_response_delay_max_value","text":"request_response_delay_max_value: float The maximum delay for a request-response cycle","title":"request_response_delay_max_value"},{"location":"communication_api/#autosar_data.abstraction.communication.SdConfig.request_response_delay_min_value","text":"request_response_delay_min_value: float The minimum delay for a request-response cycle","title":"request_response_delay_min_value"},{"location":"communication_api/#autosar_data.abstraction.communication.SdConfig.service_major_version","text":"service_major_version: int The major version of the service","title":"service_major_version"},{"location":"communication_api/#autosar_data.abstraction.communication.SdConfig.service_minor_version","text":"service_minor_version: int The minor version of the service","title":"service_minor_version"},{"location":"communication_api/#autosar_data.abstraction.communication.SdConfig.ttl","text":"ttl: int The time-to-live for the service offer","title":"ttl"},{"location":"communication_api/#autosar_data.abstraction.communication.SdEventConfig","text":"SdEventConfig( *, request_response_delay_max_value: float, request_response_delay_min_value: float, ttl: int, ) Configuration for an SD event handler","title":"SdEventConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.SdEventConfig.request_response_delay_max_value","text":"request_response_delay_max_value: float The maximum delay for a request-response cycle","title":"request_response_delay_max_value"},{"location":"communication_api/#autosar_data.abstraction.communication.SdEventConfig.request_response_delay_min_value","text":"request_response_delay_min_value: float The minimum delay for a request-response cycle","title":"request_response_delay_min_value"},{"location":"communication_api/#autosar_data.abstraction.communication.SdEventConfig.ttl","text":"ttl: int The time-to-live for the service offer","title":"ttl"},{"location":"communication_api/#autosar_data.abstraction.communication.SecureCommunicationProps","text":"SecureCommunicationProps( *, auth_data_freshness_length: Optional[int] = None, auth_data_freshness_start_position: Optional[ int ] = None, authentication_build_attempts: Optional[int] = None, authentication_retries: Optional[int] = None, data_id: Optional[int] = None, freshness_value_id: Optional[int] = None, message_link_length: Optional[int] = None, message_link_position: Optional[int] = None, secondary_freshness_value_id: Optional[int] = None, secured_area_length: Optional[int] = None, secured_area_offset: Optional[int] = None, ) The properties of a SecuredIPdu","title":"SecureCommunicationProps"},{"location":"communication_api/#autosar_data.abstraction.communication.SecureCommunicationProps.auth_data_freshness_length","text":"auth_data_freshness_length: Optional[int] length in bits of the authentic PDU data","title":"auth_data_freshness_length"},{"location":"communication_api/#autosar_data.abstraction.communication.SecureCommunicationProps.auth_data_freshness_start_position","text":"auth_data_freshness_start_position: Optional[int] start position in bits of the authentic PDU data","title":"auth_data_freshness_start_position"},{"location":"communication_api/#autosar_data.abstraction.communication.SecureCommunicationProps.authentication_build_attempts","text":"authentication_build_attempts: Optional[int] number of authentication build attempts","title":"authentication_build_attempts"},{"location":"communication_api/#autosar_data.abstraction.communication.SecureCommunicationProps.authentication_retries","text":"authentication_retries: Optional[int] number of additional authentication attempts. If this value is zero, the authentication is not repeated","title":"authentication_retries"},{"location":"communication_api/#autosar_data.abstraction.communication.SecureCommunicationProps.data_id","text":"data_id: Optional[int] numerical identifier of the secured IPdu","title":"data_id"},{"location":"communication_api/#autosar_data.abstraction.communication.SecureCommunicationProps.freshness_value_id","text":"freshness_value_id: Optional[int] id of the freshness value","title":"freshness_value_id"},{"location":"communication_api/#autosar_data.abstraction.communication.SecureCommunicationProps.message_link_length","text":"message_link_length: Optional[int] message link length in bits","title":"message_link_length"},{"location":"communication_api/#autosar_data.abstraction.communication.SecureCommunicationProps.message_link_position","text":"message_link_position: Optional[int] message link start position in bits","title":"message_link_position"},{"location":"communication_api/#autosar_data.abstraction.communication.SecureCommunicationProps.secondary_freshness_value_id","text":"secondary_freshness_value_id: Optional[int] seconday freshness value id","title":"secondary_freshness_value_id"},{"location":"communication_api/#autosar_data.abstraction.communication.SecureCommunicationProps.secured_area_length","text":"secured_area_length: Optional[int] length in bytes of the secure area inside the payload pdu","title":"secured_area_length"},{"location":"communication_api/#autosar_data.abstraction.communication.SecureCommunicationProps.secured_area_offset","text":"secured_area_offset: Optional[int] start position in bytes of the secure area inside the payload pdu","title":"secured_area_offset"},{"location":"communication_api/#autosar_data.abstraction.communication.SecuredIPdu","text":"SecuredIPdu(element: Element) Wraps an IPdu to protect it from unauthorized manipulation","title":"SecuredIPdu"},{"location":"communication_api/#autosar_data.abstraction.communication.SecuredIPdu.contained_ipdu_props","text":"contained_ipdu_props: Optional[ContainedIPduProps] set the ContainedIPduProps for this IPdu This is only needed when the IPdu is contained in a ContainerIPdu","title":"contained_ipdu_props"},{"location":"communication_api/#autosar_data.abstraction.communication.SecuredIPdu.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SecuredIPdu.length","text":"length: Optional[int] get or set the length of this PDU","title":"length"},{"location":"communication_api/#autosar_data.abstraction.communication.SecuredIPdu.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SecuredIPdu.payload_pdu_triggering","text":"payload_pdu_triggering: Optional[PduTriggering] get or set the PduTriggering that triggers the payload PDU When use_as_cryptographic_ipdu is true, this attribute can be used to directly set PduTriggering of the payload PDU. When use_as_cryptographic_ipdu is false, the function set_payload_ipdu should be used to create a new PduTriggering and set it.","title":"payload_pdu_triggering"},{"location":"communication_api/#autosar_data.abstraction.communication.SecuredIPdu.secure_communication_props","text":"secure_communication_props: Optional[ SecureCommunicationProps ]","title":"secure_communication_props"},{"location":"communication_api/#autosar_data.abstraction.communication.SecuredIPdu.use_as_cryptographic_ipdu","text":"use_as_cryptographic_ipdu: Optional[bool]","title":"use_as_cryptographic_ipdu"},{"location":"communication_api/#autosar_data.abstraction.communication.SecuredIPdu.pdu_triggerings","text":"pdu_triggerings() -> List[PduTriggering] list all PduTriggerings that trigger this PDU","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.SecuredIPdu.set_payload_ipdu","text":"set_payload_ipdu( pdu: IPdu, physical_channel: PhysicalChannel ) -> PduTriggering set the payload PduTriggering based on an IPdu This function should be used when useAsCryptographicIPdu is false or not set. A PduTriggering is created for the Pdu","title":"set_payload_ipdu"},{"location":"communication_api/#autosar_data.abstraction.communication.ServiceInstanceCollectionSet","text":"ServiceInstanceCollectionSet(element: Element) A ServiceInstanceCollectionSet contains ServiceInstance s that are provided or consumed by an ECU","title":"ServiceInstanceCollectionSet"},{"location":"communication_api/#autosar_data.abstraction.communication.ServiceInstanceCollectionSet.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.ServiceInstanceCollectionSet.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.ServiceInstanceCollectionSet.create_consumed_service_instance","text":"create_consumed_service_instance( name: str, service_identifier: int, instance_identifier: int, major_version: int, minor_version: str, ) -> ConsumedServiceInstance create a new ConsumedServiceInstance in this ServiceInstanceCollectionSet","title":"create_consumed_service_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.ServiceInstanceCollectionSet.create_provided_service_instance","text":"create_provided_service_instance( name: str, service_identifier: int, instance_identifier: int, major_version: int, minor_version: int, ) -> ProvidedServiceInstance create a new ProvidedServiceInstance in this ServiceInstanceCollectionSet","title":"create_provided_service_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.ServiceInstanceCollectionSet.service_instances","text":"service_instances() -> Iterator[ Union[ConsumedServiceInstance, ProvidedServiceInstance] ] create an iterator over all ServiceInstances in this set","title":"service_instances"},{"location":"communication_api/#autosar_data.abstraction.communication.SoAdRoutingGroup","text":"SoAdRoutingGroup(element: Element) A SoAdRoutingGroup is used to link SomeIp settings in Consumed/ProvidedServiceInstances to the SocketConnectionBundles used for transmission. SoAdRoutingGroups are part of the old way of configuring Ethernet communication in AUTOSAR.","title":"SoAdRoutingGroup"},{"location":"communication_api/#autosar_data.abstraction.communication.SoAdRoutingGroup.control_type","text":"control_type: Optional[EventGroupControlType] get or set the EventGroupControlType of this SoAdRoutingGroup","title":"control_type"},{"location":"communication_api/#autosar_data.abstraction.communication.SoAdRoutingGroup.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SoAdRoutingGroup.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SoConIPduIdentifier","text":"SoConIPduIdentifier(element: Element) A SoConIPduIdentifier describes a PDU that is transported over a static socket connection.","title":"SoConIPduIdentifier"},{"location":"communication_api/#autosar_data.abstraction.communication.SoConIPduIdentifier.collection_trigger","text":"collection_trigger: Optional[PduCollectionTrigger] get or set the collection trigger for this SoConIPduIdentifier","title":"collection_trigger"},{"location":"communication_api/#autosar_data.abstraction.communication.SoConIPduIdentifier.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SoConIPduIdentifier.header_id","text":"header_id: Optional[int] get or set the header id for this SoConIPduIdentifier","title":"header_id"},{"location":"communication_api/#autosar_data.abstraction.communication.SoConIPduIdentifier.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SoConIPduIdentifier.pdu_triggering","text":"pdu_triggering: Optional[PduTriggering] get the PduTriggering referenced by this SoConIPduIdentifier","title":"pdu_triggering"},{"location":"communication_api/#autosar_data.abstraction.communication.SoConIPduIdentifier.timeout","text":"timeout: Optional[float] set the timeout for this SoConIPduIdentifier","title":"timeout"},{"location":"communication_api/#autosar_data.abstraction.communication.SoConIPduIdentifier.set_pdu","text":"set_pdu(pdu: Pdu, channel: EthernetPhysicalChannel) -> None create a new PduTriggering for the pdu and reference it in this SoConIPduIdentifier","title":"set_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress","text":"SocketAddress(element: Element) A socket address establishes the link between one or more ECUs and a NetworkEndpoint . It contains all settings that are relevant for this combination.","title":"SocketAddress"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.network_endpoint","text":"network_endpoint: Optional[NetworkEndpoint] get the network endpoint of this SocketAddress","title":"network_endpoint"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.physical_channel","text":"physical_channel: EthernetPhysicalChannel get the EthernetPhysicalChannel containing this SocketAddress","title":"physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.socket_address_type","text":"socket_address_type: Optional[SocketAddressType] get the socket address type: unicast / multicast, as well as the connected ecus","title":"socket_address_type"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.tp_config","text":"tp_config: Optional[TpConfig] get the transport protocol settings for this SocketAddress","title":"tp_config"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.add_multicast_ecu","text":"add_multicast_ecu(ecu: EcuInstance) -> None add an EcuInstance to this multicast SocketAddress","title":"add_multicast_ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.consumed_service_instances","text":"consumed_service_instances() -> Iterator[ ConsumedServiceInstanceV1 ] get the ConsumedServiceInstance s in this SocketAddress","title":"consumed_service_instances"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.create_consumed_service_instance","text":"create_consumed_service_instance( name: str, provided_service_instance: ProvidedServiceInstanceV1, ) -> ConsumedServiceInstanceV1 create a ConsumedServiceInstanceV1 in this SocketAddress Creating a ConsumedServiceInstanceV1 in a SocketAddress is part of the old way of defining services (<= Autosar 4.5.0). It is obsolete in newer versions of the standard. When using the new way of defining services, a ConsumedServiceInstance should be created in a ServiceInstanceCollectionSet instead.","title":"create_consumed_service_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.create_provided_service_instance","text":"create_provided_service_instance( name: str, service_identifier: int, instance_identifier: int, ) -> ProvidedServiceInstanceV1 create a ProvidedServiceInstanceV1 in this SocketAddress Creating a ProvidedServiceInstanceV1 in a SocketAddress is part of the old way of defining services (<= Autosar 4.5.0). It is obsolete in newer versions of the standard. When using the new way of defining services, a ProvidedServiceInstance should be created in a ServiceInstanceCollectionSet instead.","title":"create_provided_service_instance"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.create_static_socket_connection","text":"create_static_socket_connection( name: str, remote_address: SocketAddress, /, *, tcp_role: Optional[TcpRole] = None, tcp_connect_timeout: Optional[float] = None, ) -> StaticSocketConnection create a new StaticSocketConnection from this SocketAddress to a remote SocketAddress","title":"create_static_socket_connection"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.provided_service_instances","text":"provided_service_instances() -> Iterator[ ProvidedServiceInstanceV1 ] get the ProvidedServiceInstanceV1 s in this SocketAddress","title":"provided_service_instances"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.set_unicast_ecu","text":"set_unicast_ecu(ecu: EcuInstance) -> None set the EcuInstance for this unicast SocketAddress","title":"set_unicast_ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddress.static_socket_connections","text":"static_socket_connections() -> Iterator[ StaticSocketConnection ] iterate over all StaticSocketConnection s in this SocketAddress","title":"static_socket_connections"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddressType","text":"Describes if a [ SocketAddress ] is used for unicast or multicast","title":"SocketAddressType"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddressType.Multicast","text":"Multicast: Type[SocketAddressType_Multicast]","title":"Multicast"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddressType.Unicast","text":"Unicast: Type[SocketAddressType_Unicast] SocketAddressType.Unicast(ecu | None)","title":"Unicast"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddressType_Multicast","text":"SocketAddressType_Multicast(ecus: List[EcuInstance] = []) Bases: SocketAddressType","title":"SocketAddressType_Multicast"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddressType_Multicast.ecus","text":"ecus: List[EcuInstance]","title":"ecus"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddressType_Unicast","text":"SocketAddressType_Unicast( ecu: Optional[EcuInstance] = None, ) Bases: SocketAddressType","title":"SocketAddressType_Unicast"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketAddressType_Unicast.ecu","text":"ecu: Optional[EcuInstance]","title":"ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnection","text":"SocketConnection(element: Element) A socketConnection inside a SocketConnectionBundle describes a single connection to a specific client port.","title":"SocketConnection"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnection.client_ip_addr_from_connection_request","text":"client_ip_addr_from_connection_request: Optional[bool] get or set the client_ip_addr_from_connection_request attribute for this socket connection if the value is Some(true), the attribute is set to \"true\" if the value is Some(false), the attribute is set to \"false\" if the value is None, the attribute is removed","title":"client_ip_addr_from_connection_request"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnection.client_port","text":"client_port: Optional[SocketAddress] get or set the client port of this socket connection","title":"client_port"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnection.client_port_from_connection_request","text":"client_port_from_connection_request: Optional[bool] get or set the client_port_from_connection_request attribute for this socket connection if the value is Some(true), the attribute is set to \"true\" if the value is Some(false), the attribute is set to \"false\" if the value is None, the attribute is removed","title":"client_port_from_connection_request"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnection.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnection.runtime_ip_address_configuration","text":"runtime_ip_address_configuration: bool get or set the value of the RuntimeIpAddressConfiguration attribute for this socket connection","title":"runtime_ip_address_configuration"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnection.runtime_port_configuration","text":"runtime_port_configuration: bool get or set the value of the RuntimePortConfiguration attribute for this socket connection","title":"runtime_port_configuration"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnection.socket_connection_bundle","text":"socket_connection_bundle: SocketConnectionBundle get the socket connection bundle containing this socket connection","title":"socket_connection_bundle"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnection.create_socket_connection_ipdu_identifier","text":"create_socket_connection_ipdu_identifier( pdu: Pdu, header_id: int, /, *, timeout: Optional[float] = None, collection_trigger: Optional[ PduCollectionTrigger ] = None, ) -> Tuple[SocketConnectionIpduIdentifier, PduTriggering] add a PDU to the socket connection, returning a PduTriggering","title":"create_socket_connection_ipdu_identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnection.pdu_triggerings","text":"pdu_triggerings() -> Iterator[PduTriggering] create an iterator over all PDU triggerings in this socket connection","title":"pdu_triggerings"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnection.socket_connection_ipdu_identifiers","text":"socket_connection_ipdu_identifiers() -> Iterator[ SocketConnectionIpduIdentifier ] create an iterator over all SocketConnectionIpduIdentifiers in this socket connection","title":"socket_connection_ipdu_identifiers"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionBundle","text":"SocketConnectionBundle(element: Element) A SocketConnectionBundle describes a connection between a server port and multiple client ports. It contains multiple bundled connections, each transporting one or more PDUs.","title":"SocketConnectionBundle"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionBundle.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionBundle.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionBundle.physical_channel","text":"physical_channel: EthernetPhysicalChannel get the physical channel containing this socket connection bundle","title":"physical_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionBundle.server_port","text":"server_port: Optional[SocketAddress] get or set the server port of this socket connection bundle","title":"server_port"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionBundle.bundled_connections","text":"bundled_connections() -> Iterator[SocketConnection] create an iterator over all bundled connections in this socket connection bundle","title":"bundled_connections"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionBundle.create_bundled_connection","text":"create_bundled_connection( client_port: SocketAddress, ) -> SocketConnection create a bundled SocketConnection between the server port and a client port","title":"create_bundled_connection"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifier","text":"SocketConnectionIpduIdentifier(element: Element) A SocketConnectionIpduIdentifier is used to trigger a PDU in a SocketConnection . In addition to the Pdu Triggering, it also contains associated settings like the header id, timeout and collection trigger.","title":"SocketConnectionIpduIdentifier"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifier.collection_trigger","text":"collection_trigger: Optional[PduCollectionTrigger] set the collection trigger for this SocketConnectionIpduIdentifier","title":"collection_trigger"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifier.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifier.header_id","text":"header_id: Optional[int] set the header id for this SocketConnectionIpduIdentifier","title":"header_id"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifier.pdu_triggering","text":"pdu_triggering: Optional[PduTriggering] get the PduTriggering associated with this SocketConnectionIpduIdentifier","title":"pdu_triggering"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifier.socket_connection","text":"socket_connection: SocketConnection get the SocketConnection containing this SocketConnectionIpduIdentifier","title":"socket_connection"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifier.timeout","text":"timeout: Optional[float] set the timeout for this SocketConnectionIpduIdentifier","title":"timeout"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifier.add_routing_group","text":"add_routing_group(routing_group: SoAdRoutingGroup) -> None add a reference to a SoAdRoutingGroup to this SocketConnectionIpduIdentifier","title":"add_routing_group"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifier.routing_groups","text":"routing_groups() -> Iterator[SoAdRoutingGroup] create an iterator over all SoAdRoutingGroups referenced by this SocketConnectionIpduIdentifier","title":"routing_groups"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifier.trigger_pdu","text":"trigger_pdu(pdu: Pdu) -> PduTriggering trigger a PDU in this SocketConnectionIpduIdentifier , creating a PduTriggering","title":"trigger_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifierSet","text":"SocketConnectionIpduIdentifierSet(element: Element) A SocketConnectionIpduIdentifierSet contains a set of SoConIPduIdentifiers , which are used in static socket connections and in SomeIp events.","title":"SocketConnectionIpduIdentifierSet"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifierSet.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifierSet.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifierSet.create_socon_ipdu_identifier","text":"create_socon_ipdu_identifier( name: str, pdu: Pdu, channel: EthernetPhysicalChannel, /, *, header_id: Optional[int] = None, timeout: Optional[float] = None, collection_trigger: Optional[ PduCollectionTrigger ] = None, ) -> SoConIPduIdentifier create a new SoConIPduIdentifier in this set","title":"create_socon_ipdu_identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.SocketConnectionIpduIdentifierSet.socon_ipdu_identifiers","text":"socon_ipdu_identifiers() -> Iterator[SoConIPduIdentifier] create an iterator over all SoConIPduIdentifiers in this set","title":"socon_ipdu_identifiers"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpMessageType","text":"message types that can be used in a SOME/IP message header, depending on the type of communication","title":"SomeIpMessageType"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpMessageType.Notification","text":"Notification: SomeIpMessageType","title":"Notification"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpMessageType.Request","text":"Request: SomeIpMessageType","title":"Request"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpMessageType.RequestNoReturn","text":"RequestNoReturn: SomeIpMessageType","title":"RequestNoReturn"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpMessageType.Response","text":"Response: SomeIpMessageType","title":"Response"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationISignalProps","text":"SomeIpTransformationISignalProps(element: Element) Properties for the SOMEIP transformation of an ISignal(Group)","title":"SomeIpTransformationISignalProps"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationISignalProps.dynamic_length","text":"dynamic_length: Optional[bool] get or set the dynamic length property","title":"dynamic_length"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationISignalProps.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationISignalProps.interface_version","text":"interface_version: Optional[int] get or set the interface version property","title":"interface_version"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationISignalProps.legacy_strings","text":"legacy_strings: Optional[bool] get or set the legacy strings property","title":"legacy_strings"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationISignalProps.message_type","text":"message_type: Optional[SomeIpMessageType] get or set the message type property","title":"message_type"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationISignalProps.size_of_array_length","text":"size_of_array_length: Optional[int] get or set the size of array length property","title":"size_of_array_length"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationISignalProps.size_of_string_length","text":"size_of_string_length: Optional[int] get or set the size of string length property","title":"size_of_string_length"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationISignalProps.size_of_struct_length","text":"size_of_struct_length: Optional[int] get or set the size of struct length property","title":"size_of_struct_length"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationISignalProps.size_of_union_length","text":"size_of_union_length: Optional[int] get or set the size of union length property","title":"size_of_union_length"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationISignalProps.transformer","text":"transformer: Optional[TransformationTechnology] get or set the transformer reference of the E2E transformation properties","title":"transformer"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationTechnologyConfig","text":"SomeIpTransformationTechnologyConfig( *, alignment: int, byte_order: ByteOrder, interface_version: int, ) Configuration for a SOMEIP transformation","title":"SomeIpTransformationTechnologyConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationTechnologyConfig.alignment","text":"alignment: int The alignment of the data in bits","title":"alignment"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationTechnologyConfig.byte_order","text":"byte_order: ByteOrder The byte order of the data","title":"byte_order"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeIpTransformationTechnologyConfig.interface_version","text":"interface_version: int The interface version the SOME/IP transformer shall use.","title":"interface_version"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientEventGroupTimingConfig","text":"SomeipSdClientEventGroupTimingConfig(element: Element) A SomeipSdClientEventGroupTimingConfig contains the configuration for the timing of a ConsumedEventGroup This configuration is a named element that is created separately and can be used by multiple ConsumedEventGroup s. Use [ ArPackage::create_someip_sd_client_event_group_timing_config ] to create a new SomeipSdClientEventGroupTimingConfig .","title":"SomeipSdClientEventGroupTimingConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientEventGroupTimingConfig.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientEventGroupTimingConfig.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientEventGroupTimingConfig.subscribe_eventgroup_retry_delay","text":"subscribe_eventgroup_retry_delay: Optional[float] get or set the subscribe eventgroup retry delay of this SomeipSdClientEventGroupTimingConfig","title":"subscribe_eventgroup_retry_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientEventGroupTimingConfig.subscribe_eventgroup_retry_max","text":"subscribe_eventgroup_retry_max: Optional[int] get or set subscribe eventgroup retry max of this SomeipSdClientEventGroupTimingConfig","title":"subscribe_eventgroup_retry_max"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientEventGroupTimingConfig.time_to_live","text":"time_to_live: Optional[int] get or set the time to live of this SomeipSdClientEventGroupTimingConfig","title":"time_to_live"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientEventGroupTimingConfig.request_response_delay","text":"request_response_delay() -> Optional[RequestResponseDelay] get the request response delay of this SomeipSdClientEventGroupTimingConfig","title":"request_response_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientEventGroupTimingConfig.set_request_response_delay","text":"set_request_response_delay( request_response_delay: RequestResponseDelay, ) -> None set the request response delay of this SomeipSdClientEventGroupTimingConfig","title":"set_request_response_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientServiceInstanceConfig","text":"SomeipSdClientServiceInstanceConfig(element: Element) A SomeipSdClientServiceInstanceConfig is a configuration for a ConsumedServiceInstance This configuration is a named element that is created separately and can be used by multiple ConsumedServiceInstance s. Use [ ArPackage::create_someip_sd_client_service_instance_config ] to create a new SomeipSdClientServiceInstanceConfig .","title":"SomeipSdClientServiceInstanceConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientServiceInstanceConfig.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientServiceInstanceConfig.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientServiceInstanceConfig.priority","text":"priority: Optional[int] get or set the priority of this SomeipSdClientServiceInstanceConfig Available since R21-11 ( AUTOSAR_00050 )","title":"priority"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientServiceInstanceConfig.initial_find_behavior","text":"initial_find_behavior() -> Optional[InitialSdDelayConfig] get the initial find behavior of this SomeipSdClientServiceInstanceConfig","title":"initial_find_behavior"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdClientServiceInstanceConfig.set_initial_find_behavior","text":"set_initial_find_behavior( initial_find_behavior: InitialSdDelayConfig, ) -> None set the initial find behavior of this SomeipSdClientServiceInstanceConfig","title":"set_initial_find_behavior"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerEventGroupTimingConfig","text":"SomeipSdServerEventGroupTimingConfig(element: Element) A SomeipSdServerEventGroupTimingConfig contains the configuration for the timing of an EventHandler This configuration is a named element that is created separately and can be used by multiple EventHandler s. Use [ ArPackage::create_someip_sd_server_event_group_timing_config ] to create a new SomeipSdServerEventGroupTimingConfig .","title":"SomeipSdServerEventGroupTimingConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerEventGroupTimingConfig.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerEventGroupTimingConfig.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerEventGroupTimingConfig.request_response_delay","text":"request_response_delay() -> Optional[RequestResponseDelay] get the request response delay of this SomeipSdServerEventGroupTimingConfig","title":"request_response_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerEventGroupTimingConfig.set_request_response_delay","text":"set_request_response_delay( request_response_Delay: RequestResponseDelay, ) -> None set the request response delay of this SomeipSdServerEventGroupTimingConfig","title":"set_request_response_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerServiceInstanceConfig","text":"SomeipSdServerServiceInstanceConfig(element: Element) A SomeipSdServerServiceInstanceConfig is a configuration for a ProvidedServiceInstance This configuration is a named element that is created separately and can be used by multiple ProvidedServiceInstance s. Use [ ArPackage::create_someip_sd_server_service_instance_config ] to create a new SomeipSdServerServiceInstanceConfig .","title":"SomeipSdServerServiceInstanceConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerServiceInstanceConfig.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerServiceInstanceConfig.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerServiceInstanceConfig.offer_cyclic_delay","text":"offer_cyclic_delay: Optional[float] get or set the offer cyclic delay of this SomeipSdServerServiceInstanceConfig","title":"offer_cyclic_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerServiceInstanceConfig.priority","text":"priority: Optional[int] get or set the priority of this SomeipSdServerServiceInstanceConfig Available since R21-11 ( AUTOSAR_00050 )","title":"priority"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerServiceInstanceConfig.service_offer_time_to_live","text":"service_offer_time_to_live: Optional[int] get or set the service offer time to live of this SomeipSdServerServiceInstanceConfig","title":"service_offer_time_to_live"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerServiceInstanceConfig.initial_offer_behavior","text":"initial_offer_behavior() -> Optional[InitialSdDelayConfig] get the initial offer behavior of this SomeipSdServerServiceInstanceConfig","title":"initial_offer_behavior"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerServiceInstanceConfig.request_response_delay","text":"request_response_delay() -> Optional[RequestResponseDelay] get the request response delay of this SomeipSdServerServiceInstanceConfig","title":"request_response_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerServiceInstanceConfig.set_initial_offer_behavior","text":"set_initial_offer_behavior( initial_offer_behavior: InitialSdDelayConfig, ) -> None set the initial offer behavior of this SomeipSdServerServiceInstanceConfig","title":"set_initial_offer_behavior"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipSdServerServiceInstanceConfig.set_request_response_delay","text":"set_request_response_delay( request_response_delay: RequestResponseDelay, ) -> None set the request response delay of this SomeipSdServerServiceInstanceConfig","title":"set_request_response_delay"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpChannel","text":"SomeipTpChannel(element: Element) General settings for a SomeIp TP channel version >= AUTOSAR_00046","title":"SomeipTpChannel"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpChannel.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpChannel.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpChannel.rx_timeout_time","text":"rx_timeout_time: Optional[float] set the rxTimeoutTime for the SomeIpTpChannel","title":"rx_timeout_time"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpChannel.separation_time","text":"separation_time: Optional[float] set the separationTime for the SomeIpTpChannel","title":"separation_time"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConfig","text":"SomeipTpConfig(element: Element) A SomipTpConfig contains the configuration of individual SomeIp TP connections","title":"SomeipTpConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConfig.cluster","text":"cluster: Optional[ Union[CanCluster, FlexrayCluster, EthernetCluster] ] get the communication cluster of this SomeipTpConfig","title":"cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConfig.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConfig.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConfig.create_someip_tp_channel","text":"create_someip_tp_channel(name: str) -> SomeipTpChannel create a new SomeipTpChannel in this SomeipTpConfig version >= AUTOSAR_00046","title":"create_someip_tp_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConfig.create_someip_tp_connection","text":"create_someip_tp_connection( tp_sdu: ISignalIPdu, transport_pdu_triggering: PduTriggering, /, *, tp_channel: Optional[SomeipTpChannel] = None, ) -> SomeipTpConnection create a new SomeIp TP connection in this SomeipTpConfig","title":"create_someip_tp_connection"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConfig.someip_tp_channels","text":"someip_tp_channels() -> Iterator[SomeipTpChannel] iterate over all SomeipTpChannel s in this SomeipTpConfig","title":"someip_tp_channels"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConfig.someip_tp_connections","text":"someip_tp_connections() -> Iterator[SomeipTpConnection] get all SomeipTpConnection s in this SomeipTpConfig","title":"someip_tp_connections"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConnection","text":"SomeipTpConnection(element: Element) A SomeipTpConnection contains the configuration of a single SomeIp TP connection","title":"SomeipTpConnection"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConnection.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConnection.someip_tp_config","text":"someip_tp_config: SomeipTpConfig get the SomeipTpConfig that contains this SomeipTpConnection","title":"someip_tp_config"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConnection.tp_channel","text":"tp_channel: Optional[SomeipTpChannel] set the TpChannel of this SomeipTpConnection","title":"tp_channel"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConnection.tp_sdu","text":"tp_sdu: Optional[ISignalIPdu] set the TpSdu of this SomeipTpConnection","title":"tp_sdu"},{"location":"communication_api/#autosar_data.abstraction.communication.SomeipTpConnection.transport_pdu_triggering","text":"transport_pdu_triggering: Optional[PduTriggering] get or set the PduTriggering for the transport PDU of this SomeipTpConnection","title":"transport_pdu_triggering"},{"location":"communication_api/#autosar_data.abstraction.communication.StaticSocketConnection","text":"StaticSocketConnection(element: Element) A static socket connection is a connection between two sockets. This is the new way to establish a connection. It was introduced in Autosar 4.5.0 ( AUTOSAR_00048 ).","title":"StaticSocketConnection"},{"location":"communication_api/#autosar_data.abstraction.communication.StaticSocketConnection.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.StaticSocketConnection.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.StaticSocketConnection.remote_socket","text":"remote_socket: Optional[SocketAddress] get or set the remote socket of this connection","title":"remote_socket"},{"location":"communication_api/#autosar_data.abstraction.communication.StaticSocketConnection.socket_address","text":"socket_address: SocketAddress get the socket address containing this static socket connection","title":"socket_address"},{"location":"communication_api/#autosar_data.abstraction.communication.StaticSocketConnection.tcp_connect_timeout","text":"tcp_connect_timeout: Optional[float] get or set the TCP connect timeout of this static socket connection","title":"tcp_connect_timeout"},{"location":"communication_api/#autosar_data.abstraction.communication.StaticSocketConnection.tcp_role","text":"tcp_role: Optional[TcpRole] get or set the TCP role of this static socket connection","title":"tcp_role"},{"location":"communication_api/#autosar_data.abstraction.communication.StaticSocketConnection.add_ipdu_identifier","text":"add_ipdu_identifier( identifier: SoConIPduIdentifier, ) -> None add a SoConIPduIdentifier to this static socket connection","title":"add_ipdu_identifier"},{"location":"communication_api/#autosar_data.abstraction.communication.StaticSocketConnection.ipdu_identifiers","text":"ipdu_identifiers() -> Iterator[SoConIPduIdentifier] create an iterator over all SoConIPduIdentifiers in this static socket connection","title":"ipdu_identifiers"},{"location":"communication_api/#autosar_data.abstraction.communication.SystemSignal","text":"SystemSignal(element: Element) The system signal represents the communication system's view of data exchanged between SW components which reside on different ECUs Use [ ArPackage::create_system_signal ] to create a new system signal","title":"SystemSignal"},{"location":"communication_api/#autosar_data.abstraction.communication.SystemSignal.compu_method","text":"compu_method: Optional[CompuMethod] get or set the compu method for this signal","title":"compu_method"},{"location":"communication_api/#autosar_data.abstraction.communication.SystemSignal.data_constr","text":"data_constr: Optional[DataConstr] get or set the data constraint for this signal","title":"data_constr"},{"location":"communication_api/#autosar_data.abstraction.communication.SystemSignal.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SystemSignal.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SystemSignal.signal_group","text":"signal_group: Optional[SystemSignalGroup] get the signal group that contains this signal","title":"signal_group"},{"location":"communication_api/#autosar_data.abstraction.communication.SystemSignal.unit","text":"unit: Optional[Unit] get or set the unit for this signal","title":"unit"},{"location":"communication_api/#autosar_data.abstraction.communication.SystemSignalGroup","text":"SystemSignalGroup(element: Element) A signal group refers to a set of signals that shall always be kept together. A signal group is used to guarantee the atomic transfer of AUTOSAR composite data types. Use [ ArPackage::create_system_signal_group ] to create a new system signal group","title":"SystemSignalGroup"},{"location":"communication_api/#autosar_data.abstraction.communication.SystemSignalGroup.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.SystemSignalGroup.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.SystemSignalGroup.add_signal","text":"add_signal(signal: SystemSignal) -> None Add a signal to the signal group","title":"add_signal"},{"location":"communication_api/#autosar_data.abstraction.communication.SystemSignalGroup.signals","text":"signals() -> Iterator[ISignal] Iterate over all signals in the signal group","title":"signals"},{"location":"communication_api/#autosar_data.abstraction.communication.TcpRole","text":"The role of a TCP connection in a static socket connection can either be Connect (=client) or Listen (=server).","title":"TcpRole"},{"location":"communication_api/#autosar_data.abstraction.communication.TcpRole.Connect","text":"Connect: TcpRole","title":"Connect"},{"location":"communication_api/#autosar_data.abstraction.communication.TcpRole.Listen","text":"Listen: TcpRole","title":"Listen"},{"location":"communication_api/#autosar_data.abstraction.communication.TpAddress","text":"TpAddress(element: Element) Represents an ECUs transport layer address on the referenced channel The TpAddress element is used by FlexrayArTpConfig and FlexrayTpConfig","title":"TpAddress"},{"location":"communication_api/#autosar_data.abstraction.communication.TpAddress.address","text":"address: Optional[int] get or set the value of the address","title":"address"},{"location":"communication_api/#autosar_data.abstraction.communication.TpAddress.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.TpAddress.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.TpConfig","text":"transport protocol settings of a [ SocketAddress ]","title":"TpConfig"},{"location":"communication_api/#autosar_data.abstraction.communication.TpConfig.TcpTp","text":"TcpTp( *, port_number: Optional[int] = None, port_dynamically_assigned: Optional[bool] = None, ) -> TpConfig_TcpTp","title":"TcpTp"},{"location":"communication_api/#autosar_data.abstraction.communication.TpConfig.UdpTp","text":"UdpTp( *, port_number: Optional[int] = None, port_dynamically_assigned: Optional[bool] = None, ) -> TpConfig_UdpTp","title":"UdpTp"},{"location":"communication_api/#autosar_data.abstraction.communication.TpConfig_TcpTp","text":"Bases: TpConfig","title":"TpConfig_TcpTp"},{"location":"communication_api/#autosar_data.abstraction.communication.TpConfig_TcpTp.port_dynamically_assigned","text":"port_dynamically_assigned: Optional[bool]","title":"port_dynamically_assigned"},{"location":"communication_api/#autosar_data.abstraction.communication.TpConfig_TcpTp.port_number","text":"port_number: Optional[int]","title":"port_number"},{"location":"communication_api/#autosar_data.abstraction.communication.TpConfig_UdpTp","text":"Bases: TpConfig","title":"TpConfig_UdpTp"},{"location":"communication_api/#autosar_data.abstraction.communication.TpConfig_UdpTp.port_dynamically_assigned","text":"port_dynamically_assigned: Optional[bool]","title":"port_dynamically_assigned"},{"location":"communication_api/#autosar_data.abstraction.communication.TpConfig_UdpTp.port_number","text":"port_number: Optional[int]","title":"port_number"},{"location":"communication_api/#autosar_data.abstraction.communication.TransferProperty","text":"The TransferProperty defines if or how the signal influences the transfer of the PDU","title":"TransferProperty"},{"location":"communication_api/#autosar_data.abstraction.communication.TransferProperty.Pending","text":"Pending: TransferProperty","title":"Pending"},{"location":"communication_api/#autosar_data.abstraction.communication.TransferProperty.Triggered","text":"Triggered: TransferProperty","title":"Triggered"},{"location":"communication_api/#autosar_data.abstraction.communication.TransferProperty.TriggeredOnChange","text":"TriggeredOnChange: TransferProperty","title":"TriggeredOnChange"},{"location":"communication_api/#autosar_data.abstraction.communication.TransferProperty.TriggeredOnChangeWithoutRepetition","text":"TriggeredOnChangeWithoutRepetition: TransferProperty","title":"TriggeredOnChangeWithoutRepetition"},{"location":"communication_api/#autosar_data.abstraction.communication.TransferProperty.TriggeredWithoutRepetition","text":"TriggeredWithoutRepetition: TransferProperty","title":"TriggeredWithoutRepetition"},{"location":"communication_api/#autosar_data.abstraction.communication.TransformationTechnology","text":"TransformationTechnology(element: Element) A TransformationTechnology describes how to transform signal or PDU data","title":"TransformationTechnology"},{"location":"communication_api/#autosar_data.abstraction.communication.TransformationTechnology.data_transformation_set","text":"data_transformation_set: Optional[DataTransformationSet] get the DataTransformationSet that contains this TransformationTechnology","title":"data_transformation_set"},{"location":"communication_api/#autosar_data.abstraction.communication.TransformationTechnology.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.TransformationTechnology.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.TransformationTechnology.protocol","text":"protocol: Optional[str] Get the protocol of the TransformationTechnology . It can be set by replacing the whole config","title":"protocol"},{"location":"communication_api/#autosar_data.abstraction.communication.TransformationTechnology.transformer_class","text":"transformer_class: Optional[str] Get the transformer class of the TransformationTechnology","title":"transformer_class"},{"location":"communication_api/#autosar_data.abstraction.communication.TransformationTechnology.config","text":"config() -> Optional[TransformationTechnologyConfig] get the configuration of the TransformationTechnology","title":"config"},{"location":"communication_api/#autosar_data.abstraction.communication.TransformationTechnology.set_config","text":"set_config(config: TransformationTechnologyConfig) -> None set the configuration of the TransformationTechnology","title":"set_config"},{"location":"communication_api/#autosar_data.abstraction.communication.TransmissionModeTiming","text":"TransmissionModeTiming( *, cyclic_timing: Optional[CyclicTiming] = None, event_controlled_timing: Optional[ EventControlledTiming ] = None, ) Cyclic and event controlled timing parameters for an IPDU","title":"TransmissionModeTiming"},{"location":"communication_api/#autosar_data.abstraction.communication.TransmissionModeTiming.cyclic_timing","text":"cyclic_timing: Optional[CyclicTiming] cyclic timing parameters","title":"cyclic_timing"},{"location":"communication_api/#autosar_data.abstraction.communication.TransmissionModeTiming.event_controlled_timing","text":"event_controlled_timing: Optional[EventControlledTiming] event controlled timing parameters","title":"event_controlled_timing"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster","text":"UdpNmCluster(element: Element) Udp / Ethernet specific NmCluster","title":"UdpNmCluster"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.channel_sleep_master","text":"channel_sleep_master: Optional[bool] get or set the nmChannelSleepMaster flag","title":"channel_sleep_master"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.communication_cluster","text":"communication_cluster: Optional[EthernetCluster] set the referenced EthernetCluster","title":"communication_cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.nm_cbv_position","text":"nm_cbv_position: Optional[int] get or set the value nmCbvPosition","title":"nm_cbv_position"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.nm_immediate_nm_transmissions","text":"nm_immediate_nm_transmissions: Optional[int] get or set the value nmImmediateNmTransmissions","title":"nm_immediate_nm_transmissions"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.nm_message_timeout_time","text":"nm_message_timeout_time: Optional[float] get or set the nmMessageTimeoutTime","title":"nm_message_timeout_time"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.nm_msg_cycle_time","text":"nm_msg_cycle_time: Optional[float] get or set the nmMsgCycleTime","title":"nm_msg_cycle_time"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.nm_network_timeout","text":"nm_network_timeout: Optional[float] get or set the NmNetworkTimeout","title":"nm_network_timeout"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.nm_nid_position","text":"nm_nid_position: Optional[int] get or set the value nmNidPosition","title":"nm_nid_position"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.nm_remote_sleep_indication_time","text":"nm_remote_sleep_indication_time: Optional[float] get or set the NmRemoteSleepIndicationTime","title":"nm_remote_sleep_indication_time"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.nm_repeat_message_time","text":"nm_repeat_message_time: Optional[float] get or set the NmRepeatMessageTime","title":"nm_repeat_message_time"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.nm_wait_bus_sleep_time","text":"nm_wait_bus_sleep_time: Optional[float] get or set the NmWaitBusSleepTime","title":"nm_wait_bus_sleep_time"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.node_detection_enabled","text":"node_detection_enabled: Optional[bool] get or set the nmNodeDetectionEnabled flag","title":"node_detection_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.node_id_enabled","text":"node_id_enabled: Optional[bool] get or set the nmNodeIdEnabled flag","title":"node_id_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.pnc_cluster_vector_length","text":"pnc_cluster_vector_length: Optional[int] get or set the pncClusterVectorLength","title":"pnc_cluster_vector_length"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.pnc_participation","text":"pnc_participation: Optional[bool] get or set the nmPncParticipation flag","title":"pnc_participation"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.repeat_msg_ind_enabled","text":"repeat_msg_ind_enabled: Optional[bool] get or set the nmRepeatMsgIndEnabled flag","title":"repeat_msg_ind_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.synchronizing_network","text":"synchronizing_network: Optional[bool] get or set the nmSynchronizingNetwork flag","title":"synchronizing_network"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.vlan","text":"vlan: Optional[EthernetPhysicalChannel] get or set the Vlan associated with the cluster through an EthernetPhysicalChannel reference.","title":"vlan"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.create_udp_nm_node","text":"create_udp_nm_node( name: str, controller: EthernetCommunicationController, nm_ecu: NmEcu, nm_msg_cycle_offset: float, ) -> UdpNmNode add a UdpNmNode to the cluster","title":"create_udp_nm_node"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmCluster.nm_nodes","text":"nm_nodes() -> Iterator[UdpNmNode] iterate over all NmNodes in this cluster","title":"nm_nodes"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmClusterCoupling","text":"UdpNmClusterCoupling(element: Element) Udp / Ethernet specific NmClusterCoupling It couples multiple UdpNmCluster s and provides UdpNm-specific settings","title":"UdpNmClusterCoupling"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmClusterCoupling.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmClusterCoupling.nm_immediate_restart_enabled","text":"nm_immediate_restart_enabled: Optional[bool] set or remove the nmImmediateRestartEnabled flag","title":"nm_immediate_restart_enabled"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmClusterCoupling.add_coupled_cluster","text":"add_coupled_cluster(cluster: UdpNmCluster) -> None add a reference to a coupled NmCluster","title":"add_coupled_cluster"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmClusterCoupling.coupled_clusters","text":"coupled_clusters() -> Iterator[UdpNmCluster] iterate over all coupled NmClusters","title":"coupled_clusters"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmClusterSettings","text":"UdpNmClusterSettings( *, nm_msg_cycle_time: float, nm_msg_timeout_time: float, nm_network_timeout: float, nm_remote_sleep_indication_time: float, nm_repeat_message_time: float, nm_wait_bus_sleep_time: float, ) UdpNmClusterSettings encapsulates the mandatory settings for a UdpNmCluster","title":"UdpNmClusterSettings"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmClusterSettings.nm_msg_cycle_time","text":"nm_msg_cycle_time: float Period of an NmPdu in seconds","title":"nm_msg_cycle_time"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmClusterSettings.nm_msg_timeout_time","text":"nm_msg_timeout_time: float Timeout of a NmPdu in seconds","title":"nm_msg_timeout_time"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmClusterSettings.nm_network_timeout","text":"nm_network_timeout: float Network Timeout for NmPdus in seconds","title":"nm_network_timeout"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmClusterSettings.nm_remote_sleep_indication_time","text":"nm_remote_sleep_indication_time: float Timeout for Remote Sleep Indication in seconds","title":"nm_remote_sleep_indication_time"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmClusterSettings.nm_repeat_message_time","text":"nm_repeat_message_time: float Timeout for Repeat Message State in seconds","title":"nm_repeat_message_time"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmClusterSettings.nm_wait_bus_sleep_time","text":"nm_wait_bus_sleep_time: float Timeout for bus calm down phase in seconds","title":"nm_wait_bus_sleep_time"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode","text":"UdpNmNode(element: Element) Udp / Ethernet specific NmNode","title":"UdpNmNode"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode.all_nm_messages_keep_awake","text":"all_nm_messages_keep_awake: Optional[bool] set ot remove the allNmMessagesKeepAwake flag If enabled is Some , the flag is set to the value of enabled . If enabled is None , the flag is removed.","title":"all_nm_messages_keep_awake"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode.communication_controller","text":"communication_controller: Optional[ EthernetCommunicationController ] get or set the referenced EthernetCommunicationController","title":"communication_controller"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode.element","text":"element: Element","title":"element"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode.name","text":"name: str","title":"name"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode.nm_ecu","text":"nm_ecu: Optional[NmEcu] get or set the referenced NmEcu","title":"nm_ecu"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode.nm_msg_cycle_offset","text":"nm_msg_cycle_offset: Optional[float] get or set the NmMsgCycleOffset","title":"nm_msg_cycle_offset"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode.node_id","text":"node_id: Optional[int] set the nmNodeId","title":"node_id"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode.passive_mode","text":"passive_mode: Optional[bool] set ot remove the nmPassiveModeEnabled flag","title":"passive_mode"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode.add_rx_nm_pdu","text":"add_rx_nm_pdu(nm_pdu: NmPdu) -> None add an Rx NmPdu Every NmNode must have at least one Rx NmPdu","title":"add_rx_nm_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode.add_tx_nm_pdu","text":"add_tx_nm_pdu(nm_pdu: NmPdu) -> None add a Tx NmPdu Active NmNodes must have at least one Tx NmPdu , while passive NmNodes may have none.","title":"add_tx_nm_pdu"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode.rx_nm_pdus","text":"rx_nm_pdus() -> Iterator[NmPdu] iterate over all RX NmPdus","title":"rx_nm_pdus"},{"location":"communication_api/#autosar_data.abstraction.communication.UdpNmNode.tx_nm_pdus","text":"tx_nm_pdus() -> Iterator[NmPdu] iterate over all TX NmPdus","title":"tx_nm_pdus"},{"location":"datatype_api/","text":"API Documentation: autosar_data.abstraction.datatype \u00b6 datatype \u00b6 ApplicationDataType module-attribute \u00b6 ApplicationDataType: TypeAlias = Union[ ApplicationPrimitiveDataType, ApplicationArrayDataType, ApplicationRecordDataType, ] AutosarDataType module-attribute \u00b6 AutosarDataType: TypeAlias = Union[ ApplicationDataType, ImplementationDataType ] CompositeRuleBasedValueArgument module-attribute \u00b6 CompositeRuleBasedValueArgument: TypeAlias = Union[ ApplicationValueSpecification, ApplicationRuleBasedValueSpecification, ] CompositeValueSpecification module-attribute \u00b6 CompositeValueSpecification: TypeAlias = Union[ ArrayValueSpecification, RecordValueSpecification ] DataPointerTarget module-attribute \u00b6 DataPointerTarget: TypeAlias = Union[ ImplementationDataType, SwBaseType ] DataPrototype module-attribute \u00b6 DataPrototype: TypeAlias = Union[ ArgumentDataPrototype, ParameterDataPrototype, VariableDataPrototype, ApplicationArrayElement, ApplicationRecordElement, ] ValueSpecification module-attribute \u00b6 ValueSpecification: TypeAlias = Union[ ArrayValueSpecification, RecordValueSpecification, TextValueSpecification, NumericalValueSpecification, ConstantReference, ApplicationValueSpecification, NotAvailableValueSpecification, ReferenceValueSpecification, ApplicationRuleBasedValueSpecification, CompositeRuleBasedValueSpecification, NumericalRuleBasedValueSpecification, List[ValueSpecification], Tuple[ValueSpecification, ...], str, float, ] ApplicationArrayDataType \u00b6 ApplicationArrayDataType(element: Element) An application array data type Use ArPackage.create_application_array_data_type to create a new application array data type. array_element instance-attribute \u00b6 array_element: ApplicationArrayElement array element of the array data type element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str set_size \u00b6 set_size(size: ApplicationArraySize) -> None set the size specification of the array size \u00b6 size() -> ApplicationArraySize get the size specification of the array: Variable, Fixed, etc. ApplicationArrayElement \u00b6 ApplicationArrayElement(element: Element) An element in an application array data type data_type instance-attribute \u00b6 data_type: ApplicationDataType data type of the array element element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str ApplicationArraySize \u00b6 definition of the size type of an application array data type Fixed instance-attribute \u00b6 Fixed: Type[ApplicationArraySize_Fixed] VariableFullyFlexible instance-attribute \u00b6 VariableFullyFlexible: Type[ ApplicationArraySize_VariableFullyFlexible ] VariableLinear instance-attribute \u00b6 VariableLinear: Type[ApplicationArraySize_VariableLinear] VariableRectangular instance-attribute \u00b6 VariableRectangular: Type[ ApplicationArraySize_VariableRectangular ] VariableSquare instance-attribute \u00b6 VariableSquare: Type[ApplicationArraySize_VariableSquare] ApplicationArraySize_Fixed \u00b6 ApplicationArraySize_Fixed(length: int) Bases: ApplicationArraySize length instance-attribute \u00b6 length: int ApplicationArraySize_VariableFullyFlexible \u00b6 ApplicationArraySize_VariableFullyFlexible(max_size: int) Bases: ApplicationArraySize max_size instance-attribute \u00b6 max_size: int ApplicationArraySize_VariableLinear \u00b6 ApplicationArraySize_VariableLinear(max_size: int) Bases: ApplicationArraySize max_size instance-attribute \u00b6 max_size: int ApplicationArraySize_VariableRectangular \u00b6 ApplicationArraySize_VariableRectangular(max_size: int) Bases: ApplicationArraySize max_size instance-attribute \u00b6 max_size: int ApplicationArraySize_VariableSquare \u00b6 ApplicationArraySize_VariableSquare() Bases: ApplicationArraySize ApplicationPrimitiveCategory \u00b6 The category of an application primitive data type Boolean instance-attribute \u00b6 Boolean: ApplicationPrimitiveCategory ComAxis instance-attribute \u00b6 ComAxis: ApplicationPrimitiveCategory Cube4 instance-attribute \u00b6 Cube4: ApplicationPrimitiveCategory Cube5 instance-attribute \u00b6 Cube5: ApplicationPrimitiveCategory Cuboid instance-attribute \u00b6 Cuboid: ApplicationPrimitiveCategory Curve instance-attribute \u00b6 Curve: ApplicationPrimitiveCategory Map instance-attribute \u00b6 Map: ApplicationPrimitiveCategory ResAxis instance-attribute \u00b6 ResAxis: ApplicationPrimitiveCategory String instance-attribute \u00b6 String: ApplicationPrimitiveCategory ValBlk instance-attribute \u00b6 ValBlk: ApplicationPrimitiveCategory Value instance-attribute \u00b6 Value: ApplicationPrimitiveCategory ApplicationPrimitiveDataType \u00b6 ApplicationPrimitiveDataType(element: Element) An application primitive data type Use [ ArPackage::create_application_primitive_data_type ] to create a new application primitive data type. category instance-attribute \u00b6 category: ApplicationPrimitiveCategory category of the primitive data type compu_method instance-attribute \u00b6 compu_method: CompuMethod set the compu method of the primitive data type data_constraint instance-attribute \u00b6 data_constraint: DataConstr data constraint of the primitive data type element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str unit instance-attribute \u00b6 unit: Unit unit of the primitive data type ApplicationRecordDataType \u00b6 ApplicationRecordDataType(element: Element) An application record data type Use [ ArPackage::create_application_record_data_type ] to create a new application record data type. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_record_element \u00b6 create_record_element( name: str, data_type: ApplicationDataType ) -> ApplicationRecordElement create a new element in the record data type record_elements \u00b6 record_elements() -> Iterator[ApplicationRecordElement] get an iterator over the record elements of the record data type ApplicationRecordElement \u00b6 ApplicationRecordElement(element: Element) An element in an application record data type data_type instance-attribute \u00b6 data_type: ApplicationDataType data type of the record element element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str ApplicationRuleBasedValueSpecification \u00b6 ApplicationRuleBasedValueSpecification( category: ApplicationPrimitiveCategory, sw_axis_cont: List[RuleBasedAxisCont], sw_value_cont: RuleBasedValueCont, /, *, label: Optional[str] = None, ) An application rule based value specification category instance-attribute \u00b6 category: ApplicationPrimitiveCategory category of the application rule based value specification label instance-attribute \u00b6 label: Optional[str] label of the application rule based value specification, if any sw_axis_cont instance-attribute \u00b6 sw_axis_cont: List[RuleBasedAxisCont] list of RuleBasedAxisCont objects in the application rule based value specification sw_value_cont instance-attribute \u00b6 sw_value_cont: RuleBasedValueCont RuleBasedValueCont of the application rule based value specification ApplicationValueSpecification \u00b6 ApplicationValueSpecification( category: ApplicationPrimitiveCategory, sw_axis_conts: List[SwAxisCont], sw_value_cont: SwValueCont, *, label: Optional[str] = None, ) An application value specification category instance-attribute \u00b6 category: ApplicationPrimitiveCategory category of the application value specification label instance-attribute \u00b6 label: Optional[str] label of the application value specification, if any sw_axis_conts instance-attribute \u00b6 sw_axis_conts: List[SwAxisCont] list of SwAxisCont objects in the application value specification sw_value_cont instance-attribute \u00b6 sw_value_cont: SwValueCont SwValueCont of the application value specification ArrayValueSpecification \u00b6 ArrayValueSpecification( values: List[ValueSpecification], /, *, label: Optional[str] = None, ) An array value specification label instance-attribute \u00b6 label: Optional[str] label of the array value specification, if any values instance-attribute \u00b6 values: List[ValueSpecification] list of values in the array BaseTypeEncoding \u00b6 BaseTypeEncoding describes the encoding of a basic data type. BcdPacked instance-attribute \u00b6 BcdPacked: BaseTypeEncoding BcdUnpacked instance-attribute \u00b6 BcdUnpacked: BaseTypeEncoding Boolean instance-attribute \u00b6 Boolean: BaseTypeEncoding DspFractional instance-attribute \u00b6 DspFractional: BaseTypeEncoding Ieee754 instance-attribute \u00b6 Ieee754: BaseTypeEncoding Iso8859_1 instance-attribute \u00b6 Iso8859_1: BaseTypeEncoding Iso8859_2 instance-attribute \u00b6 Iso8859_2: BaseTypeEncoding NoEncoding instance-attribute \u00b6 NoEncoding: BaseTypeEncoding OnesComplement instance-attribute \u00b6 OnesComplement: BaseTypeEncoding SignMagnitude instance-attribute \u00b6 SignMagnitude: BaseTypeEncoding TwosComplement instance-attribute \u00b6 TwosComplement: BaseTypeEncoding Ucs2 instance-attribute \u00b6 Ucs2: BaseTypeEncoding Utf16 instance-attribute \u00b6 Utf16: BaseTypeEncoding Utf8 instance-attribute \u00b6 Utf8: BaseTypeEncoding Void instance-attribute \u00b6 Void: BaseTypeEncoding Windows1252 instance-attribute \u00b6 Windows1252: BaseTypeEncoding BitfieldEntry \u00b6 BitfieldEntry(*, text: str, value: float, mask: int) A single entry of a bitfield text table conversion mask instance-attribute \u00b6 mask: int bit mask of this entry text instance-attribute \u00b6 text: str text of this entry value instance-attribute \u00b6 value: float numeric value of this entry CompositeRuleBasedValueSpecification \u00b6 CompositeRuleBasedValueSpecification( argument: List[CompositeValueSpecification], compound_primitive_argument: List[ CompositeRuleBasedValueArgument ], max_size_to_fill: Optional[int], rule: RuleBasedFillUntil, /, *, label: Optional[str] = None, ) A composite rule based value specification argument instance-attribute \u00b6 argument: List[CompositeValueSpecification] list of CompositeValueSpecification objects in the composite rule based value specification compound_primitive_argument instance-attribute \u00b6 compound_primitive_argument: List[ CompositeRuleBasedValueArgument ] list of CompositeRuleBasedValueArgument objects in the composite rule based value specification label instance-attribute \u00b6 label: Optional[str] label of the composite rule based value specification, if any max_size_to_fill instance-attribute \u00b6 max_size_to_fill: Optional[int] maximum size to fill in the composite rule based value specification rule instance-attribute \u00b6 rule: RuleBasedFillUntil rule for filling the composite rule based value specification CompuMethod \u00b6 CompuMethod(element: Element) A CompuMethod describes the conversion between physical and internal values Use [ ArPackage::create_compu_method ] to create a new CompuMethod category instance-attribute \u00b6 category: CompuMethodCategory category of the CompuMethod element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str content \u00b6 content() -> Optional[CompuMethodContent] get the CompuMethodContent of the CompuMethod create_compu_scale \u00b6 create_compu_scale( direction: CompuScaleDirection, /, *, lower_limit: Optional[float] = None, upper_limit: Optional[float] = None, ) -> CompuScale create a CompuScale in the CompuMethod int_to_phys_compu_scales \u00b6 int_to_phys_compu_scales() -> Iterator[CompuScale] Create an iterator over the internal-to-physical CompuScales phys_to_int_compu_scales \u00b6 phys_to_int_compu_scales() -> Iterator[CompuScale] Create an iterator over the physical-to-internal CompuScales set_content \u00b6 set_content(content: CompuMethodContent) -> None set the content of the CompuMethod Writing to this attribute removes any existing content CompuMethodBitfieldTextTableContent \u00b6 A single entry of a bitfield text table conversion mask instance-attribute \u00b6 mask: int bit mask of this entry text instance-attribute \u00b6 text: str text of this entry value instance-attribute \u00b6 value: float numeric value of this entry CompuMethodCategory \u00b6 Category of a CompuMethod BitfieldTextTable instance-attribute \u00b6 BitfieldTextTable: CompuMethodCategory Identical instance-attribute \u00b6 Identical: CompuMethodCategory Linear instance-attribute \u00b6 Linear: CompuMethodCategory Rational instance-attribute \u00b6 Rational: CompuMethodCategory ScaleLinear instance-attribute \u00b6 ScaleLinear: CompuMethodCategory ScaleLinearAndTextTable instance-attribute \u00b6 ScaleLinearAndTextTable: CompuMethodCategory ScaleRational instance-attribute \u00b6 ScaleRational: CompuMethodCategory ScaleRationalAndTextTable instance-attribute \u00b6 ScaleRationalAndTextTable: CompuMethodCategory TabNoInterpretation instance-attribute \u00b6 TabNoInterpretation: CompuMethodCategory TextTable instance-attribute \u00b6 TextTable: CompuMethodCategory CompuMethodContent \u00b6 Content of a CompuMethod BitfieldTextTable instance-attribute \u00b6 BitfieldTextTable: Type[ CompuMethodContent_BitfieldTextTable ] Identical instance-attribute \u00b6 Identical: Type[CompuMethodContent_Identical] Linear instance-attribute \u00b6 Linear: Type[CompuMethodContent_Linear] Rational instance-attribute \u00b6 Rational: Type[CompuMethodContent_Rational] ScaleLinear instance-attribute \u00b6 ScaleLinear: Type[CompuMethodContent_ScaleLinear] ScaleLinearAndTextTable instance-attribute \u00b6 ScaleLinearAndTextTable: Type[ CompuMethodContent_ScaleLinearAndTextTable ] ScaleRational instance-attribute \u00b6 ScaleRational: Type[CompuMethodContent_ScaleRational] ScaleRationalAndTextTable instance-attribute \u00b6 ScaleRationalAndTextTable: Type[ CompuMethodContent_ScaleRationalAndTextTable ] TabNoInterpretation instance-attribute \u00b6 TabNoInterpretation: Type[ CompuMethodContent_TabNoInterpretation ] TextTable instance-attribute \u00b6 TextTable: Type[CompuMethodContent_TextTable] CompuMethodContent_BitfieldTextTable \u00b6 CompuMethodContent_BitfieldTextTable( entries: List[BitfieldEntry], ) Bases: CompuMethodContent entries instance-attribute \u00b6 entries: List[BitfieldEntry] CompuMethodContent_Identical \u00b6 CompuMethodContent_Identical() Bases: CompuMethodContent CompuMethodContent_Linear \u00b6 CompuMethodContent_Linear( *, direction: CompuScaleDirection, divisor: float, factor: float, offset: float, lower_limit: Optional[float] = None, upper_limit: Optional[float] = None, ) Bases: CompuMethodContent direction instance-attribute \u00b6 direction: CompuScaleDirection divisor instance-attribute \u00b6 divisor: float factor instance-attribute \u00b6 factor: float lower_limit instance-attribute \u00b6 lower_limit: Optional[float] offset instance-attribute \u00b6 offset: float upper_limit instance-attribute \u00b6 upper_limit: Optional[float] CompuMethodContent_Rational \u00b6 CompuMethodContent_Rational( *, direction: CompuScaleDirection, denominator: List[float], numerator: List[float], lower_limit: float, upper_limit: float, ) Bases: CompuMethodContent denominator instance-attribute \u00b6 denominator: List[float] direction instance-attribute \u00b6 direction: CompuScaleDirection lower_limit instance-attribute \u00b6 lower_limit: float numerator instance-attribute \u00b6 numerator: List[float] upper_limit instance-attribute \u00b6 upper_limit: float CompuMethodContent_ScaleLinear \u00b6 CompuMethodContent_ScaleLinear( *, scales: List[LinearConversionParameters] ) Bases: CompuMethodContent scales instance-attribute \u00b6 scales: List[LinearConversionParameters] CompuMethodContent_ScaleLinearAndTextTable \u00b6 CompuMethodContent_ScaleLinearAndTextTable( *, scales: List[LinearConversionParameters], texts: List[TextTableEntry], ) Bases: CompuMethodContent scales instance-attribute \u00b6 scales: List[LinearConversionParameters] texts instance-attribute \u00b6 texts: List[TextTableEntry] CompuMethodContent_ScaleRational \u00b6 CompuMethodContent_ScaleRational( *, scales: List[RationalConversionParameters] ) Bases: CompuMethodContent scales instance-attribute \u00b6 scales: List[RationalConversionParameters] CompuMethodContent_ScaleRationalAndTextTable \u00b6 CompuMethodContent_ScaleRationalAndTextTable( *, scales: List[RationalConversionParameters], texts: List[TextTableEntry], ) Bases: CompuMethodContent scales instance-attribute \u00b6 scales: List[RationalConversionParameters] texts instance-attribute \u00b6 texts: List[TextTableEntry] CompuMethodContent_TabNoInterpretation \u00b6 CompuMethodContent_TabNoInterpretation( *, entries: List[TabNoIntpEntry] ) Bases: CompuMethodContent entries instance-attribute \u00b6 entries: List[TabNoIntpEntry] CompuMethodContent_TextTable \u00b6 CompuMethodContent_TextTable( *, texts: List[TextTableEntry] ) Bases: CompuMethodContent texts instance-attribute \u00b6 texts: List[TextTableEntry] CompuMethodIdenticalContent \u00b6 Description of the content of a CompuMethod whose category is Identical . This class is empty, as there are no additional attributes for the identical conversion. CompuScale \u00b6 CompuScale(element: Element) A CompuScale describes the conversion between physical and internal values, as well as the limits of the scale content instance-attribute \u00b6 content: Union[CompuScaleRationalCoefficients, str, int] content of the CompuScale element instance-attribute \u00b6 element: Element lower_limit instance-attribute \u00b6 lower_limit: Optional[float] lower limit of the CompuScale mask instance-attribute \u00b6 mask: Optional[int] mask of the CompuScale , applicable for BitfieldTextTable upper_limit instance-attribute \u00b6 upper_limit: Optional[float] upper limit of the CompuScale CompuScaleDirection \u00b6 Direction of a CompuScale IntToPhys instance-attribute \u00b6 IntToPhys: CompuScaleDirection PhysToInt instance-attribute \u00b6 PhysToInt: CompuScaleDirection CompuScaleRationalCoefficients \u00b6 CompuScaleRationalCoefficients( *, numerator: List[float], denominator: List[float] ) Rational coefficients of a CompuScale denominator instance-attribute \u00b6 denominator: List[float] list of denominator coefficients numerator instance-attribute \u00b6 numerator: List[float] list of numerator coefficients ConstantReference \u00b6 ConstantReference( constant: ConstantSpecification, /, *, label: Optional[str] = None, ) A ConstantReference is a reference to a ConstantSpecification which can be used in a ValueSpecification. constant instance-attribute \u00b6 constant: ConstantSpecification the constant specification that is referenced label instance-attribute \u00b6 label: Optional[str] label of the ConstantReference , if any ConstantSpecification \u00b6 ConstantSpecification(element: Element) A ConstantSpecification is a specification of a constant value. Use [ ArPackage::create_constant_specification ] to create a new ConstantSpecification . element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str value_specification instance-attribute \u00b6 value_specification: ValueSpecification DataConstr \u00b6 DataConstr(element: Element) DataConstr represents a data constraint. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_data_constr_rule \u00b6 create_data_constr_rule( rule_type: DataConstrType, /, *, lower_limit: Optional[float] = None, upper_limit: Optional[float] = None, ) -> DataConstrRule Create a data constraint rule data_constr_rules \u00b6 data_constr_rules() -> Iterator[DataConstrRule] Get all data constraint rules DataConstrRule \u00b6 DataConstrRule(element: Element) DataConstrRule represents a data constraint rule. element instance-attribute \u00b6 element: Element lower_limit instance-attribute \u00b6 lower_limit: Optional[float] get the lower limit rule_type instance-attribute \u00b6 rule_type: DataConstrType get the constraint type upper_limit instance-attribute \u00b6 upper_limit: Optional[float] get the upper limit DataConstrType \u00b6 The type of a data constraint rule Internal instance-attribute \u00b6 Internal: DataConstrType Physical instance-attribute \u00b6 Physical: DataConstrType DataTypeMap \u00b6 DataTypeMap(element: Element) A DataTypeMap maps an ImplementationDataType to an ApplicationDataType application_data_type instance-attribute \u00b6 application_data_type: ApplicationDataType Get the ApplicationDataType of the DataTypeMap element instance-attribute \u00b6 element: Element implementation_data_type instance-attribute \u00b6 implementation_data_type: ImplementationDataType Get the ImplementationDataType of the DataTypeMap DataTypeMappingSet \u00b6 DataTypeMappingSet(element: Element) A [ DataTypeMappingSet ] contains DataTypeMap s Use [ ArPackage::create_data_type_mapping_set ] to create a new DataTypeMappingSet element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_data_type_map \u00b6 create_data_type_map( implementation_data_type: ImplementationDataType, application_data_type: ApplicationDataType, ) -> DataTypeMap Create a new DataTypeMap in the DataTypeMappingSet data_type_maps \u00b6 data_type_maps() -> Iterator[DataTypeMap] Get an iterator over the DataTypeMap s in the DataTypeMappingSet ImplementationDataCategory \u00b6 The category of an implementation data type Array instance-attribute \u00b6 Array: ImplementationDataCategory DataReference instance-attribute \u00b6 DataReference: ImplementationDataCategory FunctionReference instance-attribute \u00b6 FunctionReference: ImplementationDataCategory Structure instance-attribute \u00b6 Structure: ImplementationDataCategory TypeReference instance-attribute \u00b6 TypeReference: ImplementationDataCategory Union instance-attribute \u00b6 Union: ImplementationDataCategory Value instance-attribute \u00b6 Value: ImplementationDataCategory ImplementationDataType \u00b6 ImplementationDataType(element: Element) An implementation data type; specifics are determined by the category Use [ ArPackage::create_implementation_data_type ] to create a new implementation data type array_size instance-attribute \u00b6 array_size: Optional[int] array size of this implementation data type [category: ARRAY] base_type instance-attribute \u00b6 base_type: Optional[SwBaseType] SwBaseType of this implementation data type [category: VALUE] category instance-attribute \u00b6 category: Optional[ImplementationDataCategory] category of this implementation data type compu_method instance-attribute \u00b6 compu_method: Optional[CompuMethod] CompuMethod of this implementation data type [category: VALUE, TYPE_REFERENCE ] data_constraint instance-attribute \u00b6 data_constraint: Optional[DataConstr] DataConstr of this implementation data type [category: VALUE, TYPE_REFERENCE ] data_pointer_target instance-attribute \u00b6 data_pointer_target: Optional[DataPointerTarget] get the target type of the data pointer [category: DATA_REFERENCE] element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str referenced_type instance-attribute \u00b6 referenced_type: Optional[ImplementationDataType] get the referenced implementation data type [category: TYPE_REFERENCE ] apply_settings \u00b6 apply_settings( settings: ImplementationDataTypeSettings, ) -> None apply the settings to this implementation data type Calling this method completely replaces the existing settings of the implementation data type, deleting existing sub-elements and creating new ones according to the settings settings \u00b6 settings() -> Optional[ImplementationDataTypeSettings] get the settings of this implementation data type sub_elements \u00b6 sub_elements() -> Iterator[ImplementationDataTypeElement] create an iterator over the sub-elements of this implementation data type ImplementationDataTypeElement \u00b6 ImplementationDataTypeElement(element: Element) An element of an implementation data type array_size instance-attribute \u00b6 array_size: Optional[int] array size of this implementation data type [category: ARRAY] base_type instance-attribute \u00b6 base_type: Optional[SwBaseType] SwBaseType of this implementation data type [category: VALUE] category instance-attribute \u00b6 category: Optional[ImplementationDataCategory] category of this implementation data type compu_method instance-attribute \u00b6 compu_method: Optional[CompuMethod] CompuMethod of this implementation data type [category: VALUE, TYPE_REFERENCE ] data_constraint instance-attribute \u00b6 data_constraint: Optional[DataConstr] DataConstr of this implementation data type [category: VALUE, TYPE_REFERENCE ] data_pointer_target instance-attribute \u00b6 data_pointer_target: Optional[DataPointerTarget] get the target type of the data pointer [category: DATA_REFERENCE] element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str referenced_type instance-attribute \u00b6 referenced_type: Optional[ImplementationDataType] get the referenced implementation data type [category: TYPE_REFERENCE ] apply_settings \u00b6 apply_settings( settings: ImplementationDataTypeSettings, ) -> None apply the settings to this implementation data type Calling this method completely replaces the existing settings of the implementation data type, deleting existing sub-elements and creating new ones according to the settings settings \u00b6 settings() -> ImplementationDataTypeSettings get the settings of this implementation data type sub_elements \u00b6 sub_elements() -> Iterator[ImplementationDataTypeElement] create an iterator over the sub-elements of this implementation data type ImplementationDataTypeSettings \u00b6 Settings for an implementation data type This structure is used to create new implementation data types Array staticmethod \u00b6 Array( name: str, *, length: int, element_type: ImplementationDataTypeSettings, ) -> ImplementationDataTypeSettings DataReference staticmethod \u00b6 DataReference( name: str, *, target: DataPointerTarget ) -> ImplementationDataTypeSettings FunctionReference staticmethod \u00b6 FunctionReference( name: str, ) -> ImplementationDataTypeSettings Structure staticmethod \u00b6 Structure( name: str, *, elements: List[ImplementationDataTypeSettings], ) -> ImplementationDataTypeSettings TypeReference staticmethod \u00b6 TypeReference( name: str, *, reftype: ImplementationDataType, compu_method: Optional[CompuMethod] = None, data_constraint: Optional[DataConstr] = None, ) -> ImplementationDataTypeSettings Union staticmethod \u00b6 Union( name: str, *, elements: List[ImplementationDataTypeSettings], ) -> ImplementationDataTypeSettings Value staticmethod \u00b6 Value( name: str, *, base_type: SwBaseType, compu_method: Optional[CompuMethod] = None, data_constraint: Optional[DataConstr] = None, ) -> ImplementationDataTypeSettings ImplementationDataTypeSettings_Array \u00b6 Bases: ImplementationDataTypeSettings element_type instance-attribute \u00b6 element_type: ImplementationDataType length instance-attribute \u00b6 length: int name instance-attribute \u00b6 name: str ImplementationDataTypeSettings_DataReference \u00b6 Bases: ImplementationDataTypeSettings data_pointer_target instance-attribute \u00b6 data_pointer_target: DataPointerTarget get the target type of the data pointer name instance-attribute \u00b6 name: str ImplementationDataTypeSettings_FunctionReference \u00b6 Bases: ImplementationDataTypeSettings name instance-attribute \u00b6 name: str ImplementationDataTypeSettings_Structure \u00b6 Bases: ImplementationDataTypeSettings elements instance-attribute \u00b6 elements: List[ImplementationDataTypeElement] name instance-attribute \u00b6 name: str ImplementationDataTypeSettings_TypeReference \u00b6 Bases: ImplementationDataTypeSettings compu_method instance-attribute \u00b6 compu_method: CompuMethod data_constraint instance-attribute \u00b6 data_constraint: DataConstr name instance-attribute \u00b6 name: str reftype instance-attribute \u00b6 reftype: ImplementationDataType ImplementationDataTypeSettings_Union \u00b6 Bases: ImplementationDataTypeSettings elements instance-attribute \u00b6 elements: List[ImplementationDataTypeElement] name instance-attribute \u00b6 name: str ImplementationDataTypeSettings_Value \u00b6 Bases: ImplementationDataTypeSettings base_type instance-attribute \u00b6 base_type: SwBaseType compu_method instance-attribute \u00b6 compu_method: CompuMethod data_constraint instance-attribute \u00b6 data_constraint: DataConstr name instance-attribute \u00b6 name: str LinearConversionParameters \u00b6 LinearConversionParameters( *, direction: CompuScaleDirection, offset: float, factor: float, divisor: float, lower_limit: float, upper_limit: float, ) Linear conversion parameters for CompuMethodScaleLinearContent and CompuMethodScaleLinearAndTextTable direction instance-attribute \u00b6 direction: CompuScaleDirection direction of the conversion divisor instance-attribute \u00b6 divisor: float divisor factor instance-attribute \u00b6 factor: float factor lower_limit instance-attribute \u00b6 lower_limit: float lower limit of the scale offset instance-attribute \u00b6 offset: float offset upper_limit instance-attribute \u00b6 upper_limit: float upper limit of the scale NotAvailableValueSpecification \u00b6 NotAvailableValueSpecification( *, default_pattern: Optional[int] = None, label: Optional[str] = None, ) A value specification that is not available. It is used for ApplicationRecordElements where the attribute isOptional ist set to the value True. default_pattern instance-attribute \u00b6 default_pattern: Optional[int] default pattern to fill unused memory, if any label instance-attribute \u00b6 label: Optional[str] label of the NotAvailableValueSpecification , if any NumericalRuleBasedValueSpecification \u00b6 NumericalRuleBasedValueSpecification( rule_based_values: RuleBasedValueSpecification, /, *, label: Optional[str] = None, ) A numerical rule based value specification This is a value specification that contains a rule based value specification for numerical values. label instance-attribute \u00b6 label: Optional[str] label of the numerical rule based value specification, if any rule_based_values instance-attribute \u00b6 rule_based_values: RuleBasedValueSpecification the rule based value specification that contains the numerical values NumericalValueSpecification \u00b6 NumericalValueSpecification( value: float, /, *, label: Optional[str] = None ) A numerical value specification This is a simple value specification that contains a single float value. label instance-attribute \u00b6 label: Optional[str] label of the numerical value specification, if any value instance-attribute \u00b6 value: float the numerical value RationalConversionParameters \u00b6 RationalConversionParameters( *, direction: CompuScaleDirection, denominator: List[float], numerator: List[float], lower_limit: float, upper_limit: float, ) Description of the content of a CompuMethod whose category is Rational Initialize self. See help(type(self)) for accurate signature. denominator instance-attribute \u00b6 denominator: List[float] list of numerator coefficients direction instance-attribute \u00b6 direction: CompuScaleDirection direction of the conversion lower_limit instance-attribute \u00b6 lower_limit: float lower limit of the scale numerator instance-attribute \u00b6 numerator: List[float] list of denominator coefficients upper_limit instance-attribute \u00b6 upper_limit: float upper limit of the scale RecordValueSpecification \u00b6 RecordValueSpecification( values: List[ValueSpecification], /, *, label: Optional[str] = None, ) A record value specification label instance-attribute \u00b6 label: Optional[str] label of the record value specification, if any values instance-attribute \u00b6 values: List[ValueSpecification] list of values in the record ReferenceValueSpecification \u00b6 ReferenceValueSpecification( reference_value: DataPrototype, /, *, label: Optional[str] = None, ) A reference value specification This is a value specification that contains a reference to a DataPrototype which defines the target value specification. label instance-attribute \u00b6 label: Optional[str] label of the ReferenceValueSpecification , if any reference_value instance-attribute \u00b6 reference_value: DataPrototype the target data prototype that is referenced RuleArgument \u00b6 argument of a rule-based value specification V instance-attribute \u00b6 V: Type[RuleArgument_V] V: argument is a numerical value Vf instance-attribute \u00b6 Vf: Type[RuleArgument_Vf] VF: argument is a numerical value Vt instance-attribute \u00b6 Vt: Type[RuleArgument_Vt] VT: argument is a text value VtfNumber instance-attribute \u00b6 VtfNumber: Type[RuleArgument_VtfNumber] VTF: argument is a numerical value VtfText instance-attribute \u00b6 VtfText: Type[RuleArgument_VtfText] VTF: argument is a text value RuleArgument_V \u00b6 RuleArgument_V(value: float) Bases: RuleArgument argument is a numerical value value instance-attribute \u00b6 value: float the numerical value of the argument RuleArgument_Vf \u00b6 RuleArgument_Vf(value: float) Bases: RuleArgument argument is a numerical value value instance-attribute \u00b6 value: float the numerical value of the argument RuleArgument_Vt \u00b6 RuleArgument_Vt(value: str) Bases: RuleArgument argument is a text value value instance-attribute \u00b6 value: str the text value of the argument RuleArgument_VtfNumber \u00b6 RuleArgument_VtfNumber(value: float) Bases: RuleArgument argument is a numerical value value instance-attribute \u00b6 value: float the numerical value of the argument RuleArgument_VtfText \u00b6 RuleArgument_VtfText(value: str) Bases: RuleArgument argument is a text value value instance-attribute \u00b6 value: str the text value of the argument RuleBasedAxisCont \u00b6 RuleBasedAxisCont( category: SwAxisContCategory, sw_array_size: List[int], sw_axis_index: int, rule_based_values: RuleBasedValueSpecification, unit: Optional[Unit] = None, ) Specification of the axis values of a compound primitive data type (curve, map) in a rule-based definition category instance-attribute \u00b6 category: SwAxisContCategory category of the axis content rule_based_values instance-attribute \u00b6 rule_based_values: RuleBasedValueSpecification rule based value specification of the axis content sw_array_size instance-attribute \u00b6 sw_array_size: List[int] array size of the axis content sw_axis_index instance-attribute \u00b6 sw_axis_index: int index of the axis in the compound primitive data type unit instance-attribute \u00b6 unit: Optional[Unit] unit of the axis content, if any RuleBasedFillUntil \u00b6 standard fill rules for rule based value specifications End instance-attribute \u00b6 End: RuleBasedFillUntil FILL_UNTIL_END : fills the value of the last RuleBasedValueSpecification.arguments until the last element of the array has been filled MaxSize instance-attribute \u00b6 MaxSize: RuleBasedFillUntil FILL_UNTIL_MAX_SIZE : fills the value of the last RuleBasedValueSpecification.arguments until maxSizeToFill elements of the array have been filled RuleBasedValueCont \u00b6 RuleBasedValueCont( rule_based_values: RuleBasedValueSpecification, sw_array_size: List[int], unit: Optional[Unit] = None, ) Specification of the value content of a compound primitive data type (curve, map) in a rule-based definition rule_based_values instance-attribute \u00b6 rule_based_values: RuleBasedValueSpecification rule based value specification of the value content sw_array_size instance-attribute \u00b6 sw_array_size: List[int] array size of the value content unit instance-attribute \u00b6 unit: Optional[Unit] unit of the value content, if any RuleBasedValueSpecification \u00b6 RuleBasedValueSpecification( arguments: List[RuleArgument], rule: RuleBasedFillUntil, max_size_to_fill: Optional[int] = None, ) A rule based value specification arguments instance-attribute \u00b6 arguments: List[RuleArgument] list of RuleArgument objects in the rule based value specification max_size_to_fill instance-attribute \u00b6 max_size_to_fill: Optional[int] maximum size to fill in the rule based value specification, if any rule instance-attribute \u00b6 rule: RuleBasedFillUntil rule for filling the rule based value specification SwAxisCont \u00b6 SwAxisCont( category: SwAxisContCategory, sw_array_size: List[int], sw_axis_index: int, sw_values_phys: List[SwValue], /, *, unit: Optional[Unit] = None, unit_display_name: Optional[str] = None, ) Specification of the axis values of a compound primitive data type (curve, map) category instance-attribute \u00b6 category: SwAxisContCategory category of the axis content sw_array_size instance-attribute \u00b6 sw_array_size: List[int] array size of the axis content sw_axis_index instance-attribute \u00b6 sw_axis_index: int index of the axis in the compound primitive data type sw_values_phys instance-attribute \u00b6 sw_values_phys: List[SwValue] list of SwValue objects in the axis content unit instance-attribute \u00b6 unit: Optional[Unit] unit of the axis content, if any unit_display_name instance-attribute \u00b6 unit_display_name: Optional[str] display name of the unit, if any SwAxisContCategory \u00b6 Category of a SwAxisCont ComAxis instance-attribute \u00b6 ComAxis: SwAxisContCategory commmon axis ResAxis instance-attribute \u00b6 ResAxis: SwAxisContCategory rescale axis StdAxis instance-attribute \u00b6 StdAxis: SwAxisContCategory standard axis SwBaseType \u00b6 SwBaseType(element: Element) SwBaseType is a basic data type. It is used to define the data types of signals and variables. base_type_encoding instance-attribute \u00b6 base_type_encoding: BaseTypeEncoding set the base type encoding of the SwBaseType bit_length instance-attribute \u00b6 bit_length: Optional[int] get the bit length of the SwBaseType byte_order instance-attribute \u00b6 byte_order: Optional[ByteOrder] set the byte order of the SwBaseType The byte order is platform specific and should only be set when it is really needed. element instance-attribute \u00b6 element: Element mem_alignment instance-attribute \u00b6 mem_alignment: Optional[int] set the memory alignment of the SwBaseType The memory alignment describes the slignement in bits. Example: 8 means that the type is aligned to a byte. Since the memory alignment is platform specific, it should only be set when it is really needed. name instance-attribute \u00b6 name: str native_declaration instance-attribute \u00b6 native_declaration: Optional[str] set the native declaration of the SwBaseType The native declaration is a string that represents the type in the native programming language. SwValue \u00b6 a single value of a compound primitive data type (curve, map) V instance-attribute \u00b6 V: Type[SwValue_V] V: value is a numerical value Vf instance-attribute \u00b6 Vf: Type[SwValue_Vf] VF: value is a numerical value Vg instance-attribute \u00b6 Vg: Type[SwValue_Vg] VG: value is a group of values Vt instance-attribute \u00b6 Vt: Type[SwValue_Vt] VT: value is a text value VtfNumber instance-attribute \u00b6 VtfNumber: Type[SwValue_VtfNumber] VTF: value is a numerical value VtfText instance-attribute \u00b6 VtfText: Type[SwValue_VtfText] SwValueCont \u00b6 SwValueCont( sw_array_size: List[int], sw_values_phys: List[SwValue] ) Specification of the values of a compound primitive data type (curve, map) sw_array_size instance-attribute \u00b6 sw_array_size: List[int] array size of the value content sw_values_phys instance-attribute \u00b6 sw_values_phys: List[SwValue] list of SwValue objects in the value content SwValue_V \u00b6 SwValue_V(value: float) Bases: SwValue value is a numerical value value instance-attribute \u00b6 value: float the numerical value of the value SwValue_Vf \u00b6 SwValue_Vf(value: float) Bases: SwValue value is a numerical value value instance-attribute \u00b6 value: float the numerical value of the value SwValue_Vg \u00b6 SwValue_Vg( values: List[SwValue], label: Optional[str] = None ) Bases: SwValue value is a group of values label instance-attribute \u00b6 label: Optional[str] label of the group, if any values instance-attribute \u00b6 values: List[SwValue] list of SwValue objects in the group SwValue_Vt \u00b6 SwValue_Vt(value: str) Bases: SwValue value is a text value value instance-attribute \u00b6 value: str the text value of the value SwValue_VtfNumber \u00b6 SwValue_VtfNumber(value: float) Bases: SwValue value is a numerical value value instance-attribute \u00b6 value: float the numerical value of the value SwValue_VtfText \u00b6 SwValue_VtfText(value: str) Bases: SwValue value is a text value value instance-attribute \u00b6 value: str the text value of the value TabNoIntpEntry \u00b6 TabNoIntpEntry(*, value_in: float, value_out: float) a single entry of a CompuMethod whose category is TabNoInterpretation value_in instance-attribute \u00b6 value_in: float input value value_out instance-attribute \u00b6 value_out: float output value TextTableEntry \u00b6 TextTableEntry(*, text: str, value: float) text instance-attribute \u00b6 text: str text value instance-attribute \u00b6 value: float value TextValueSpecification \u00b6 TextValueSpecification( value: str, /, *, label: Optional[str] = None ) A text value specification This is a simple value specification that contains a single string value. label instance-attribute \u00b6 label: Optional[str] label of the text value specification, if any value instance-attribute \u00b6 value: str the text value Unit \u00b6 Unit(element: Element) Unit represents a unit of measurement. Use [ ArPackage::create_unit ] to create a new unit. display_name instance-attribute \u00b6 display_name: Optional[str] display name of the unit element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str","title":"Datatype"},{"location":"datatype_api/#api-documentation-autosar_dataabstractiondatatype","text":"","title":"API Documentation: autosar_data.abstraction.datatype"},{"location":"datatype_api/#autosar_data.abstraction.datatype","text":"","title":"datatype"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationDataType","text":"ApplicationDataType: TypeAlias = Union[ ApplicationPrimitiveDataType, ApplicationArrayDataType, ApplicationRecordDataType, ]","title":"ApplicationDataType"},{"location":"datatype_api/#autosar_data.abstraction.datatype.AutosarDataType","text":"AutosarDataType: TypeAlias = Union[ ApplicationDataType, ImplementationDataType ]","title":"AutosarDataType"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompositeRuleBasedValueArgument","text":"CompositeRuleBasedValueArgument: TypeAlias = Union[ ApplicationValueSpecification, ApplicationRuleBasedValueSpecification, ]","title":"CompositeRuleBasedValueArgument"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompositeValueSpecification","text":"CompositeValueSpecification: TypeAlias = Union[ ArrayValueSpecification, RecordValueSpecification ]","title":"CompositeValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataPointerTarget","text":"DataPointerTarget: TypeAlias = Union[ ImplementationDataType, SwBaseType ]","title":"DataPointerTarget"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataPrototype","text":"DataPrototype: TypeAlias = Union[ ArgumentDataPrototype, ParameterDataPrototype, VariableDataPrototype, ApplicationArrayElement, ApplicationRecordElement, ]","title":"DataPrototype"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ValueSpecification","text":"ValueSpecification: TypeAlias = Union[ ArrayValueSpecification, RecordValueSpecification, TextValueSpecification, NumericalValueSpecification, ConstantReference, ApplicationValueSpecification, NotAvailableValueSpecification, ReferenceValueSpecification, ApplicationRuleBasedValueSpecification, CompositeRuleBasedValueSpecification, NumericalRuleBasedValueSpecification, List[ValueSpecification], Tuple[ValueSpecification, ...], str, float, ]","title":"ValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArrayDataType","text":"ApplicationArrayDataType(element: Element) An application array data type Use ArPackage.create_application_array_data_type to create a new application array data type.","title":"ApplicationArrayDataType"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArrayDataType.array_element","text":"array_element: ApplicationArrayElement array element of the array data type","title":"array_element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArrayDataType.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArrayDataType.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArrayDataType.set_size","text":"set_size(size: ApplicationArraySize) -> None set the size specification of the array","title":"set_size"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArrayDataType.size","text":"size() -> ApplicationArraySize get the size specification of the array: Variable, Fixed, etc.","title":"size"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArrayElement","text":"ApplicationArrayElement(element: Element) An element in an application array data type","title":"ApplicationArrayElement"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArrayElement.data_type","text":"data_type: ApplicationDataType data type of the array element","title":"data_type"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArrayElement.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArrayElement.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize","text":"definition of the size type of an application array data type","title":"ApplicationArraySize"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize.Fixed","text":"Fixed: Type[ApplicationArraySize_Fixed]","title":"Fixed"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize.VariableFullyFlexible","text":"VariableFullyFlexible: Type[ ApplicationArraySize_VariableFullyFlexible ]","title":"VariableFullyFlexible"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize.VariableLinear","text":"VariableLinear: Type[ApplicationArraySize_VariableLinear]","title":"VariableLinear"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize.VariableRectangular","text":"VariableRectangular: Type[ ApplicationArraySize_VariableRectangular ]","title":"VariableRectangular"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize.VariableSquare","text":"VariableSquare: Type[ApplicationArraySize_VariableSquare]","title":"VariableSquare"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize_Fixed","text":"ApplicationArraySize_Fixed(length: int) Bases: ApplicationArraySize","title":"ApplicationArraySize_Fixed"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize_Fixed.length","text":"length: int","title":"length"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize_VariableFullyFlexible","text":"ApplicationArraySize_VariableFullyFlexible(max_size: int) Bases: ApplicationArraySize","title":"ApplicationArraySize_VariableFullyFlexible"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize_VariableFullyFlexible.max_size","text":"max_size: int","title":"max_size"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize_VariableLinear","text":"ApplicationArraySize_VariableLinear(max_size: int) Bases: ApplicationArraySize","title":"ApplicationArraySize_VariableLinear"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize_VariableLinear.max_size","text":"max_size: int","title":"max_size"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize_VariableRectangular","text":"ApplicationArraySize_VariableRectangular(max_size: int) Bases: ApplicationArraySize","title":"ApplicationArraySize_VariableRectangular"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize_VariableRectangular.max_size","text":"max_size: int","title":"max_size"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationArraySize_VariableSquare","text":"ApplicationArraySize_VariableSquare() Bases: ApplicationArraySize","title":"ApplicationArraySize_VariableSquare"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveCategory","text":"The category of an application primitive data type","title":"ApplicationPrimitiveCategory"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveCategory.Boolean","text":"Boolean: ApplicationPrimitiveCategory","title":"Boolean"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveCategory.ComAxis","text":"ComAxis: ApplicationPrimitiveCategory","title":"ComAxis"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveCategory.Cube4","text":"Cube4: ApplicationPrimitiveCategory","title":"Cube4"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveCategory.Cube5","text":"Cube5: ApplicationPrimitiveCategory","title":"Cube5"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveCategory.Cuboid","text":"Cuboid: ApplicationPrimitiveCategory","title":"Cuboid"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveCategory.Curve","text":"Curve: ApplicationPrimitiveCategory","title":"Curve"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveCategory.Map","text":"Map: ApplicationPrimitiveCategory","title":"Map"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveCategory.ResAxis","text":"ResAxis: ApplicationPrimitiveCategory","title":"ResAxis"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveCategory.String","text":"String: ApplicationPrimitiveCategory","title":"String"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveCategory.ValBlk","text":"ValBlk: ApplicationPrimitiveCategory","title":"ValBlk"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveCategory.Value","text":"Value: ApplicationPrimitiveCategory","title":"Value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveDataType","text":"ApplicationPrimitiveDataType(element: Element) An application primitive data type Use [ ArPackage::create_application_primitive_data_type ] to create a new application primitive data type.","title":"ApplicationPrimitiveDataType"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveDataType.category","text":"category: ApplicationPrimitiveCategory category of the primitive data type","title":"category"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveDataType.compu_method","text":"compu_method: CompuMethod set the compu method of the primitive data type","title":"compu_method"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveDataType.data_constraint","text":"data_constraint: DataConstr data constraint of the primitive data type","title":"data_constraint"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveDataType.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveDataType.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationPrimitiveDataType.unit","text":"unit: Unit unit of the primitive data type","title":"unit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRecordDataType","text":"ApplicationRecordDataType(element: Element) An application record data type Use [ ArPackage::create_application_record_data_type ] to create a new application record data type.","title":"ApplicationRecordDataType"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRecordDataType.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRecordDataType.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRecordDataType.create_record_element","text":"create_record_element( name: str, data_type: ApplicationDataType ) -> ApplicationRecordElement create a new element in the record data type","title":"create_record_element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRecordDataType.record_elements","text":"record_elements() -> Iterator[ApplicationRecordElement] get an iterator over the record elements of the record data type","title":"record_elements"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRecordElement","text":"ApplicationRecordElement(element: Element) An element in an application record data type","title":"ApplicationRecordElement"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRecordElement.data_type","text":"data_type: ApplicationDataType data type of the record element","title":"data_type"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRecordElement.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRecordElement.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRuleBasedValueSpecification","text":"ApplicationRuleBasedValueSpecification( category: ApplicationPrimitiveCategory, sw_axis_cont: List[RuleBasedAxisCont], sw_value_cont: RuleBasedValueCont, /, *, label: Optional[str] = None, ) An application rule based value specification","title":"ApplicationRuleBasedValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRuleBasedValueSpecification.category","text":"category: ApplicationPrimitiveCategory category of the application rule based value specification","title":"category"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRuleBasedValueSpecification.label","text":"label: Optional[str] label of the application rule based value specification, if any","title":"label"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRuleBasedValueSpecification.sw_axis_cont","text":"sw_axis_cont: List[RuleBasedAxisCont] list of RuleBasedAxisCont objects in the application rule based value specification","title":"sw_axis_cont"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationRuleBasedValueSpecification.sw_value_cont","text":"sw_value_cont: RuleBasedValueCont RuleBasedValueCont of the application rule based value specification","title":"sw_value_cont"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationValueSpecification","text":"ApplicationValueSpecification( category: ApplicationPrimitiveCategory, sw_axis_conts: List[SwAxisCont], sw_value_cont: SwValueCont, *, label: Optional[str] = None, ) An application value specification","title":"ApplicationValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationValueSpecification.category","text":"category: ApplicationPrimitiveCategory category of the application value specification","title":"category"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationValueSpecification.label","text":"label: Optional[str] label of the application value specification, if any","title":"label"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationValueSpecification.sw_axis_conts","text":"sw_axis_conts: List[SwAxisCont] list of SwAxisCont objects in the application value specification","title":"sw_axis_conts"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ApplicationValueSpecification.sw_value_cont","text":"sw_value_cont: SwValueCont SwValueCont of the application value specification","title":"sw_value_cont"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ArrayValueSpecification","text":"ArrayValueSpecification( values: List[ValueSpecification], /, *, label: Optional[str] = None, ) An array value specification","title":"ArrayValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ArrayValueSpecification.label","text":"label: Optional[str] label of the array value specification, if any","title":"label"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ArrayValueSpecification.values","text":"values: List[ValueSpecification] list of values in the array","title":"values"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding","text":"BaseTypeEncoding describes the encoding of a basic data type.","title":"BaseTypeEncoding"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.BcdPacked","text":"BcdPacked: BaseTypeEncoding","title":"BcdPacked"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.BcdUnpacked","text":"BcdUnpacked: BaseTypeEncoding","title":"BcdUnpacked"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.Boolean","text":"Boolean: BaseTypeEncoding","title":"Boolean"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.DspFractional","text":"DspFractional: BaseTypeEncoding","title":"DspFractional"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.Ieee754","text":"Ieee754: BaseTypeEncoding","title":"Ieee754"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.Iso8859_1","text":"Iso8859_1: BaseTypeEncoding","title":"Iso8859_1"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.Iso8859_2","text":"Iso8859_2: BaseTypeEncoding","title":"Iso8859_2"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.NoEncoding","text":"NoEncoding: BaseTypeEncoding","title":"NoEncoding"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.OnesComplement","text":"OnesComplement: BaseTypeEncoding","title":"OnesComplement"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.SignMagnitude","text":"SignMagnitude: BaseTypeEncoding","title":"SignMagnitude"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.TwosComplement","text":"TwosComplement: BaseTypeEncoding","title":"TwosComplement"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.Ucs2","text":"Ucs2: BaseTypeEncoding","title":"Ucs2"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.Utf16","text":"Utf16: BaseTypeEncoding","title":"Utf16"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.Utf8","text":"Utf8: BaseTypeEncoding","title":"Utf8"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.Void","text":"Void: BaseTypeEncoding","title":"Void"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BaseTypeEncoding.Windows1252","text":"Windows1252: BaseTypeEncoding","title":"Windows1252"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BitfieldEntry","text":"BitfieldEntry(*, text: str, value: float, mask: int) A single entry of a bitfield text table conversion","title":"BitfieldEntry"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BitfieldEntry.mask","text":"mask: int bit mask of this entry","title":"mask"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BitfieldEntry.text","text":"text: str text of this entry","title":"text"},{"location":"datatype_api/#autosar_data.abstraction.datatype.BitfieldEntry.value","text":"value: float numeric value of this entry","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompositeRuleBasedValueSpecification","text":"CompositeRuleBasedValueSpecification( argument: List[CompositeValueSpecification], compound_primitive_argument: List[ CompositeRuleBasedValueArgument ], max_size_to_fill: Optional[int], rule: RuleBasedFillUntil, /, *, label: Optional[str] = None, ) A composite rule based value specification","title":"CompositeRuleBasedValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompositeRuleBasedValueSpecification.argument","text":"argument: List[CompositeValueSpecification] list of CompositeValueSpecification objects in the composite rule based value specification","title":"argument"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompositeRuleBasedValueSpecification.compound_primitive_argument","text":"compound_primitive_argument: List[ CompositeRuleBasedValueArgument ] list of CompositeRuleBasedValueArgument objects in the composite rule based value specification","title":"compound_primitive_argument"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompositeRuleBasedValueSpecification.label","text":"label: Optional[str] label of the composite rule based value specification, if any","title":"label"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompositeRuleBasedValueSpecification.max_size_to_fill","text":"max_size_to_fill: Optional[int] maximum size to fill in the composite rule based value specification","title":"max_size_to_fill"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompositeRuleBasedValueSpecification.rule","text":"rule: RuleBasedFillUntil rule for filling the composite rule based value specification","title":"rule"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethod","text":"CompuMethod(element: Element) A CompuMethod describes the conversion between physical and internal values Use [ ArPackage::create_compu_method ] to create a new CompuMethod","title":"CompuMethod"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethod.category","text":"category: CompuMethodCategory category of the CompuMethod","title":"category"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethod.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethod.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethod.content","text":"content() -> Optional[CompuMethodContent] get the CompuMethodContent of the CompuMethod","title":"content"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethod.create_compu_scale","text":"create_compu_scale( direction: CompuScaleDirection, /, *, lower_limit: Optional[float] = None, upper_limit: Optional[float] = None, ) -> CompuScale create a CompuScale in the CompuMethod","title":"create_compu_scale"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethod.int_to_phys_compu_scales","text":"int_to_phys_compu_scales() -> Iterator[CompuScale] Create an iterator over the internal-to-physical CompuScales","title":"int_to_phys_compu_scales"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethod.phys_to_int_compu_scales","text":"phys_to_int_compu_scales() -> Iterator[CompuScale] Create an iterator over the physical-to-internal CompuScales","title":"phys_to_int_compu_scales"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethod.set_content","text":"set_content(content: CompuMethodContent) -> None set the content of the CompuMethod Writing to this attribute removes any existing content","title":"set_content"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodBitfieldTextTableContent","text":"A single entry of a bitfield text table conversion","title":"CompuMethodBitfieldTextTableContent"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodBitfieldTextTableContent.mask","text":"mask: int bit mask of this entry","title":"mask"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodBitfieldTextTableContent.text","text":"text: str text of this entry","title":"text"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodBitfieldTextTableContent.value","text":"value: float numeric value of this entry","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodCategory","text":"Category of a CompuMethod","title":"CompuMethodCategory"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodCategory.BitfieldTextTable","text":"BitfieldTextTable: CompuMethodCategory","title":"BitfieldTextTable"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodCategory.Identical","text":"Identical: CompuMethodCategory","title":"Identical"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodCategory.Linear","text":"Linear: CompuMethodCategory","title":"Linear"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodCategory.Rational","text":"Rational: CompuMethodCategory","title":"Rational"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodCategory.ScaleLinear","text":"ScaleLinear: CompuMethodCategory","title":"ScaleLinear"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodCategory.ScaleLinearAndTextTable","text":"ScaleLinearAndTextTable: CompuMethodCategory","title":"ScaleLinearAndTextTable"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodCategory.ScaleRational","text":"ScaleRational: CompuMethodCategory","title":"ScaleRational"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodCategory.ScaleRationalAndTextTable","text":"ScaleRationalAndTextTable: CompuMethodCategory","title":"ScaleRationalAndTextTable"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodCategory.TabNoInterpretation","text":"TabNoInterpretation: CompuMethodCategory","title":"TabNoInterpretation"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodCategory.TextTable","text":"TextTable: CompuMethodCategory","title":"TextTable"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent","text":"Content of a CompuMethod","title":"CompuMethodContent"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent.BitfieldTextTable","text":"BitfieldTextTable: Type[ CompuMethodContent_BitfieldTextTable ]","title":"BitfieldTextTable"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent.Identical","text":"Identical: Type[CompuMethodContent_Identical]","title":"Identical"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent.Linear","text":"Linear: Type[CompuMethodContent_Linear]","title":"Linear"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent.Rational","text":"Rational: Type[CompuMethodContent_Rational]","title":"Rational"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent.ScaleLinear","text":"ScaleLinear: Type[CompuMethodContent_ScaleLinear]","title":"ScaleLinear"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent.ScaleLinearAndTextTable","text":"ScaleLinearAndTextTable: Type[ CompuMethodContent_ScaleLinearAndTextTable ]","title":"ScaleLinearAndTextTable"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent.ScaleRational","text":"ScaleRational: Type[CompuMethodContent_ScaleRational]","title":"ScaleRational"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent.ScaleRationalAndTextTable","text":"ScaleRationalAndTextTable: Type[ CompuMethodContent_ScaleRationalAndTextTable ]","title":"ScaleRationalAndTextTable"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent.TabNoInterpretation","text":"TabNoInterpretation: Type[ CompuMethodContent_TabNoInterpretation ]","title":"TabNoInterpretation"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent.TextTable","text":"TextTable: Type[CompuMethodContent_TextTable]","title":"TextTable"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_BitfieldTextTable","text":"CompuMethodContent_BitfieldTextTable( entries: List[BitfieldEntry], ) Bases: CompuMethodContent","title":"CompuMethodContent_BitfieldTextTable"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_BitfieldTextTable.entries","text":"entries: List[BitfieldEntry]","title":"entries"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Identical","text":"CompuMethodContent_Identical() Bases: CompuMethodContent","title":"CompuMethodContent_Identical"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Linear","text":"CompuMethodContent_Linear( *, direction: CompuScaleDirection, divisor: float, factor: float, offset: float, lower_limit: Optional[float] = None, upper_limit: Optional[float] = None, ) Bases: CompuMethodContent","title":"CompuMethodContent_Linear"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Linear.direction","text":"direction: CompuScaleDirection","title":"direction"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Linear.divisor","text":"divisor: float","title":"divisor"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Linear.factor","text":"factor: float","title":"factor"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Linear.lower_limit","text":"lower_limit: Optional[float]","title":"lower_limit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Linear.offset","text":"offset: float","title":"offset"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Linear.upper_limit","text":"upper_limit: Optional[float]","title":"upper_limit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Rational","text":"CompuMethodContent_Rational( *, direction: CompuScaleDirection, denominator: List[float], numerator: List[float], lower_limit: float, upper_limit: float, ) Bases: CompuMethodContent","title":"CompuMethodContent_Rational"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Rational.denominator","text":"denominator: List[float]","title":"denominator"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Rational.direction","text":"direction: CompuScaleDirection","title":"direction"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Rational.lower_limit","text":"lower_limit: float","title":"lower_limit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Rational.numerator","text":"numerator: List[float]","title":"numerator"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_Rational.upper_limit","text":"upper_limit: float","title":"upper_limit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_ScaleLinear","text":"CompuMethodContent_ScaleLinear( *, scales: List[LinearConversionParameters] ) Bases: CompuMethodContent","title":"CompuMethodContent_ScaleLinear"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_ScaleLinear.scales","text":"scales: List[LinearConversionParameters]","title":"scales"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_ScaleLinearAndTextTable","text":"CompuMethodContent_ScaleLinearAndTextTable( *, scales: List[LinearConversionParameters], texts: List[TextTableEntry], ) Bases: CompuMethodContent","title":"CompuMethodContent_ScaleLinearAndTextTable"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_ScaleLinearAndTextTable.scales","text":"scales: List[LinearConversionParameters]","title":"scales"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_ScaleLinearAndTextTable.texts","text":"texts: List[TextTableEntry]","title":"texts"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_ScaleRational","text":"CompuMethodContent_ScaleRational( *, scales: List[RationalConversionParameters] ) Bases: CompuMethodContent","title":"CompuMethodContent_ScaleRational"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_ScaleRational.scales","text":"scales: List[RationalConversionParameters]","title":"scales"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_ScaleRationalAndTextTable","text":"CompuMethodContent_ScaleRationalAndTextTable( *, scales: List[RationalConversionParameters], texts: List[TextTableEntry], ) Bases: CompuMethodContent","title":"CompuMethodContent_ScaleRationalAndTextTable"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_ScaleRationalAndTextTable.scales","text":"scales: List[RationalConversionParameters]","title":"scales"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_ScaleRationalAndTextTable.texts","text":"texts: List[TextTableEntry]","title":"texts"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_TabNoInterpretation","text":"CompuMethodContent_TabNoInterpretation( *, entries: List[TabNoIntpEntry] ) Bases: CompuMethodContent","title":"CompuMethodContent_TabNoInterpretation"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_TabNoInterpretation.entries","text":"entries: List[TabNoIntpEntry]","title":"entries"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_TextTable","text":"CompuMethodContent_TextTable( *, texts: List[TextTableEntry] ) Bases: CompuMethodContent","title":"CompuMethodContent_TextTable"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodContent_TextTable.texts","text":"texts: List[TextTableEntry]","title":"texts"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuMethodIdenticalContent","text":"Description of the content of a CompuMethod whose category is Identical . This class is empty, as there are no additional attributes for the identical conversion.","title":"CompuMethodIdenticalContent"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuScale","text":"CompuScale(element: Element) A CompuScale describes the conversion between physical and internal values, as well as the limits of the scale","title":"CompuScale"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuScale.content","text":"content: Union[CompuScaleRationalCoefficients, str, int] content of the CompuScale","title":"content"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuScale.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuScale.lower_limit","text":"lower_limit: Optional[float] lower limit of the CompuScale","title":"lower_limit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuScale.mask","text":"mask: Optional[int] mask of the CompuScale , applicable for BitfieldTextTable","title":"mask"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuScale.upper_limit","text":"upper_limit: Optional[float] upper limit of the CompuScale","title":"upper_limit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuScaleDirection","text":"Direction of a CompuScale","title":"CompuScaleDirection"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuScaleDirection.IntToPhys","text":"IntToPhys: CompuScaleDirection","title":"IntToPhys"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuScaleDirection.PhysToInt","text":"PhysToInt: CompuScaleDirection","title":"PhysToInt"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuScaleRationalCoefficients","text":"CompuScaleRationalCoefficients( *, numerator: List[float], denominator: List[float] ) Rational coefficients of a CompuScale","title":"CompuScaleRationalCoefficients"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuScaleRationalCoefficients.denominator","text":"denominator: List[float] list of denominator coefficients","title":"denominator"},{"location":"datatype_api/#autosar_data.abstraction.datatype.CompuScaleRationalCoefficients.numerator","text":"numerator: List[float] list of numerator coefficients","title":"numerator"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ConstantReference","text":"ConstantReference( constant: ConstantSpecification, /, *, label: Optional[str] = None, ) A ConstantReference is a reference to a ConstantSpecification which can be used in a ValueSpecification.","title":"ConstantReference"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ConstantReference.constant","text":"constant: ConstantSpecification the constant specification that is referenced","title":"constant"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ConstantReference.label","text":"label: Optional[str] label of the ConstantReference , if any","title":"label"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ConstantSpecification","text":"ConstantSpecification(element: Element) A ConstantSpecification is a specification of a constant value. Use [ ArPackage::create_constant_specification ] to create a new ConstantSpecification .","title":"ConstantSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ConstantSpecification.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ConstantSpecification.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ConstantSpecification.value_specification","text":"value_specification: ValueSpecification","title":"value_specification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstr","text":"DataConstr(element: Element) DataConstr represents a data constraint.","title":"DataConstr"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstr.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstr.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstr.create_data_constr_rule","text":"create_data_constr_rule( rule_type: DataConstrType, /, *, lower_limit: Optional[float] = None, upper_limit: Optional[float] = None, ) -> DataConstrRule Create a data constraint rule","title":"create_data_constr_rule"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstr.data_constr_rules","text":"data_constr_rules() -> Iterator[DataConstrRule] Get all data constraint rules","title":"data_constr_rules"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstrRule","text":"DataConstrRule(element: Element) DataConstrRule represents a data constraint rule.","title":"DataConstrRule"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstrRule.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstrRule.lower_limit","text":"lower_limit: Optional[float] get the lower limit","title":"lower_limit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstrRule.rule_type","text":"rule_type: DataConstrType get the constraint type","title":"rule_type"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstrRule.upper_limit","text":"upper_limit: Optional[float] get the upper limit","title":"upper_limit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstrType","text":"The type of a data constraint rule","title":"DataConstrType"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstrType.Internal","text":"Internal: DataConstrType","title":"Internal"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataConstrType.Physical","text":"Physical: DataConstrType","title":"Physical"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataTypeMap","text":"DataTypeMap(element: Element) A DataTypeMap maps an ImplementationDataType to an ApplicationDataType","title":"DataTypeMap"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataTypeMap.application_data_type","text":"application_data_type: ApplicationDataType Get the ApplicationDataType of the DataTypeMap","title":"application_data_type"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataTypeMap.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataTypeMap.implementation_data_type","text":"implementation_data_type: ImplementationDataType Get the ImplementationDataType of the DataTypeMap","title":"implementation_data_type"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataTypeMappingSet","text":"DataTypeMappingSet(element: Element) A [ DataTypeMappingSet ] contains DataTypeMap s Use [ ArPackage::create_data_type_mapping_set ] to create a new DataTypeMappingSet","title":"DataTypeMappingSet"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataTypeMappingSet.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataTypeMappingSet.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataTypeMappingSet.create_data_type_map","text":"create_data_type_map( implementation_data_type: ImplementationDataType, application_data_type: ApplicationDataType, ) -> DataTypeMap Create a new DataTypeMap in the DataTypeMappingSet","title":"create_data_type_map"},{"location":"datatype_api/#autosar_data.abstraction.datatype.DataTypeMappingSet.data_type_maps","text":"data_type_maps() -> Iterator[DataTypeMap] Get an iterator over the DataTypeMap s in the DataTypeMappingSet","title":"data_type_maps"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataCategory","text":"The category of an implementation data type","title":"ImplementationDataCategory"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataCategory.Array","text":"Array: ImplementationDataCategory","title":"Array"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataCategory.DataReference","text":"DataReference: ImplementationDataCategory","title":"DataReference"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataCategory.FunctionReference","text":"FunctionReference: ImplementationDataCategory","title":"FunctionReference"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataCategory.Structure","text":"Structure: ImplementationDataCategory","title":"Structure"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataCategory.TypeReference","text":"TypeReference: ImplementationDataCategory","title":"TypeReference"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataCategory.Union","text":"Union: ImplementationDataCategory","title":"Union"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataCategory.Value","text":"Value: ImplementationDataCategory","title":"Value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType","text":"ImplementationDataType(element: Element) An implementation data type; specifics are determined by the category Use [ ArPackage::create_implementation_data_type ] to create a new implementation data type","title":"ImplementationDataType"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType.array_size","text":"array_size: Optional[int] array size of this implementation data type [category: ARRAY]","title":"array_size"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType.base_type","text":"base_type: Optional[SwBaseType] SwBaseType of this implementation data type [category: VALUE]","title":"base_type"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType.category","text":"category: Optional[ImplementationDataCategory] category of this implementation data type","title":"category"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType.compu_method","text":"compu_method: Optional[CompuMethod] CompuMethod of this implementation data type [category: VALUE, TYPE_REFERENCE ]","title":"compu_method"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType.data_constraint","text":"data_constraint: Optional[DataConstr] DataConstr of this implementation data type [category: VALUE, TYPE_REFERENCE ]","title":"data_constraint"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType.data_pointer_target","text":"data_pointer_target: Optional[DataPointerTarget] get the target type of the data pointer [category: DATA_REFERENCE]","title":"data_pointer_target"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType.referenced_type","text":"referenced_type: Optional[ImplementationDataType] get the referenced implementation data type [category: TYPE_REFERENCE ]","title":"referenced_type"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType.apply_settings","text":"apply_settings( settings: ImplementationDataTypeSettings, ) -> None apply the settings to this implementation data type Calling this method completely replaces the existing settings of the implementation data type, deleting existing sub-elements and creating new ones according to the settings","title":"apply_settings"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType.settings","text":"settings() -> Optional[ImplementationDataTypeSettings] get the settings of this implementation data type","title":"settings"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataType.sub_elements","text":"sub_elements() -> Iterator[ImplementationDataTypeElement] create an iterator over the sub-elements of this implementation data type","title":"sub_elements"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement","text":"ImplementationDataTypeElement(element: Element) An element of an implementation data type","title":"ImplementationDataTypeElement"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement.array_size","text":"array_size: Optional[int] array size of this implementation data type [category: ARRAY]","title":"array_size"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement.base_type","text":"base_type: Optional[SwBaseType] SwBaseType of this implementation data type [category: VALUE]","title":"base_type"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement.category","text":"category: Optional[ImplementationDataCategory] category of this implementation data type","title":"category"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement.compu_method","text":"compu_method: Optional[CompuMethod] CompuMethod of this implementation data type [category: VALUE, TYPE_REFERENCE ]","title":"compu_method"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement.data_constraint","text":"data_constraint: Optional[DataConstr] DataConstr of this implementation data type [category: VALUE, TYPE_REFERENCE ]","title":"data_constraint"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement.data_pointer_target","text":"data_pointer_target: Optional[DataPointerTarget] get the target type of the data pointer [category: DATA_REFERENCE]","title":"data_pointer_target"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement.referenced_type","text":"referenced_type: Optional[ImplementationDataType] get the referenced implementation data type [category: TYPE_REFERENCE ]","title":"referenced_type"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement.apply_settings","text":"apply_settings( settings: ImplementationDataTypeSettings, ) -> None apply the settings to this implementation data type Calling this method completely replaces the existing settings of the implementation data type, deleting existing sub-elements and creating new ones according to the settings","title":"apply_settings"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement.settings","text":"settings() -> ImplementationDataTypeSettings get the settings of this implementation data type","title":"settings"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeElement.sub_elements","text":"sub_elements() -> Iterator[ImplementationDataTypeElement] create an iterator over the sub-elements of this implementation data type","title":"sub_elements"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings","text":"Settings for an implementation data type This structure is used to create new implementation data types","title":"ImplementationDataTypeSettings"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings.Array","text":"Array( name: str, *, length: int, element_type: ImplementationDataTypeSettings, ) -> ImplementationDataTypeSettings","title":"Array"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings.DataReference","text":"DataReference( name: str, *, target: DataPointerTarget ) -> ImplementationDataTypeSettings","title":"DataReference"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings.FunctionReference","text":"FunctionReference( name: str, ) -> ImplementationDataTypeSettings","title":"FunctionReference"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings.Structure","text":"Structure( name: str, *, elements: List[ImplementationDataTypeSettings], ) -> ImplementationDataTypeSettings","title":"Structure"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings.TypeReference","text":"TypeReference( name: str, *, reftype: ImplementationDataType, compu_method: Optional[CompuMethod] = None, data_constraint: Optional[DataConstr] = None, ) -> ImplementationDataTypeSettings","title":"TypeReference"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings.Union","text":"Union( name: str, *, elements: List[ImplementationDataTypeSettings], ) -> ImplementationDataTypeSettings","title":"Union"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings.Value","text":"Value( name: str, *, base_type: SwBaseType, compu_method: Optional[CompuMethod] = None, data_constraint: Optional[DataConstr] = None, ) -> ImplementationDataTypeSettings","title":"Value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Array","text":"Bases: ImplementationDataTypeSettings","title":"ImplementationDataTypeSettings_Array"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Array.element_type","text":"element_type: ImplementationDataType","title":"element_type"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Array.length","text":"length: int","title":"length"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Array.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_DataReference","text":"Bases: ImplementationDataTypeSettings","title":"ImplementationDataTypeSettings_DataReference"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_DataReference.data_pointer_target","text":"data_pointer_target: DataPointerTarget get the target type of the data pointer","title":"data_pointer_target"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_DataReference.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_FunctionReference","text":"Bases: ImplementationDataTypeSettings","title":"ImplementationDataTypeSettings_FunctionReference"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_FunctionReference.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Structure","text":"Bases: ImplementationDataTypeSettings","title":"ImplementationDataTypeSettings_Structure"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Structure.elements","text":"elements: List[ImplementationDataTypeElement]","title":"elements"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Structure.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_TypeReference","text":"Bases: ImplementationDataTypeSettings","title":"ImplementationDataTypeSettings_TypeReference"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_TypeReference.compu_method","text":"compu_method: CompuMethod","title":"compu_method"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_TypeReference.data_constraint","text":"data_constraint: DataConstr","title":"data_constraint"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_TypeReference.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_TypeReference.reftype","text":"reftype: ImplementationDataType","title":"reftype"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Union","text":"Bases: ImplementationDataTypeSettings","title":"ImplementationDataTypeSettings_Union"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Union.elements","text":"elements: List[ImplementationDataTypeElement]","title":"elements"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Union.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Value","text":"Bases: ImplementationDataTypeSettings","title":"ImplementationDataTypeSettings_Value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Value.base_type","text":"base_type: SwBaseType","title":"base_type"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Value.compu_method","text":"compu_method: CompuMethod","title":"compu_method"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Value.data_constraint","text":"data_constraint: DataConstr","title":"data_constraint"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ImplementationDataTypeSettings_Value.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.LinearConversionParameters","text":"LinearConversionParameters( *, direction: CompuScaleDirection, offset: float, factor: float, divisor: float, lower_limit: float, upper_limit: float, ) Linear conversion parameters for CompuMethodScaleLinearContent and CompuMethodScaleLinearAndTextTable","title":"LinearConversionParameters"},{"location":"datatype_api/#autosar_data.abstraction.datatype.LinearConversionParameters.direction","text":"direction: CompuScaleDirection direction of the conversion","title":"direction"},{"location":"datatype_api/#autosar_data.abstraction.datatype.LinearConversionParameters.divisor","text":"divisor: float divisor","title":"divisor"},{"location":"datatype_api/#autosar_data.abstraction.datatype.LinearConversionParameters.factor","text":"factor: float factor","title":"factor"},{"location":"datatype_api/#autosar_data.abstraction.datatype.LinearConversionParameters.lower_limit","text":"lower_limit: float lower limit of the scale","title":"lower_limit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.LinearConversionParameters.offset","text":"offset: float offset","title":"offset"},{"location":"datatype_api/#autosar_data.abstraction.datatype.LinearConversionParameters.upper_limit","text":"upper_limit: float upper limit of the scale","title":"upper_limit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.NotAvailableValueSpecification","text":"NotAvailableValueSpecification( *, default_pattern: Optional[int] = None, label: Optional[str] = None, ) A value specification that is not available. It is used for ApplicationRecordElements where the attribute isOptional ist set to the value True.","title":"NotAvailableValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.NotAvailableValueSpecification.default_pattern","text":"default_pattern: Optional[int] default pattern to fill unused memory, if any","title":"default_pattern"},{"location":"datatype_api/#autosar_data.abstraction.datatype.NotAvailableValueSpecification.label","text":"label: Optional[str] label of the NotAvailableValueSpecification , if any","title":"label"},{"location":"datatype_api/#autosar_data.abstraction.datatype.NumericalRuleBasedValueSpecification","text":"NumericalRuleBasedValueSpecification( rule_based_values: RuleBasedValueSpecification, /, *, label: Optional[str] = None, ) A numerical rule based value specification This is a value specification that contains a rule based value specification for numerical values.","title":"NumericalRuleBasedValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.NumericalRuleBasedValueSpecification.label","text":"label: Optional[str] label of the numerical rule based value specification, if any","title":"label"},{"location":"datatype_api/#autosar_data.abstraction.datatype.NumericalRuleBasedValueSpecification.rule_based_values","text":"rule_based_values: RuleBasedValueSpecification the rule based value specification that contains the numerical values","title":"rule_based_values"},{"location":"datatype_api/#autosar_data.abstraction.datatype.NumericalValueSpecification","text":"NumericalValueSpecification( value: float, /, *, label: Optional[str] = None ) A numerical value specification This is a simple value specification that contains a single float value.","title":"NumericalValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.NumericalValueSpecification.label","text":"label: Optional[str] label of the numerical value specification, if any","title":"label"},{"location":"datatype_api/#autosar_data.abstraction.datatype.NumericalValueSpecification.value","text":"value: float the numerical value","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RationalConversionParameters","text":"RationalConversionParameters( *, direction: CompuScaleDirection, denominator: List[float], numerator: List[float], lower_limit: float, upper_limit: float, ) Description of the content of a CompuMethod whose category is Rational Initialize self. See help(type(self)) for accurate signature.","title":"RationalConversionParameters"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RationalConversionParameters.denominator","text":"denominator: List[float] list of numerator coefficients","title":"denominator"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RationalConversionParameters.direction","text":"direction: CompuScaleDirection direction of the conversion","title":"direction"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RationalConversionParameters.lower_limit","text":"lower_limit: float lower limit of the scale","title":"lower_limit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RationalConversionParameters.numerator","text":"numerator: List[float] list of denominator coefficients","title":"numerator"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RationalConversionParameters.upper_limit","text":"upper_limit: float upper limit of the scale","title":"upper_limit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RecordValueSpecification","text":"RecordValueSpecification( values: List[ValueSpecification], /, *, label: Optional[str] = None, ) A record value specification","title":"RecordValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RecordValueSpecification.label","text":"label: Optional[str] label of the record value specification, if any","title":"label"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RecordValueSpecification.values","text":"values: List[ValueSpecification] list of values in the record","title":"values"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ReferenceValueSpecification","text":"ReferenceValueSpecification( reference_value: DataPrototype, /, *, label: Optional[str] = None, ) A reference value specification This is a value specification that contains a reference to a DataPrototype which defines the target value specification.","title":"ReferenceValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ReferenceValueSpecification.label","text":"label: Optional[str] label of the ReferenceValueSpecification , if any","title":"label"},{"location":"datatype_api/#autosar_data.abstraction.datatype.ReferenceValueSpecification.reference_value","text":"reference_value: DataPrototype the target data prototype that is referenced","title":"reference_value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument","text":"argument of a rule-based value specification","title":"RuleArgument"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument.V","text":"V: Type[RuleArgument_V] V: argument is a numerical value","title":"V"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument.Vf","text":"Vf: Type[RuleArgument_Vf] VF: argument is a numerical value","title":"Vf"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument.Vt","text":"Vt: Type[RuleArgument_Vt] VT: argument is a text value","title":"Vt"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument.VtfNumber","text":"VtfNumber: Type[RuleArgument_VtfNumber] VTF: argument is a numerical value","title":"VtfNumber"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument.VtfText","text":"VtfText: Type[RuleArgument_VtfText] VTF: argument is a text value","title":"VtfText"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument_V","text":"RuleArgument_V(value: float) Bases: RuleArgument argument is a numerical value","title":"RuleArgument_V"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument_V.value","text":"value: float the numerical value of the argument","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument_Vf","text":"RuleArgument_Vf(value: float) Bases: RuleArgument argument is a numerical value","title":"RuleArgument_Vf"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument_Vf.value","text":"value: float the numerical value of the argument","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument_Vt","text":"RuleArgument_Vt(value: str) Bases: RuleArgument argument is a text value","title":"RuleArgument_Vt"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument_Vt.value","text":"value: str the text value of the argument","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument_VtfNumber","text":"RuleArgument_VtfNumber(value: float) Bases: RuleArgument argument is a numerical value","title":"RuleArgument_VtfNumber"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument_VtfNumber.value","text":"value: float the numerical value of the argument","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument_VtfText","text":"RuleArgument_VtfText(value: str) Bases: RuleArgument argument is a text value","title":"RuleArgument_VtfText"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleArgument_VtfText.value","text":"value: str the text value of the argument","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedAxisCont","text":"RuleBasedAxisCont( category: SwAxisContCategory, sw_array_size: List[int], sw_axis_index: int, rule_based_values: RuleBasedValueSpecification, unit: Optional[Unit] = None, ) Specification of the axis values of a compound primitive data type (curve, map) in a rule-based definition","title":"RuleBasedAxisCont"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedAxisCont.category","text":"category: SwAxisContCategory category of the axis content","title":"category"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedAxisCont.rule_based_values","text":"rule_based_values: RuleBasedValueSpecification rule based value specification of the axis content","title":"rule_based_values"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedAxisCont.sw_array_size","text":"sw_array_size: List[int] array size of the axis content","title":"sw_array_size"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedAxisCont.sw_axis_index","text":"sw_axis_index: int index of the axis in the compound primitive data type","title":"sw_axis_index"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedAxisCont.unit","text":"unit: Optional[Unit] unit of the axis content, if any","title":"unit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedFillUntil","text":"standard fill rules for rule based value specifications","title":"RuleBasedFillUntil"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedFillUntil.End","text":"End: RuleBasedFillUntil FILL_UNTIL_END : fills the value of the last RuleBasedValueSpecification.arguments until the last element of the array has been filled","title":"End"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedFillUntil.MaxSize","text":"MaxSize: RuleBasedFillUntil FILL_UNTIL_MAX_SIZE : fills the value of the last RuleBasedValueSpecification.arguments until maxSizeToFill elements of the array have been filled","title":"MaxSize"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedValueCont","text":"RuleBasedValueCont( rule_based_values: RuleBasedValueSpecification, sw_array_size: List[int], unit: Optional[Unit] = None, ) Specification of the value content of a compound primitive data type (curve, map) in a rule-based definition","title":"RuleBasedValueCont"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedValueCont.rule_based_values","text":"rule_based_values: RuleBasedValueSpecification rule based value specification of the value content","title":"rule_based_values"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedValueCont.sw_array_size","text":"sw_array_size: List[int] array size of the value content","title":"sw_array_size"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedValueCont.unit","text":"unit: Optional[Unit] unit of the value content, if any","title":"unit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedValueSpecification","text":"RuleBasedValueSpecification( arguments: List[RuleArgument], rule: RuleBasedFillUntil, max_size_to_fill: Optional[int] = None, ) A rule based value specification","title":"RuleBasedValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedValueSpecification.arguments","text":"arguments: List[RuleArgument] list of RuleArgument objects in the rule based value specification","title":"arguments"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedValueSpecification.max_size_to_fill","text":"max_size_to_fill: Optional[int] maximum size to fill in the rule based value specification, if any","title":"max_size_to_fill"},{"location":"datatype_api/#autosar_data.abstraction.datatype.RuleBasedValueSpecification.rule","text":"rule: RuleBasedFillUntil rule for filling the rule based value specification","title":"rule"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwAxisCont","text":"SwAxisCont( category: SwAxisContCategory, sw_array_size: List[int], sw_axis_index: int, sw_values_phys: List[SwValue], /, *, unit: Optional[Unit] = None, unit_display_name: Optional[str] = None, ) Specification of the axis values of a compound primitive data type (curve, map)","title":"SwAxisCont"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwAxisCont.category","text":"category: SwAxisContCategory category of the axis content","title":"category"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwAxisCont.sw_array_size","text":"sw_array_size: List[int] array size of the axis content","title":"sw_array_size"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwAxisCont.sw_axis_index","text":"sw_axis_index: int index of the axis in the compound primitive data type","title":"sw_axis_index"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwAxisCont.sw_values_phys","text":"sw_values_phys: List[SwValue] list of SwValue objects in the axis content","title":"sw_values_phys"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwAxisCont.unit","text":"unit: Optional[Unit] unit of the axis content, if any","title":"unit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwAxisCont.unit_display_name","text":"unit_display_name: Optional[str] display name of the unit, if any","title":"unit_display_name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwAxisContCategory","text":"Category of a SwAxisCont","title":"SwAxisContCategory"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwAxisContCategory.ComAxis","text":"ComAxis: SwAxisContCategory commmon axis","title":"ComAxis"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwAxisContCategory.ResAxis","text":"ResAxis: SwAxisContCategory rescale axis","title":"ResAxis"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwAxisContCategory.StdAxis","text":"StdAxis: SwAxisContCategory standard axis","title":"StdAxis"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwBaseType","text":"SwBaseType(element: Element) SwBaseType is a basic data type. It is used to define the data types of signals and variables.","title":"SwBaseType"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwBaseType.base_type_encoding","text":"base_type_encoding: BaseTypeEncoding set the base type encoding of the SwBaseType","title":"base_type_encoding"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwBaseType.bit_length","text":"bit_length: Optional[int] get the bit length of the SwBaseType","title":"bit_length"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwBaseType.byte_order","text":"byte_order: Optional[ByteOrder] set the byte order of the SwBaseType The byte order is platform specific and should only be set when it is really needed.","title":"byte_order"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwBaseType.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwBaseType.mem_alignment","text":"mem_alignment: Optional[int] set the memory alignment of the SwBaseType The memory alignment describes the slignement in bits. Example: 8 means that the type is aligned to a byte. Since the memory alignment is platform specific, it should only be set when it is really needed.","title":"mem_alignment"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwBaseType.name","text":"name: str","title":"name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwBaseType.native_declaration","text":"native_declaration: Optional[str] set the native declaration of the SwBaseType The native declaration is a string that represents the type in the native programming language.","title":"native_declaration"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue","text":"a single value of a compound primitive data type (curve, map)","title":"SwValue"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue.V","text":"V: Type[SwValue_V] V: value is a numerical value","title":"V"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue.Vf","text":"Vf: Type[SwValue_Vf] VF: value is a numerical value","title":"Vf"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue.Vg","text":"Vg: Type[SwValue_Vg] VG: value is a group of values","title":"Vg"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue.Vt","text":"Vt: Type[SwValue_Vt] VT: value is a text value","title":"Vt"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue.VtfNumber","text":"VtfNumber: Type[SwValue_VtfNumber] VTF: value is a numerical value","title":"VtfNumber"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue.VtfText","text":"VtfText: Type[SwValue_VtfText]","title":"VtfText"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValueCont","text":"SwValueCont( sw_array_size: List[int], sw_values_phys: List[SwValue] ) Specification of the values of a compound primitive data type (curve, map)","title":"SwValueCont"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValueCont.sw_array_size","text":"sw_array_size: List[int] array size of the value content","title":"sw_array_size"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValueCont.sw_values_phys","text":"sw_values_phys: List[SwValue] list of SwValue objects in the value content","title":"sw_values_phys"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_V","text":"SwValue_V(value: float) Bases: SwValue value is a numerical value","title":"SwValue_V"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_V.value","text":"value: float the numerical value of the value","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_Vf","text":"SwValue_Vf(value: float) Bases: SwValue value is a numerical value","title":"SwValue_Vf"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_Vf.value","text":"value: float the numerical value of the value","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_Vg","text":"SwValue_Vg( values: List[SwValue], label: Optional[str] = None ) Bases: SwValue value is a group of values","title":"SwValue_Vg"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_Vg.label","text":"label: Optional[str] label of the group, if any","title":"label"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_Vg.values","text":"values: List[SwValue] list of SwValue objects in the group","title":"values"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_Vt","text":"SwValue_Vt(value: str) Bases: SwValue value is a text value","title":"SwValue_Vt"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_Vt.value","text":"value: str the text value of the value","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_VtfNumber","text":"SwValue_VtfNumber(value: float) Bases: SwValue value is a numerical value","title":"SwValue_VtfNumber"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_VtfNumber.value","text":"value: float the numerical value of the value","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_VtfText","text":"SwValue_VtfText(value: str) Bases: SwValue value is a text value","title":"SwValue_VtfText"},{"location":"datatype_api/#autosar_data.abstraction.datatype.SwValue_VtfText.value","text":"value: str the text value of the value","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.TabNoIntpEntry","text":"TabNoIntpEntry(*, value_in: float, value_out: float) a single entry of a CompuMethod whose category is TabNoInterpretation","title":"TabNoIntpEntry"},{"location":"datatype_api/#autosar_data.abstraction.datatype.TabNoIntpEntry.value_in","text":"value_in: float input value","title":"value_in"},{"location":"datatype_api/#autosar_data.abstraction.datatype.TabNoIntpEntry.value_out","text":"value_out: float output value","title":"value_out"},{"location":"datatype_api/#autosar_data.abstraction.datatype.TextTableEntry","text":"TextTableEntry(*, text: str, value: float)","title":"TextTableEntry"},{"location":"datatype_api/#autosar_data.abstraction.datatype.TextTableEntry.text","text":"text: str text","title":"text"},{"location":"datatype_api/#autosar_data.abstraction.datatype.TextTableEntry.value","text":"value: float value","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.TextValueSpecification","text":"TextValueSpecification( value: str, /, *, label: Optional[str] = None ) A text value specification This is a simple value specification that contains a single string value.","title":"TextValueSpecification"},{"location":"datatype_api/#autosar_data.abstraction.datatype.TextValueSpecification.label","text":"label: Optional[str] label of the text value specification, if any","title":"label"},{"location":"datatype_api/#autosar_data.abstraction.datatype.TextValueSpecification.value","text":"value: str the text value","title":"value"},{"location":"datatype_api/#autosar_data.abstraction.datatype.Unit","text":"Unit(element: Element) Unit represents a unit of measurement. Use [ ArPackage::create_unit ] to create a new unit.","title":"Unit"},{"location":"datatype_api/#autosar_data.abstraction.datatype.Unit.display_name","text":"display_name: Optional[str] display name of the unit","title":"display_name"},{"location":"datatype_api/#autosar_data.abstraction.datatype.Unit.element","text":"element: Element","title":"element"},{"location":"datatype_api/#autosar_data.abstraction.datatype.Unit.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/","text":"API Documentation: autosar_data.abstraction.ecu_configuration \u00b6 ecu_configuration \u00b6 EcucAnyReferenceDef module-attribute \u00b6 EcucAnyReferenceDef: TypeAlias = Union[ EcucReferenceDef, EcucUriReferenceDef, EcucForeignReferenceDef, EcucInstanceReferenceDef, EcucChoiceReferenceDef, ] EcucContainerDef module-attribute \u00b6 EcucContainerDef: TypeAlias = Union[ EcucParamConfContainerDef, EcucChoiceContainerDef ] EcucParameterDef module-attribute \u00b6 EcucParameterDef: TypeAlias = Union[ EcucAddInfoParamDef, EcucBooleanParamDef, EcucIntegerParamDef, EcucEnumerationParamDef, EcucFloatParamDef, EcucFunctionNameDef, EcucLinkerSymbolDef, EcucMultilineStringParamDef, EcucStringParamDef, ] EcucParameterValue module-attribute \u00b6 EcucParameterValue: TypeAlias = Union[ EcucNumericalParamValue, EcucTextualParamValue, EcucAddInfoParamValue, ] EcucAddInfoParamDef \u00b6 EcucAddInfoParamDef(element: Element) EcucAddInfoParamDef is used to specify the need for formated text in the ECU configuration value description element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] get or set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] get or set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. EcucAddInfoParamValue \u00b6 EcucAddInfoParamValue(element: Element) The EcucAddInfoParamValue holds descriptive text and takes the role of a parameter in the ECU configuration element instance-attribute \u00b6 element: Element EcucBooleanParamDef \u00b6 EcucBooleanParamDef(element: Element) EcucBooleanParamDef is used to specify a boolean parameter in the ECU configuration default_value instance-attribute \u00b6 default_value: Optional[bool] set the default value of the boolean parameter element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. EcucChoiceContainerDef \u00b6 EcucChoiceContainerDef(element: Element) Marker trait for container definitions The EcucChoiceContainerDef is used to define configuration containers that provide a choice between several EcucParamConfContainerDef element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute name instance-attribute \u00b6 name: str upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. choices \u00b6 choices() -> Iterator[EcucParamConfContainerDef] iterate over the choices in the container create_param_conf_container_def \u00b6 create_param_conf_container_def( name: str, ) -> EcucParamConfContainerDef create a new EcucParamConfContainerDef as one of the choices in this choice container EcucChoiceReferenceDef \u00b6 EcucChoiceReferenceDef(element: Element) The EcucChoiceReferenceDef specifies alternative references where only one of the specified references will be used in the ECU configuration. element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. add_destination \u00b6 add_destination(destination) -> None add a reference to a destination container destination_refs \u00b6 destination_refs() -> Iterator[EcucContainerDef] get the references to the destination containers EcucConfigurationClass \u00b6 EcucConfigurationClass provides the different configuration classes for Autosar configuration parameters Link instance-attribute \u00b6 Link: EcucConfigurationClass PostBuild instance-attribute \u00b6 PostBuild: EcucConfigurationClass PreCompile instance-attribute \u00b6 PreCompile: EcucConfigurationClass PublishedInformation instance-attribute \u00b6 PublishedInformation: EcucConfigurationClass EcucConfigurationVariant \u00b6 EcucConfigurationVariant provides the different configuration variants that can be used by the module definition. PreconfiguredConfiguration instance-attribute \u00b6 PreconfiguredConfiguration: EcucConfigurationVariant RecommendedConfiguration instance-attribute \u00b6 RecommendedConfiguration: EcucConfigurationVariant VariantLinkTime instance-attribute \u00b6 VariantLinkTime: EcucConfigurationVariant VariantPostBuild instance-attribute \u00b6 VariantPostBuild: EcucConfigurationVariant VariantPostBuildLoadable instance-attribute \u00b6 VariantPostBuildLoadable: EcucConfigurationVariant VariantPostBuildSelectable instance-attribute \u00b6 VariantPostBuildSelectable: EcucConfigurationVariant VariantPreCompile instance-attribute \u00b6 VariantPreCompile: EcucConfigurationVariant EcucContainerValue \u00b6 EcucContainerValue(element: Element) The EcucContainerValue is a container in the ECU configuration definition instance-attribute \u00b6 definition: Optional[EcucContainerDef] set the container definition reference definition_ref instance-attribute \u00b6 definition_ref: Optional[str] get the definition reference as a string This function is an alternative to definition() ; it is useful when the referenced definition is not loaded and can't be resolved. element instance-attribute \u00b6 element: Element index instance-attribute \u00b6 index: Optional[int] set the index of the container If the container definition has requiresIndex set to true , then the container must have an index. Otherwise the index is meaningless. name instance-attribute \u00b6 name: str create_add_info_param_value \u00b6 create_add_info_param_value( definition: EcucAddInfoParamDef, ) -> EcucAddInfoParamValue create a new EcucTextualParamValue in the container create_instance_reference \u00b6 create_instance_reference( definition: EcucInstanceReferenceDef, target_context: List[Element], target: Element, ) -> EcucInstanceReferenceValue create a new instance reference value in the container create_numerical_param_value \u00b6 create_numerical_param_value( definition: EcucParameterDef, value: str ) -> EcucNumericalParamValue create a new EcucNumericalParamValue in the container create_reference_value \u00b6 create_reference_value( definition: EcucReferenceDef, target: Element ) -> EcucReferenceValue create a new reference value in the container create_sub_container \u00b6 create_sub_container( name: str, definition: EcucContainerDef ) -> EcucContainerValue create a sub-container create_textual_param_value \u00b6 create_textual_param_value( definition: EcucParameterDef, value: str ) -> EcucTextualParamValue create a new EcucTextualParamValue in the container parameter_values \u00b6 parameter_values() -> Iterator[EcucParameterValue] iterate over the parameter values in the container reference_values \u00b6 reference_values() -> Iterator[ Union[EcucReferenceValue, EcucInstanceReferenceValue] ] iterate over the reference values in the container sub_containers \u00b6 sub_containers() -> Iterator[EcucContainerValue] iterate over the sub-containers in this container EcucDefinitionCollection \u00b6 EcucDefinitionCollection(element: Element) The EcucDefinitionCollection is a container for all module definitions in the ECU configuration element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str add_module_def \u00b6 add_module_def(module_def: EcucModuleDef) -> None add a reference to a module definition to the collection module_defs \u00b6 module_defs() -> Iterator[EcucModuleDef] iterate over all module definitions in the collection EcucDestinationUriDef \u00b6 EcucDestinationUriDef(element: Element) A EcucDestinationUriDef defines a target for an EcucUriReferenceDef element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str nesting_contract instance-attribute \u00b6 nesting_contract: Optional[ EcucDestinationUriNestingContract ] set the nesting contract for the destination uri containers \u00b6 containers() -> Iterator[ Union[EcucChoiceContainerDef, EcucParamConfContainerDef] ] iterate over all containers in the destination uri policy create_choice_container_def \u00b6 create_choice_container_def( name: str, ) -> EcucChoiceContainerDef create an EcucChoiceContainerDef in the destination uri policy create_param_conf_container_def \u00b6 create_param_conf_container_def( name: str, ) -> EcucParamConfContainerDef create an EcucParamConfContainerDef in the destination uri policy EcucDestinationUriDefSet \u00b6 EcucDestinationUriDefSet(element: Element) A EcucDestinationUriDefSet contains a list of EcucDestinationUriDef s element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_destination_uri_def \u00b6 create_destination_uri_def( name: str, contract: EcucDestinationUriNestingContract ) -> EcucDestinationUriDef create a new EcucDestinationUriDef destination_uri_defs \u00b6 destination_uri_defs() -> Iterator[EcucDestinationUriDef] iterate over all destination uri definitions in the set EcucDestinationUriNestingContract \u00b6 EcucDestinationUriNestingContract provides the different nesting contracts for destination URIs LeafOfTargetContainer instance-attribute \u00b6 LeafOfTargetContainer: EcucDestinationUriNestingContract TargetContainer instance-attribute \u00b6 TargetContainer: EcucDestinationUriNestingContract VertexOfTargetContainer instance-attribute \u00b6 VertexOfTargetContainer: EcucDestinationUriNestingContract EcucEnumerationLiteralDef \u00b6 EcucEnumerationLiteralDef(element: Element) EcucEnumerationLiteralDef is used to specify an enumeration literal in the ECU configuration element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str EcucEnumerationParamDef \u00b6 EcucEnumerationParamDef(element: Element) EcucEnumerationParamDef is used to specify an enumeration parameter in the ECU configuration default_value instance-attribute \u00b6 default_value: Optional[str] set the default value of the enumeration parameter Note: enumeration literals must be created first, since the default value must match one of the literals element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. create_enumeration_literal \u00b6 create_enumeration_literal( name, ) -> EcucEnumerationLiteralDef create a new enumeration literal enumeration_literals \u00b6 enumeration_literals() -> Iterator[ EcucEnumerationLiteralDef ] iterate over all enumeration literals EcucFloatParamDef \u00b6 EcucFloatParamDef(element: Element) EcucFloatParamDef is used to specify a float parameter in the ECU configuration default_value instance-attribute \u00b6 default_value: Optional[float] set the default value of the float parameter element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute max instance-attribute \u00b6 max: Optional[float] set the max value of the float parameter min instance-attribute \u00b6 min: Optional[float] set the min value of the float parameter multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. EcucForeignReferenceDef \u00b6 EcucForeignReferenceDef(element: Element) marker trait for all reference definitions The EcucForeignReferenceDef specifies a reference to an XML description of an entity described in another AUTOSAR template. destination_type instance-attribute \u00b6 destination_type: Optional[str] set the destination type of the reference definition element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. EcucFunctionNameDef \u00b6 EcucFunctionNameDef(element: Element) EcucFunctionNameDef is used to specify a function name parameter in the ECU configuration default_value instance-attribute \u00b6 default_value: Optional[str] default value of the string parameter element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute max_length instance-attribute \u00b6 max_length: Optional[int] max length of the string parameter min_length instance-attribute \u00b6 min_length: Optional[int] min length of the string parameter multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. regular_expression instance-attribute \u00b6 regular_expression: Optional[str] regular expression for the string parameter requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. EcucInstanceReferenceDef \u00b6 EcucInstanceReferenceDef(element: Element) The EcucInstanceReferenceDef specifies a reference to an XML description of an entity described in another AUTOSAR template using INSTANCE REFERENCE semantics. destination_context instance-attribute \u00b6 destination_context: Optional[str] set the destination context of the reference definition The destination context is a string of autosar element names separated by spaces. Additionally, the ' ' character can be used to indicate multiple occurrences of the previous element. E.g. \"SW-COMPONENT-PROTOTYPE R-PORT-PROTOTYPE destination_type instance-attribute \u00b6 destination_type: Optional[str] set the destination type of the reference definition element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. EcucInstanceReferenceValue \u00b6 EcucInstanceReferenceValue(element: Element) An EcucInstanceReferenceValue provides the mechanism to reference an instance of a prototype definition instance-attribute \u00b6 definition: Optional[EcucInstanceReferenceDef] set the parameter definition reference definition_ref instance-attribute \u00b6 definition_ref: Optional[str] get the parameter definition reference as a string This function is an alternative to definition() ; it is useful when the referenced definition is not loaded and can't be resolved. element instance-attribute \u00b6 element: Element index instance-attribute \u00b6 index: Optional[int] set the index of the reference If the reference definition has requiresIndex set to true , then the reference must have an index. Otherwise the index is meaningless. is_auto_value instance-attribute \u00b6 is_auto_value: Optional[bool] set the isAutoValue flag If the reference definition has withAuto set to true , then the reference is allowed to have an auto value. target instance-attribute \u00b6 target: Optional[Tuple[List[Element], Element]] Set the target of the reference An instance reference targets a specific instance of a prototype. In order to uniquely identify the target, the target context is required. The target context is a list of elements that are the parent elements of the target element. The instance reference definition specifies which context elements are required. EcucIntegerParamDef \u00b6 EcucIntegerParamDef(element: Element) EcucIntegerParamDef is used to specify an integer parameter in the ECU configuration default_value instance-attribute \u00b6 default_value: Optional[int] set the default value of the integer parameter element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute max instance-attribute \u00b6 max: Optional[int] set the max value of the integer parameter min instance-attribute \u00b6 min: Optional[int] set the min value of the integer parameter multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. EcucLinkerSymbolDef \u00b6 EcucLinkerSymbolDef(element: Element) EcucLinkerSymbolDef is used to specify a linker symbol parameter in the ECU configuration default_value instance-attribute \u00b6 default_value: Optional[str] default value of the string parameter element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute max_length instance-attribute \u00b6 max_length: Optional[int] max length of the string parameter min_length instance-attribute \u00b6 min_length: Optional[int] min length of the string parameter multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. regular_expression instance-attribute \u00b6 regular_expression: Optional[str] regular expression for the string parameter requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. EcucModuleConfigurationValues \u00b6 EcucModuleConfigurationValues(element: Element) The EcucModuleConfigurationValues is a container for the configuration of a single base software module definition instance-attribute \u00b6 definition: Optional[EcucModuleDef] set the module definition reference definition_ref instance-attribute \u00b6 definition_ref: Optional[str] get the definition reference as a string This function is an alternative to definition() ; it is useful when the referenced definition is not loaded and can't be resolved. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str container_values \u00b6 container_values() -> Iterator[EcucContainerValue] create an iterator over the container values in the module configuration create_container_value \u00b6 create_container_value( name: str, definition: EcucContainerDef ) -> EcucContainerValue Create a new EcucContainerValue in the module configuration EcucModuleDef \u00b6 EcucModuleDef(element: Element) The EcucModuleDef is a container for the definition of a single base software module api_service_prefix instance-attribute \u00b6 api_service_prefix: Optional[str] get or set the apiServicePrefix for the module for CDD modules the short name of the module is always \"CDD\", so this attribute is needed to define the prefix for the API services category instance-attribute \u00b6 category: Optional[EcucModuleDefCategory] get or set the category of the module definition element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute name instance-attribute \u00b6 name: str post_build_variant_support instance-attribute \u00b6 post_build_variant_support: Optional[bool] get or set the post build variant support attribute refined_module_def instance-attribute \u00b6 refined_module_def: Optional[EcucModuleDef] get or set the reference to a refined standard module This reference is only used if the category is VendorSpecificModuleDefinition supported_config_variants instance-attribute \u00b6 supported_config_variants: List[EcucConfigurationVariant] set the supported configuration variants for the module upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. containers \u00b6 containers() -> Iterator[ Union[EcucChoiceContainerDef, EcucParamConfContainerDef] ] iterate over all containers in the module create_choice_container_def \u00b6 create_choice_container_def( name: str, ) -> EcucChoiceContainerDef create a new EcucChoiceContainerDef in the module create_param_conf_container_def \u00b6 create_param_conf_container_def( name: str, ) -> EcucParamConfContainerDef create a new EcucParamConfContainerDef in the module EcucModuleDefCategory \u00b6 The EcucModuleDefCategory represents the possible category values for a module definition StandardizedModuleDefinition instance-attribute \u00b6 StandardizedModuleDefinition: EcucModuleDefCategory VendorSpecificModuleDefinition instance-attribute \u00b6 VendorSpecificModuleDefinition: EcucModuleDefCategory EcucMultilineStringParamDef \u00b6 EcucMultilineStringParamDef(element: Element) EcucMultilineStringParamDef is used to specify a multiline string parameter in the ECU configuration default_value instance-attribute \u00b6 default_value: Optional[str] default value of the string parameter element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute max_length instance-attribute \u00b6 max_length: Optional[int] max length of the string parameter min_length instance-attribute \u00b6 min_length: Optional[int] min length of the string parameter multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. regular_expression instance-attribute \u00b6 regular_expression: Optional[str] regular expression for the string parameter requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. EcucNumericalParamValue \u00b6 EcucNumericalParamValue(element: Element) The EcucNumericalParamValue holds a numerical value and can represent boolean, float or int parameter definitions. Internally this value is stored as a string; in additon to the value() function, there are also value_bool(), value_int() and value_float() functions, which parse the string and should be used as appropriate. definition instance-attribute \u00b6 definition: Optional[ Union[ EcucBooleanParamDef, EcucFloatParamDef, EcucIntegerParamDef, ] ] set the parameter definition reference definition_ref instance-attribute \u00b6 definition_ref: Optional[str] get the parameter definition reference as a string This function is an alternative to definition() ; it is useful when the referenced definition is not loaded and can't be resolved. element instance-attribute \u00b6 element: Element index instance-attribute \u00b6 index: Optional[int] set the index of the parameter If the parameter definition has requiresIndex set to true , then the parameter must have an index. Otherwise the index is meaningless. is_auto_value instance-attribute \u00b6 is_auto_value: Optional[bool] set the isAutoValue flag If the parameter definition has withAuto set to true , then the parameter is allowed to have an auto value. value instance-attribute \u00b6 value: Optional[str] get or set the numerical value as a string value_bool instance-attribute \u00b6 value_bool: Optional[bool] get the numerical value as a boolean value_float instance-attribute \u00b6 value_float: Optional[float] get the numerical value as a float value_int instance-attribute \u00b6 value_int: Optional[int] get the numerical value as an integer EcucParamConfContainerDef \u00b6 EcucParamConfContainerDef(element: Element) The EcucParamConfContainerDef is used to define configuration containers element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute name instance-attribute \u00b6 name: str upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. create_add_info_param_def \u00b6 create_add_info_param_def( name: str, origin: str ) -> EcucAddInfoParamDef create a new EcucAddInfoParamDef in the container create_boolean_param_def \u00b6 create_boolean_param_def( name: str, origin: str ) -> EcucBooleanParamDef create a new EcucBooleanParamDef in the container create_choice_container_def \u00b6 create_choice_container_def( name: str, ) -> EcucChoiceContainerDef create a new EcucChoiceContainerDef as a sub-container create_choice_reference_def \u00b6 create_choice_reference_def( name: str, origin: str ) -> EcucChoiceReferenceDef create a new EcucChoiceReferenceDef in the container create_enumeration_param_def \u00b6 create_enumeration_param_def( name: str, origin: str ) -> EcucEnumerationParamDef create a new EcucEnumerationParamDef in the container create_float_param_def \u00b6 create_float_param_def( name: str, origin: str ) -> EcucFloatParamDef create a new EcucFloatParamDef in the container create_foreign_reference_def \u00b6 create_foreign_reference_def( name: str, origin: str ) -> EcucForeignReferenceDef create a new EcucForeignReferenceDef in the container create_function_name_param_def \u00b6 create_function_name_param_def( name: str, origin: str ) -> EcucFunctionNameDef create a new EcucFunctionNameDef in the container create_instance_reference_def \u00b6 create_instance_reference_def( name: str, origin: str ) -> EcucInstanceReferenceDef create a new EcucInstanceReferenceDef in the container create_integer_param_def \u00b6 create_integer_param_def( name: str, origin: str ) -> EcucIntegerParamDef create a new EcucIntegerParamDef in the container create_linker_symbol_param_def \u00b6 create_linker_symbol_param_def( name: str, origin: str ) -> EcucLinkerSymbolDef create a new EcucLinkerSymbolDef in the container create_multiline_string_param_def \u00b6 create_multiline_string_param_def( name: str, origin: str ) -> EcucMultilineStringParamDef create a new EcucMultilineStringParamDef in the container create_param_conf_container_def \u00b6 create_param_conf_container_def( name: str, ) -> EcucParamConfContainerDef create a new EcucParamConfContainerDef as a sub-container create_reference_def \u00b6 create_reference_def( name: str, origin: str ) -> EcucReferenceDef create a new EcucReferenceDef in the container create_string_param_def \u00b6 create_string_param_def( name: str, origin: str ) -> EcucStringParamDef create a new EcucStringParamDef in the container create_uri_reference_def \u00b6 create_uri_reference_def( name: str, origin: str ) -> EcucUriReferenceDef create a new EcucUriReferenceDef in the container parameters \u00b6 parameters() -> Iterator[EcucParameterDef] get the parameters in the container references \u00b6 references() -> Iterator[EcucAnyReferenceDef] get the references in the container sub_containers \u00b6 sub_containers() -> Iterator[EcucContainerDef] iterate over the sub-containers EcucReferenceDef \u00b6 EcucReferenceDef(element: Element) The EcuReferenceDef specifies references between parameters in the ECU configuration. destination instance-attribute \u00b6 destination: Optional[EcucContainerDef] destination container of the reference element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. EcucReferenceValue \u00b6 EcucReferenceValue(element: Element) An EcucReferenceValue allows the ecu tonfiguration to refer to any identifiable element in the Autosar model definition instance-attribute \u00b6 definition: Optional[EcucReferenceDef] set the parameter definition reference definition_ref instance-attribute \u00b6 definition_ref: Optional[str] get the referenced definition ref as a string This function is an alternative to definition() ; it is useful when the referenced definition is not loaded and can't be resolved. element instance-attribute \u00b6 element: Element index instance-attribute \u00b6 index: Optional[int] set the index of the reference If the reference definition has requiresIndex set to true , then the reference must have an index. Otherwise the index is meaningless. is_auto_value instance-attribute \u00b6 is_auto_value: Optional[bool] set the isAutoValue flag If the reference definition has withAuto set to true , then the reference is allowed to have an auto value. target instance-attribute \u00b6 target: Optional[Element] Set the target of the reference EcucStringParamDef \u00b6 EcucStringParamDef(element: Element) EcucStringParamDef is used to specify a string parameter in the ECU configuration default_value instance-attribute \u00b6 default_value: Optional[str] default value of the string parameter element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute max_length instance-attribute \u00b6 max_length: Optional[int] max length of the string parameter min_length instance-attribute \u00b6 min_length: Optional[int] min length of the string parameter multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. regular_expression instance-attribute \u00b6 regular_expression: Optional[str] regular expression for the string parameter requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. EcucTextualParamValue \u00b6 EcucTextualParamValue(element: Element) The EcucTextualParamValue holds a string value and can represent a enumeration, string, multi-line string, function name or linker symbol parameter definition. definition instance-attribute \u00b6 definition: Optional[EcucParameterDef] set the parameter definition reference definition_ref instance-attribute \u00b6 definition_ref: Optional[str] get the parameter definition reference as a string This function is an alternative to definition() ; it is useful when the referenced definition is not loaded and can't be resolved. element instance-attribute \u00b6 element: Element index instance-attribute \u00b6 index: Optional[int] set the index of the parameter If the parameter definition has requiresIndex set to true , then the parameter must have an index. Otherwise the index is meaningless. is_auto_value instance-attribute \u00b6 is_auto_value: Optional[bool] set the isAutoValue flag If the parameter definition has withAuto set to true , then the parameter is allowed to have an auto value. value instance-attribute \u00b6 value: str the textual value of the parameter EcucUriReferenceDef \u00b6 EcucUriReferenceDef(element: Element) The EcucUriReferenceDef defines a reference with a destination that is specified via a destinationUri destination_uri instance-attribute \u00b6 destination_uri: Optional[EcucDestinationUriDef] set the destination uri of the reference definition element instance-attribute \u00b6 element: Element lower_multiplicity instance-attribute \u00b6 lower_multiplicity: Optional[int] get or set the lower multiplicity attribute multiplicity_config_classes instance-attribute \u00b6 multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION. name instance-attribute \u00b6 name: str origin instance-attribute \u00b6 origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3' post_build_variant_multiplicity instance-attribute \u00b6 post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants. post_build_variant_value instance-attribute \u00b6 post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants. requires_index instance-attribute \u00b6 requires_index: Optional[bool] get or set the requiresIndex attribute upper_multiplicity instance-attribute \u00b6 upper_multiplicity: Optional[int] get or set the upper multiplicity attribute upper_multiplicity_infinite instance-attribute \u00b6 upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used. value_config_classes instance-attribute \u00b6 value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used. with_auto instance-attribute \u00b6 with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true. EcucValueCollection \u00b6 EcucValueCollection(element: Element) EcucValueCollection collects references to all the separate modules that form the ECU configuration ecu_extract_reference instance-attribute \u00b6 ecu_extract_reference: Optional[System] Set the ecu extract reference, which links a System to the ECU configuration element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str add_module_configuration \u00b6 add_module_configuration( module_configuration: EcucModuleConfigurationValues, ) -> None Add a reference to a module configuration to the collection module_configurations \u00b6 module_configurations() -> Iterator[ EcucModuleConfigurationValues ] Get the module configurations in the collection","title":"ECU configuration"},{"location":"ecu_configuration_api/#api-documentation-autosar_dataabstractionecu_configuration","text":"","title":"API Documentation: autosar_data.abstraction.ecu_configuration"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration","text":"","title":"ecu_configuration"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAnyReferenceDef","text":"EcucAnyReferenceDef: TypeAlias = Union[ EcucReferenceDef, EcucUriReferenceDef, EcucForeignReferenceDef, EcucInstanceReferenceDef, EcucChoiceReferenceDef, ]","title":"EcucAnyReferenceDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerDef","text":"EcucContainerDef: TypeAlias = Union[ EcucParamConfContainerDef, EcucChoiceContainerDef ]","title":"EcucContainerDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParameterDef","text":"EcucParameterDef: TypeAlias = Union[ EcucAddInfoParamDef, EcucBooleanParamDef, EcucIntegerParamDef, EcucEnumerationParamDef, EcucFloatParamDef, EcucFunctionNameDef, EcucLinkerSymbolDef, EcucMultilineStringParamDef, EcucStringParamDef, ]","title":"EcucParameterDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParameterValue","text":"EcucParameterValue: TypeAlias = Union[ EcucNumericalParamValue, EcucTextualParamValue, EcucAddInfoParamValue, ]","title":"EcucParameterValue"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef","text":"EcucAddInfoParamDef(element: Element) EcucAddInfoParamDef is used to specify the need for formated text in the ECU configuration value description","title":"EcucAddInfoParamDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] get or set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef.origin","text":"origin: Optional[str] get or set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamValue","text":"EcucAddInfoParamValue(element: Element) The EcucAddInfoParamValue holds descriptive text and takes the role of a parameter in the ECU configuration","title":"EcucAddInfoParamValue"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucAddInfoParamValue.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef","text":"EcucBooleanParamDef(element: Element) EcucBooleanParamDef is used to specify a boolean parameter in the ECU configuration","title":"EcucBooleanParamDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.default_value","text":"default_value: Optional[bool] set the default value of the boolean parameter","title":"default_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucBooleanParamDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceContainerDef","text":"EcucChoiceContainerDef(element: Element) Marker trait for container definitions The EcucChoiceContainerDef is used to define configuration containers that provide a choice between several EcucParamConfContainerDef","title":"EcucChoiceContainerDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceContainerDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceContainerDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceContainerDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceContainerDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceContainerDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceContainerDef.choices","text":"choices() -> Iterator[EcucParamConfContainerDef] iterate over the choices in the container","title":"choices"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceContainerDef.create_param_conf_container_def","text":"create_param_conf_container_def( name: str, ) -> EcucParamConfContainerDef create a new EcucParamConfContainerDef as one of the choices in this choice container","title":"create_param_conf_container_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef","text":"EcucChoiceReferenceDef(element: Element) The EcucChoiceReferenceDef specifies alternative references where only one of the specified references will be used in the ECU configuration.","title":"EcucChoiceReferenceDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.add_destination","text":"add_destination(destination) -> None add a reference to a destination container","title":"add_destination"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucChoiceReferenceDef.destination_refs","text":"destination_refs() -> Iterator[EcucContainerDef] get the references to the destination containers","title":"destination_refs"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationClass","text":"EcucConfigurationClass provides the different configuration classes for Autosar configuration parameters","title":"EcucConfigurationClass"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationClass.Link","text":"Link: EcucConfigurationClass","title":"Link"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationClass.PostBuild","text":"PostBuild: EcucConfigurationClass","title":"PostBuild"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationClass.PreCompile","text":"PreCompile: EcucConfigurationClass","title":"PreCompile"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationClass.PublishedInformation","text":"PublishedInformation: EcucConfigurationClass","title":"PublishedInformation"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationVariant","text":"EcucConfigurationVariant provides the different configuration variants that can be used by the module definition.","title":"EcucConfigurationVariant"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationVariant.PreconfiguredConfiguration","text":"PreconfiguredConfiguration: EcucConfigurationVariant","title":"PreconfiguredConfiguration"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationVariant.RecommendedConfiguration","text":"RecommendedConfiguration: EcucConfigurationVariant","title":"RecommendedConfiguration"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationVariant.VariantLinkTime","text":"VariantLinkTime: EcucConfigurationVariant","title":"VariantLinkTime"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationVariant.VariantPostBuild","text":"VariantPostBuild: EcucConfigurationVariant","title":"VariantPostBuild"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationVariant.VariantPostBuildLoadable","text":"VariantPostBuildLoadable: EcucConfigurationVariant","title":"VariantPostBuildLoadable"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationVariant.VariantPostBuildSelectable","text":"VariantPostBuildSelectable: EcucConfigurationVariant","title":"VariantPostBuildSelectable"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucConfigurationVariant.VariantPreCompile","text":"VariantPreCompile: EcucConfigurationVariant","title":"VariantPreCompile"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue","text":"EcucContainerValue(element: Element) The EcucContainerValue is a container in the ECU configuration","title":"EcucContainerValue"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.definition","text":"definition: Optional[EcucContainerDef] set the container definition reference","title":"definition"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.definition_ref","text":"definition_ref: Optional[str] get the definition reference as a string This function is an alternative to definition() ; it is useful when the referenced definition is not loaded and can't be resolved.","title":"definition_ref"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.index","text":"index: Optional[int] set the index of the container If the container definition has requiresIndex set to true , then the container must have an index. Otherwise the index is meaningless.","title":"index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.create_add_info_param_value","text":"create_add_info_param_value( definition: EcucAddInfoParamDef, ) -> EcucAddInfoParamValue create a new EcucTextualParamValue in the container","title":"create_add_info_param_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.create_instance_reference","text":"create_instance_reference( definition: EcucInstanceReferenceDef, target_context: List[Element], target: Element, ) -> EcucInstanceReferenceValue create a new instance reference value in the container","title":"create_instance_reference"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.create_numerical_param_value","text":"create_numerical_param_value( definition: EcucParameterDef, value: str ) -> EcucNumericalParamValue create a new EcucNumericalParamValue in the container","title":"create_numerical_param_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.create_reference_value","text":"create_reference_value( definition: EcucReferenceDef, target: Element ) -> EcucReferenceValue create a new reference value in the container","title":"create_reference_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.create_sub_container","text":"create_sub_container( name: str, definition: EcucContainerDef ) -> EcucContainerValue create a sub-container","title":"create_sub_container"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.create_textual_param_value","text":"create_textual_param_value( definition: EcucParameterDef, value: str ) -> EcucTextualParamValue create a new EcucTextualParamValue in the container","title":"create_textual_param_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.parameter_values","text":"parameter_values() -> Iterator[EcucParameterValue] iterate over the parameter values in the container","title":"parameter_values"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.reference_values","text":"reference_values() -> Iterator[ Union[EcucReferenceValue, EcucInstanceReferenceValue] ] iterate over the reference values in the container","title":"reference_values"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucContainerValue.sub_containers","text":"sub_containers() -> Iterator[EcucContainerValue] iterate over the sub-containers in this container","title":"sub_containers"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDefinitionCollection","text":"EcucDefinitionCollection(element: Element) The EcucDefinitionCollection is a container for all module definitions in the ECU configuration","title":"EcucDefinitionCollection"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDefinitionCollection.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDefinitionCollection.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDefinitionCollection.add_module_def","text":"add_module_def(module_def: EcucModuleDef) -> None add a reference to a module definition to the collection","title":"add_module_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDefinitionCollection.module_defs","text":"module_defs() -> Iterator[EcucModuleDef] iterate over all module definitions in the collection","title":"module_defs"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriDef","text":"EcucDestinationUriDef(element: Element) A EcucDestinationUriDef defines a target for an EcucUriReferenceDef","title":"EcucDestinationUriDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriDef.nesting_contract","text":"nesting_contract: Optional[ EcucDestinationUriNestingContract ] set the nesting contract for the destination uri","title":"nesting_contract"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriDef.containers","text":"containers() -> Iterator[ Union[EcucChoiceContainerDef, EcucParamConfContainerDef] ] iterate over all containers in the destination uri policy","title":"containers"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriDef.create_choice_container_def","text":"create_choice_container_def( name: str, ) -> EcucChoiceContainerDef create an EcucChoiceContainerDef in the destination uri policy","title":"create_choice_container_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriDef.create_param_conf_container_def","text":"create_param_conf_container_def( name: str, ) -> EcucParamConfContainerDef create an EcucParamConfContainerDef in the destination uri policy","title":"create_param_conf_container_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriDefSet","text":"EcucDestinationUriDefSet(element: Element) A EcucDestinationUriDefSet contains a list of EcucDestinationUriDef s","title":"EcucDestinationUriDefSet"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriDefSet.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriDefSet.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriDefSet.create_destination_uri_def","text":"create_destination_uri_def( name: str, contract: EcucDestinationUriNestingContract ) -> EcucDestinationUriDef create a new EcucDestinationUriDef","title":"create_destination_uri_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriDefSet.destination_uri_defs","text":"destination_uri_defs() -> Iterator[EcucDestinationUriDef] iterate over all destination uri definitions in the set","title":"destination_uri_defs"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriNestingContract","text":"EcucDestinationUriNestingContract provides the different nesting contracts for destination URIs","title":"EcucDestinationUriNestingContract"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriNestingContract.LeafOfTargetContainer","text":"LeafOfTargetContainer: EcucDestinationUriNestingContract","title":"LeafOfTargetContainer"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriNestingContract.TargetContainer","text":"TargetContainer: EcucDestinationUriNestingContract","title":"TargetContainer"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucDestinationUriNestingContract.VertexOfTargetContainer","text":"VertexOfTargetContainer: EcucDestinationUriNestingContract","title":"VertexOfTargetContainer"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationLiteralDef","text":"EcucEnumerationLiteralDef(element: Element) EcucEnumerationLiteralDef is used to specify an enumeration literal in the ECU configuration","title":"EcucEnumerationLiteralDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationLiteralDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationLiteralDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef","text":"EcucEnumerationParamDef(element: Element) EcucEnumerationParamDef is used to specify an enumeration parameter in the ECU configuration","title":"EcucEnumerationParamDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.default_value","text":"default_value: Optional[str] set the default value of the enumeration parameter Note: enumeration literals must be created first, since the default value must match one of the literals","title":"default_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.create_enumeration_literal","text":"create_enumeration_literal( name, ) -> EcucEnumerationLiteralDef create a new enumeration literal","title":"create_enumeration_literal"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucEnumerationParamDef.enumeration_literals","text":"enumeration_literals() -> Iterator[ EcucEnumerationLiteralDef ] iterate over all enumeration literals","title":"enumeration_literals"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef","text":"EcucFloatParamDef(element: Element) EcucFloatParamDef is used to specify a float parameter in the ECU configuration","title":"EcucFloatParamDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.default_value","text":"default_value: Optional[float] set the default value of the float parameter","title":"default_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.max","text":"max: Optional[float] set the max value of the float parameter","title":"max"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.min","text":"min: Optional[float] set the min value of the float parameter","title":"min"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFloatParamDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef","text":"EcucForeignReferenceDef(element: Element) marker trait for all reference definitions The EcucForeignReferenceDef specifies a reference to an XML description of an entity described in another AUTOSAR template.","title":"EcucForeignReferenceDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.destination_type","text":"destination_type: Optional[str] set the destination type of the reference definition","title":"destination_type"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucForeignReferenceDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef","text":"EcucFunctionNameDef(element: Element) EcucFunctionNameDef is used to specify a function name parameter in the ECU configuration","title":"EcucFunctionNameDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.default_value","text":"default_value: Optional[str] default value of the string parameter","title":"default_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.max_length","text":"max_length: Optional[int] max length of the string parameter","title":"max_length"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.min_length","text":"min_length: Optional[int] min length of the string parameter","title":"min_length"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.regular_expression","text":"regular_expression: Optional[str] regular expression for the string parameter","title":"regular_expression"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucFunctionNameDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef","text":"EcucInstanceReferenceDef(element: Element) The EcucInstanceReferenceDef specifies a reference to an XML description of an entity described in another AUTOSAR template using INSTANCE REFERENCE semantics.","title":"EcucInstanceReferenceDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.destination_context","text":"destination_context: Optional[str] set the destination context of the reference definition The destination context is a string of autosar element names separated by spaces. Additionally, the ' ' character can be used to indicate multiple occurrences of the previous element. E.g. \"SW-COMPONENT-PROTOTYPE R-PORT-PROTOTYPE","title":"destination_context"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.destination_type","text":"destination_type: Optional[str] set the destination type of the reference definition","title":"destination_type"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceValue","text":"EcucInstanceReferenceValue(element: Element) An EcucInstanceReferenceValue provides the mechanism to reference an instance of a prototype","title":"EcucInstanceReferenceValue"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceValue.definition","text":"definition: Optional[EcucInstanceReferenceDef] set the parameter definition reference","title":"definition"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceValue.definition_ref","text":"definition_ref: Optional[str] get the parameter definition reference as a string This function is an alternative to definition() ; it is useful when the referenced definition is not loaded and can't be resolved.","title":"definition_ref"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceValue.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceValue.index","text":"index: Optional[int] set the index of the reference If the reference definition has requiresIndex set to true , then the reference must have an index. Otherwise the index is meaningless.","title":"index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceValue.is_auto_value","text":"is_auto_value: Optional[bool] set the isAutoValue flag If the reference definition has withAuto set to true , then the reference is allowed to have an auto value.","title":"is_auto_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucInstanceReferenceValue.target","text":"target: Optional[Tuple[List[Element], Element]] Set the target of the reference An instance reference targets a specific instance of a prototype. In order to uniquely identify the target, the target context is required. The target context is a list of elements that are the parent elements of the target element. The instance reference definition specifies which context elements are required.","title":"target"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef","text":"EcucIntegerParamDef(element: Element) EcucIntegerParamDef is used to specify an integer parameter in the ECU configuration","title":"EcucIntegerParamDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.default_value","text":"default_value: Optional[int] set the default value of the integer parameter","title":"default_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.max","text":"max: Optional[int] set the max value of the integer parameter","title":"max"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.min","text":"min: Optional[int] set the min value of the integer parameter","title":"min"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucIntegerParamDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef","text":"EcucLinkerSymbolDef(element: Element) EcucLinkerSymbolDef is used to specify a linker symbol parameter in the ECU configuration","title":"EcucLinkerSymbolDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.default_value","text":"default_value: Optional[str] default value of the string parameter","title":"default_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.max_length","text":"max_length: Optional[int] max length of the string parameter","title":"max_length"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.min_length","text":"min_length: Optional[int] min length of the string parameter","title":"min_length"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.regular_expression","text":"regular_expression: Optional[str] regular expression for the string parameter","title":"regular_expression"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucLinkerSymbolDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleConfigurationValues","text":"EcucModuleConfigurationValues(element: Element) The EcucModuleConfigurationValues is a container for the configuration of a single base software module","title":"EcucModuleConfigurationValues"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleConfigurationValues.definition","text":"definition: Optional[EcucModuleDef] set the module definition reference","title":"definition"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleConfigurationValues.definition_ref","text":"definition_ref: Optional[str] get the definition reference as a string This function is an alternative to definition() ; it is useful when the referenced definition is not loaded and can't be resolved.","title":"definition_ref"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleConfigurationValues.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleConfigurationValues.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleConfigurationValues.container_values","text":"container_values() -> Iterator[EcucContainerValue] create an iterator over the container values in the module configuration","title":"container_values"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleConfigurationValues.create_container_value","text":"create_container_value( name: str, definition: EcucContainerDef ) -> EcucContainerValue Create a new EcucContainerValue in the module configuration","title":"create_container_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef","text":"EcucModuleDef(element: Element) The EcucModuleDef is a container for the definition of a single base software module","title":"EcucModuleDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.api_service_prefix","text":"api_service_prefix: Optional[str] get or set the apiServicePrefix for the module for CDD modules the short name of the module is always \"CDD\", so this attribute is needed to define the prefix for the API services","title":"api_service_prefix"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.category","text":"category: Optional[EcucModuleDefCategory] get or set the category of the module definition","title":"category"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.post_build_variant_support","text":"post_build_variant_support: Optional[bool] get or set the post build variant support attribute","title":"post_build_variant_support"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.refined_module_def","text":"refined_module_def: Optional[EcucModuleDef] get or set the reference to a refined standard module This reference is only used if the category is VendorSpecificModuleDefinition","title":"refined_module_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.supported_config_variants","text":"supported_config_variants: List[EcucConfigurationVariant] set the supported configuration variants for the module","title":"supported_config_variants"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.containers","text":"containers() -> Iterator[ Union[EcucChoiceContainerDef, EcucParamConfContainerDef] ] iterate over all containers in the module","title":"containers"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.create_choice_container_def","text":"create_choice_container_def( name: str, ) -> EcucChoiceContainerDef create a new EcucChoiceContainerDef in the module","title":"create_choice_container_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDef.create_param_conf_container_def","text":"create_param_conf_container_def( name: str, ) -> EcucParamConfContainerDef create a new EcucParamConfContainerDef in the module","title":"create_param_conf_container_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDefCategory","text":"The EcucModuleDefCategory represents the possible category values for a module definition","title":"EcucModuleDefCategory"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDefCategory.StandardizedModuleDefinition","text":"StandardizedModuleDefinition: EcucModuleDefCategory","title":"StandardizedModuleDefinition"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucModuleDefCategory.VendorSpecificModuleDefinition","text":"VendorSpecificModuleDefinition: EcucModuleDefCategory","title":"VendorSpecificModuleDefinition"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef","text":"EcucMultilineStringParamDef(element: Element) EcucMultilineStringParamDef is used to specify a multiline string parameter in the ECU configuration","title":"EcucMultilineStringParamDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.default_value","text":"default_value: Optional[str] default value of the string parameter","title":"default_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.max_length","text":"max_length: Optional[int] max length of the string parameter","title":"max_length"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.min_length","text":"min_length: Optional[int] min length of the string parameter","title":"min_length"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.regular_expression","text":"regular_expression: Optional[str] regular expression for the string parameter","title":"regular_expression"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucMultilineStringParamDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucNumericalParamValue","text":"EcucNumericalParamValue(element: Element) The EcucNumericalParamValue holds a numerical value and can represent boolean, float or int parameter definitions. Internally this value is stored as a string; in additon to the value() function, there are also value_bool(), value_int() and value_float() functions, which parse the string and should be used as appropriate.","title":"EcucNumericalParamValue"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucNumericalParamValue.definition","text":"definition: Optional[ Union[ EcucBooleanParamDef, EcucFloatParamDef, EcucIntegerParamDef, ] ] set the parameter definition reference","title":"definition"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucNumericalParamValue.definition_ref","text":"definition_ref: Optional[str] get the parameter definition reference as a string This function is an alternative to definition() ; it is useful when the referenced definition is not loaded and can't be resolved.","title":"definition_ref"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucNumericalParamValue.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucNumericalParamValue.index","text":"index: Optional[int] set the index of the parameter If the parameter definition has requiresIndex set to true , then the parameter must have an index. Otherwise the index is meaningless.","title":"index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucNumericalParamValue.is_auto_value","text":"is_auto_value: Optional[bool] set the isAutoValue flag If the parameter definition has withAuto set to true , then the parameter is allowed to have an auto value.","title":"is_auto_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucNumericalParamValue.value","text":"value: Optional[str] get or set the numerical value as a string","title":"value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucNumericalParamValue.value_bool","text":"value_bool: Optional[bool] get the numerical value as a boolean","title":"value_bool"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucNumericalParamValue.value_float","text":"value_float: Optional[float] get the numerical value as a float","title":"value_float"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucNumericalParamValue.value_int","text":"value_int: Optional[int] get the numerical value as an integer","title":"value_int"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef","text":"EcucParamConfContainerDef(element: Element) The EcucParamConfContainerDef is used to define configuration containers","title":"EcucParamConfContainerDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_add_info_param_def","text":"create_add_info_param_def( name: str, origin: str ) -> EcucAddInfoParamDef create a new EcucAddInfoParamDef in the container","title":"create_add_info_param_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_boolean_param_def","text":"create_boolean_param_def( name: str, origin: str ) -> EcucBooleanParamDef create a new EcucBooleanParamDef in the container","title":"create_boolean_param_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_choice_container_def","text":"create_choice_container_def( name: str, ) -> EcucChoiceContainerDef create a new EcucChoiceContainerDef as a sub-container","title":"create_choice_container_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_choice_reference_def","text":"create_choice_reference_def( name: str, origin: str ) -> EcucChoiceReferenceDef create a new EcucChoiceReferenceDef in the container","title":"create_choice_reference_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_enumeration_param_def","text":"create_enumeration_param_def( name: str, origin: str ) -> EcucEnumerationParamDef create a new EcucEnumerationParamDef in the container","title":"create_enumeration_param_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_float_param_def","text":"create_float_param_def( name: str, origin: str ) -> EcucFloatParamDef create a new EcucFloatParamDef in the container","title":"create_float_param_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_foreign_reference_def","text":"create_foreign_reference_def( name: str, origin: str ) -> EcucForeignReferenceDef create a new EcucForeignReferenceDef in the container","title":"create_foreign_reference_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_function_name_param_def","text":"create_function_name_param_def( name: str, origin: str ) -> EcucFunctionNameDef create a new EcucFunctionNameDef in the container","title":"create_function_name_param_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_instance_reference_def","text":"create_instance_reference_def( name: str, origin: str ) -> EcucInstanceReferenceDef create a new EcucInstanceReferenceDef in the container","title":"create_instance_reference_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_integer_param_def","text":"create_integer_param_def( name: str, origin: str ) -> EcucIntegerParamDef create a new EcucIntegerParamDef in the container","title":"create_integer_param_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_linker_symbol_param_def","text":"create_linker_symbol_param_def( name: str, origin: str ) -> EcucLinkerSymbolDef create a new EcucLinkerSymbolDef in the container","title":"create_linker_symbol_param_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_multiline_string_param_def","text":"create_multiline_string_param_def( name: str, origin: str ) -> EcucMultilineStringParamDef create a new EcucMultilineStringParamDef in the container","title":"create_multiline_string_param_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_param_conf_container_def","text":"create_param_conf_container_def( name: str, ) -> EcucParamConfContainerDef create a new EcucParamConfContainerDef as a sub-container","title":"create_param_conf_container_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_reference_def","text":"create_reference_def( name: str, origin: str ) -> EcucReferenceDef create a new EcucReferenceDef in the container","title":"create_reference_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_string_param_def","text":"create_string_param_def( name: str, origin: str ) -> EcucStringParamDef create a new EcucStringParamDef in the container","title":"create_string_param_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.create_uri_reference_def","text":"create_uri_reference_def( name: str, origin: str ) -> EcucUriReferenceDef create a new EcucUriReferenceDef in the container","title":"create_uri_reference_def"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.parameters","text":"parameters() -> Iterator[EcucParameterDef] get the parameters in the container","title":"parameters"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.references","text":"references() -> Iterator[EcucAnyReferenceDef] get the references in the container","title":"references"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucParamConfContainerDef.sub_containers","text":"sub_containers() -> Iterator[EcucContainerDef] iterate over the sub-containers","title":"sub_containers"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef","text":"EcucReferenceDef(element: Element) The EcuReferenceDef specifies references between parameters in the ECU configuration.","title":"EcucReferenceDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.destination","text":"destination: Optional[EcucContainerDef] destination container of the reference","title":"destination"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceValue","text":"EcucReferenceValue(element: Element) An EcucReferenceValue allows the ecu tonfiguration to refer to any identifiable element in the Autosar model","title":"EcucReferenceValue"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceValue.definition","text":"definition: Optional[EcucReferenceDef] set the parameter definition reference","title":"definition"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceValue.definition_ref","text":"definition_ref: Optional[str] get the referenced definition ref as a string This function is an alternative to definition() ; it is useful when the referenced definition is not loaded and can't be resolved.","title":"definition_ref"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceValue.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceValue.index","text":"index: Optional[int] set the index of the reference If the reference definition has requiresIndex set to true , then the reference must have an index. Otherwise the index is meaningless.","title":"index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceValue.is_auto_value","text":"is_auto_value: Optional[bool] set the isAutoValue flag If the reference definition has withAuto set to true , then the reference is allowed to have an auto value.","title":"is_auto_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucReferenceValue.target","text":"target: Optional[Element] Set the target of the reference","title":"target"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef","text":"EcucStringParamDef(element: Element) EcucStringParamDef is used to specify a string parameter in the ECU configuration","title":"EcucStringParamDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.default_value","text":"default_value: Optional[str] default value of the string parameter","title":"default_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.max_length","text":"max_length: Optional[int] max length of the string parameter","title":"max_length"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.min_length","text":"min_length: Optional[int] min length of the string parameter","title":"min_length"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.regular_expression","text":"regular_expression: Optional[str] regular expression for the string parameter","title":"regular_expression"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucStringParamDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucTextualParamValue","text":"EcucTextualParamValue(element: Element) The EcucTextualParamValue holds a string value and can represent a enumeration, string, multi-line string, function name or linker symbol parameter definition.","title":"EcucTextualParamValue"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucTextualParamValue.definition","text":"definition: Optional[EcucParameterDef] set the parameter definition reference","title":"definition"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucTextualParamValue.definition_ref","text":"definition_ref: Optional[str] get the parameter definition reference as a string This function is an alternative to definition() ; it is useful when the referenced definition is not loaded and can't be resolved.","title":"definition_ref"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucTextualParamValue.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucTextualParamValue.index","text":"index: Optional[int] set the index of the parameter If the parameter definition has requiresIndex set to true , then the parameter must have an index. Otherwise the index is meaningless.","title":"index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucTextualParamValue.is_auto_value","text":"is_auto_value: Optional[bool] set the isAutoValue flag If the parameter definition has withAuto set to true , then the parameter is allowed to have an auto value.","title":"is_auto_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucTextualParamValue.value","text":"value: str the textual value of the parameter","title":"value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef","text":"EcucUriReferenceDef(element: Element) The EcucUriReferenceDef defines a reference with a destination that is specified via a destinationUri","title":"EcucUriReferenceDef"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.destination_uri","text":"destination_uri: Optional[EcucDestinationUriDef] set the destination uri of the reference definition","title":"destination_uri"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.lower_multiplicity","text":"lower_multiplicity: Optional[int] get or set the lower multiplicity attribute","title":"lower_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.multiplicity_config_classes","text":"multiplicity_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the multiplicity config classes of the parameter definition. If an empty list is provided, the multiplicity config classes are removed. This setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION.","title":"multiplicity_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.origin","text":"origin: Optional[str] set the origin of the parameter definition The origin is a string that describes if the parameter was defined in the AUTOSAR standard or by a vendor. Standardized parameters use the origin \"AUTOSAR_ECUC\", while vendors are supposed to use string like 'VendorXyz_v1.3'","title":"origin"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.post_build_variant_multiplicity","text":"post_build_variant_multiplicity: Optional[bool] get or set the postBuildVariantMultiplicity attribute If postBuildVariantMultiplicity is true, then the parameter or reference may have a different number of instances in different post-build variants.","title":"post_build_variant_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.post_build_variant_value","text":"post_build_variant_value: Optional[bool] get or set the postBuildVariantValue attribute If postBuildVariantValue is true, then the parameter or reference may have different values in different post-build variants.","title":"post_build_variant_value"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.requires_index","text":"requires_index: Optional[bool] get or set the requiresIndex attribute","title":"requires_index"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.upper_multiplicity","text":"upper_multiplicity: Optional[int] get or set the upper multiplicity attribute","title":"upper_multiplicity"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.upper_multiplicity_infinite","text":"upper_multiplicity_infinite: Optional[bool] get or set the upper multiplicity infinite attribute if this attribute is set to true, the upper multiplicity is infinite (i.e. the module definition can be used an arbitrary number of times) When this attribute is true, the upper multiplicity attribute may not be used.","title":"upper_multiplicity_infinite"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.value_config_classes","text":"value_config_classes: List[ Tuple[EcucConfigurationClass, EcucConfigurationVariant] ] set the value config classes of the parameter definition. If an empty list is provided, the value config classes are removed. According to the specification setting is required if the containing EcucModuleDef has the category VENDOR_SPECIFIC_MODULE_DEFINITION, but in practice it is rarely used.","title":"value_config_classes"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucUriReferenceDef.with_auto","text":"with_auto: Optional[bool] get or set the withAuto attribute If withAuto is true, then the parameter or reference is allowed to set its isAutoValue attribute to true.","title":"with_auto"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucValueCollection","text":"EcucValueCollection(element: Element) EcucValueCollection collects references to all the separate modules that form the ECU configuration","title":"EcucValueCollection"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucValueCollection.ecu_extract_reference","text":"ecu_extract_reference: Optional[System] Set the ecu extract reference, which links a System to the ECU configuration","title":"ecu_extract_reference"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucValueCollection.element","text":"element: Element","title":"element"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucValueCollection.name","text":"name: str","title":"name"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucValueCollection.add_module_configuration","text":"add_module_configuration( module_configuration: EcucModuleConfigurationValues, ) -> None Add a reference to a module configuration to the collection","title":"add_module_configuration"},{"location":"ecu_configuration_api/#autosar_data.abstraction.ecu_configuration.EcucValueCollection.module_configurations","text":"module_configurations() -> Iterator[ EcucModuleConfigurationValues ] Get the module configurations in the collection","title":"module_configurations"},{"location":"software_component_api/","text":"API Documentation: autosar_data.abstraction.software_component \u00b6 Example \u00b6 from autosar_data.abstraction import * from autosar_data.abstraction.datatype import * from autosar_data.abstraction.software_component import * model = AutosarModelAbstraction.create(\"swc.arxml\") package = model.get_or_create_package(\"/Package\") # create some software components composition_type = package.create_composition_sw_component_type(\"CompositionType\") app_swc1_type = package.create_application_sw_component_type(\"AppSwc1Type\") app_swc1 = composition_type.create_component(\"AppSwc1\", app_swc1_type) app_swc2_type = package.create_application_sw_component_type(\"AppSwc2Type\") app_swc2 = composition_type.create_component(\"AppSwc2\", app_swc2_type) # create a data type sw_base_type = package.create_sw_base_type( \"SwBaseType\", 16, BaseTypeEncoding.TwosComplement ) sr_data_type = package.create_implementation_data_type( ImplementationDataTypeSettings.Value(\"ImplValue\", base_type=sw_base_type) ) # create interfaces and ports cs_interface = package.create_client_server_interface(\"CsInterface\") cs_operation = cs_interface.create_operation(\"CsOp\") sr_interface = package.create_sender_receiver_interface(\"SrInterface\") sr_data = sr_interface.create_data_element(\"SrData\", sr_data_type) # app1 provides the server interface, app2 requires it app1_cs_p_port = app_swc1_type.create_p_port(\"P_CS\", cs_interface) app2_cs_r_port = app_swc2_type.create_r_port(\"R_CS\", cs_interface) # connect the ports composition_type.create_assembly_connector( \"CS_Assembly\", app1_cs_p_port, app_swc1, app2_cs_r_port, app_swc2 ) # app1 receives data from app2 using the sender-receiver interface app1_sr_r_port = app_swc1_type.create_r_port(\"R_Sr\", sr_interface) app2_sr_p_port = app_swc2_type.create_p_port(\"P_Sr\", sr_interface) # connect the ports composition_type.create_assembly_connector( \"Sr_Assembly\", app1_sr_r_port, app_swc1, app2_sr_p_port, app_swc2 ) # create internal behavior for app1 app1_behavior = app_swc1_type.create_swc_internal_behavior(\"InternalBehavior\") # app1 needs a server runnable to process calls to its cs_operation server_runnable = app1_behavior.create_runnable_entity(\"ServerRunnable\") app1_behavior.create_operation_invoked_event( \"CsOperationEvent\", server_runnable, cs_operation, app1_cs_p_port ) # create a cyclically triggered runnable for app1 cyclic_runnable = app1_behavior.create_runnable_entity(\"CyclicRunnable\") app1_behavior.create_timing_event(\"CyclicEvent\", cyclic_runnable, 0.01) # allow the cyclic runnable to read data from the sender-receiver port cyclic_runnable.create_data_receive_point_by_argument( \"ReceiveData\", sr_data, app1_sr_r_port ) # create internal behavior for app2 app2_behavior = app_swc2_type.create_swc_internal_behavior(\"InternalBehavior\") # app2 has a cyclic runnable that sends data to app1 and calls the server operation cyclic_runnable = app2_behavior.create_runnable_entity(\"CyclicRunnable\") app2_behavior.create_timing_event(\"CyclicEvent\", cyclic_runnable, 0.01) # allow the cyclic runnable to send data to app1 cyclic_runnable.create_data_send_point(\"SendData\", sr_data, app2_sr_p_port) # allow the cyclic runnable to call the server operation on app1 cyclic_runnable.create_synchronous_server_call_point( \"ServerCall\", cs_operation, app2_cs_r_port ) API \u00b6 software_component \u00b6 PortInterface module-attribute \u00b6 PortInterface: TypeAlias = Union[ SenderReceiverInterface, ClientServerInterface, ModeSwitchInterface, NvDataInterface, ParameterInterface, TriggerInterface, ] PortPrototype module-attribute \u00b6 PortPrototype: TypeAlias = Union[ PPortPrototype, PRPortPrototype, RPortPrototype ] RTEEvent module-attribute \u00b6 RTEEvent: TypeAlias = Union[ AsynchronousServerCallReturnsEvent, BackgroundEvent, DataReceiveErrorEvent, DataReceivedEvent, DataSendCompletedEvent, DataWriteCompletedEvent, ExternalTriggerOccurredEvent, InitEvent, InternalTriggerOccurredEvent, ModeSwitchedAckEvent, OperationInvokedEvent, OsTaskExecutionEvent, SwcModeManagerErrorEvent, SwcModeSwitchEvent, TimingEvent, TransformerHardErrorEvent, ] SwComponentType module-attribute \u00b6 SwComponentType: TypeAlias = Union[ ApplicationSwComponentType, ComplexDeviceDriverSwComponentType, CompositionSwComponentType, EcuAbstractionSwComponentType, SensorActuatorSwComponentType, ServiceSwComponentType, ] ApplicationError \u00b6 ApplicationError(element: Element) An ApplicationError represents an error that can be returned by a client server operation element instance-attribute \u00b6 element: Element error_code instance-attribute \u00b6 error_code: int the error code of the application error name instance-attribute \u00b6 name: str ApplicationSwComponentType \u00b6 ApplicationSwComponentType(element: Element) An ApplicationSwComponentType is a software component that provides application functionality Use [ ArPackage::create_application_sw_component_type ] to create a new application sw component type. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_p_port \u00b6 create_p_port( name: str, port_interface: PortInterface ) -> PPortPrototype create a new provided port with the given name and port interface create_port_group \u00b6 create_port_group(name: str) -> PortGroup create a new port group create_pr_port \u00b6 create_pr_port( name: str, port_interface: PortInterface ) -> PRPortPrototype create a new provided required port with the given name and port interface create_r_port \u00b6 create_r_port( name: str, port_interface: PortInterface ) -> RPortPrototype create a new required port with the given name and port interface create_swc_internal_behavior \u00b6 create_swc_internal_behavior( name: str, ) -> SwcInternalBehavior create an SwcInternalBehavior for the component A component can have only one internal behavior, but since the internal behavior is a variation point, more than one internal behavior can be created. In this case the variation point settings must ensure that only one internal behavior is active. instances \u00b6 instances() -> List[SwComponentPrototype] list all instances of the component type parent_compositions \u00b6 parent_compositions() -> List[CompositionSwComponentType] list all compositions containing instances of the component type ports \u00b6 ports() -> Iterator[PortPrototype] get an iterator over the ports of the component swc_internal_behaviors \u00b6 swc_internal_behaviors() -> Iterator[SwcInternalBehavior] iterate over all swc internal behaviors - typically zero or one ArgumentDataPrototype \u00b6 ArgumentDataPrototype(element: Element) An ArgumentDataPrototype represents an argument in a ClientServerOperation data_type instance-attribute \u00b6 data_type: Optional[AutosarDataType] data type of the argument direction instance-attribute \u00b6 direction: Optional[ArgumentDirection] direction of the argument element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str ArgumentDirection \u00b6 The ArgumentDirection defines the direction of an argument in a ClientServerOperation Input arguments are used to pass data from the client to the server and are usualy passed by value. Output arguments are used to pass data from the server to the client and are usually passed by reference. In/Out arguments are used to pass data in both directions and are usually passed by reference. In instance-attribute \u00b6 In: ArgumentDirection InOut instance-attribute \u00b6 InOut: ArgumentDirection Out instance-attribute \u00b6 Out: ArgumentDirection AssemblySwConnector \u00b6 AssemblySwConnector(element: Element) An AssemblySwConnector connects ports of two SwCompositionType s. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str p_port instance-attribute \u00b6 p_port: Optional[PortPrototype] get the provided port of the assembly connector p_sw_component instance-attribute \u00b6 p_sw_component: Optional[SwComponentPrototype] get the software component that contains the provided port of the assembly connector r_port instance-attribute \u00b6 r_port: Optional[PortPrototype] get the required port of the assembly connector r_sw_component instance-attribute \u00b6 r_sw_component: Optional[SwComponentPrototype] get the software component that contains the required port of the assembly connector AsynchronousServerCallReturnsEvent \u00b6 AsynchronousServerCallReturnsEvent(element: Element) an asynchronous server call completed element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event BackgroundEvent \u00b6 BackgroundEvent(element: Element) starts a runnable for background processing at low priority element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event ClientServerInterface \u00b6 ClientServerInterface(element: Element) A ClientServerInterface defines a set of operations that can be implemented by a server and called by a client Use [ ArPackage::create_client_server_interface ] to create a new client server interface element instance-attribute \u00b6 element: Element is_service instance-attribute \u00b6 is_service: Optional[bool] Get/Set if the client server interface is a service interface name instance-attribute \u00b6 name: str create_operation \u00b6 create_operation(name: str) -> ClientServerOperation add an operation to the client server interface create_possible_error \u00b6 create_possible_error( name: str, error_code: int ) -> ApplicationError Create a new ClientServerInterface Add a possible error to the client server interface operations \u00b6 operations() -> Iterator[ClientServerOperation] iterate over all operations possible_errors \u00b6 possible_errors() -> Iterator[ApplicationError] iterate over all application errors ClientServerOperation \u00b6 ClientServerOperation(element: Element) A ClientServerOperation defines an operation in a ClientServerInterface element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str add_possible_error \u00b6 add_possible_error(error: ApplicationError) -> None add a reference to possible error to the operation arguments \u00b6 arguments() -> Iterator[ArgumentDataPrototype] iterate over all arguments create_argument \u00b6 create_argument( name: str, data_type: AutosarDataType, direction: ArgumentDirection, ) -> ArgumentDataPrototype Create a new ClientServerOperation Add an argument to the operation possible_errors \u00b6 possible_errors() -> Iterator[ApplicationError] Get the possible errors of the operation ComplexDeviceDriverSwComponentType \u00b6 ComplexDeviceDriverSwComponentType(element: Element) A ComplexDeviceDriverSwComponentType is a software component that provides complex device driver functionality Use [ ArPackage::create_complex_device_driver_sw_component_type ] to create a new complex device driver sw component type. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_p_port \u00b6 create_p_port( name: str, port_interface: PortInterface ) -> PPortPrototype create a new provided port with the given name and port interface create_port_group \u00b6 create_port_group(name: str) -> PortGroup create a new port group create_pr_port \u00b6 create_pr_port( name: str, port_interface: PortInterface ) -> PRPortPrototype create a new provided required port with the given name and port interface create_r_port \u00b6 create_r_port( name: str, port_interface: PortInterface ) -> RPortPrototype create a new required port with the given name and port interface create_swc_internal_behavior \u00b6 create_swc_internal_behavior( name: str, ) -> SwcInternalBehavior create an SwcInternalBehavior for the component A component can have only one internal behavior, but since the internal behavior is a variation point, more than one internal behavior can be created. In this case the variation point settings must ensure that only one internal behavior is active. instances \u00b6 instances() -> List[SwComponentPrototype] list of all instances of the component type parent_compositions \u00b6 parent_compositions() -> List[CompositionSwComponentType] list all compositions containing instances of the component type ports \u00b6 ports() -> Iterator[PortPrototype] get an iterator over the ports of the component swc_internal_behaviors \u00b6 swc_internal_behaviors() -> Iterator[SwcInternalBehavior] iterate over all swc internal behaviors - typically zero or one CompositionSwComponentType \u00b6 CompositionSwComponentType(element: Element) A CompositionSwComponentType is a software component that contains other software components Use [ ArPackage::create_composition_sw_component_type ] to create a new composition sw component type. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str components \u00b6 components() -> Iterator[SwComponentPrototype] get an iterator over the components of the composition connectors \u00b6 connectors() -> Iterator[AssemblySwConnector] iterate over all connectors create_assembly_connector \u00b6 create_assembly_connector( name: str, port_1: PortPrototype, sw_prototype_1: SwComponentPrototype, port_2: PortPrototype, sw_prototype_2: SwComponentPrototype, ) -> AssemblySwConnector create a new delegation connector between an inner port and an outer port this is the actual implementation of the public method, but without the generic parameters create a new assembly connector between two ports of contained software components The two ports must be compatible. create_component \u00b6 create_component( name: str, component_type: SwComponentType ) -> SwComponentPrototype create a component of type component_type in the composition It is not allowed to form cycles in the composition hierarchy, and this will return an error create_delegation_connector \u00b6 create_delegation_connector( name: str, inner_port: PortPrototype, inner_sw_prototype: SwComponentPrototype, outer_port: PortPrototype, ) -> DelegationSwConnector create a new delegation connector between an inner port and an outer port The two ports must be compatible. create_p_port \u00b6 create_p_port( name: str, port_interface: PortInterface ) -> PPortPrototype create a new provided port with the given name and port interface create_pass_through_connector \u00b6 create_pass_through_connector( name: str, port_1: PortPrototype, port_2: PortPrototype ) -> PassThroughSwConnector create a new passthrough connector between two outer ports of the composition The two ports must be compatible. create_port_group \u00b6 create_port_group(name: str) -> PortGroup create a new port group create_pr_port \u00b6 create_pr_port( name: str, port_interface: PortInterface ) -> PRPortPrototype create a new provided required port with the given name and port interface create_r_port \u00b6 create_r_port( name: str, port_interface: PortInterface ) -> RPortPrototype create a new required port with the given name and port interface instances \u00b6 instances() -> List[SwComponentPrototype] list of all instances of the component type is_parent_of \u00b6 is_parent_of(other: SwComponentType) -> bool check if the composition is a parent (or grand-parent, etc.) of the component parent_compositions \u00b6 parent_compositions() -> Iterator[ CompositionSwComponentType ] iterator over all compositions containing instances of the component type ports \u00b6 ports() -> Iterator[PortPrototype] get an iterator over the ports of the component DataReceiveErrorEvent \u00b6 DataReceiveErrorEvent(element: Element) A DataReceiveErrorEvent is a subclass of RTEEvent which triggers a RunnableEntity when a data receive error occurs element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event DataReceivedEvent \u00b6 DataReceivedEvent(element: Element) A DataReceivedEvent is a subclass of RTEEvent which triggers a RunnableEntity when data is received element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event variable_data_prototype instance-attribute \u00b6 variable_data_prototype: Optional[ Tuple[VariableDataPrototype, PortPrototype] ] Get the VariableDataPrototype that triggers the DataReceivedEvent set_variable_data_prototype \u00b6 set_variable_data_prototype( variable_data_prototype: VariableDataPrototype, context_port: PPortPrototype, ) -> None Set the VariableDataPrototype that triggers the DataReceivedEvent DataSendCompletedEvent \u00b6 DataSendCompletedEvent(element: Element) A DataSendCompletedEvent is a subclass of RTEEvent which triggers a RunnableEntity when data is sent element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event DataWriteCompletedEvent \u00b6 DataWriteCompletedEvent(element: Element) A DataWriteCompletedEvent is a subclass of RTEEvent which triggers a RunnableEntity when data is written element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event DelegationSwConnector \u00b6 DelegationSwConnector(element: Element) A DelegationSwConnector connects a port of a software component that is contained inside a SwCompositionType with a port of the SwCompositionType . element instance-attribute \u00b6 element: Element inner_port instance-attribute \u00b6 inner_port: Optional[PortPrototype] get the inner port of the delegation connector inner_sw_component instance-attribute \u00b6 inner_sw_component: Optional[SwComponentPrototype] get the software component that contains the inner port of the delegation connector name instance-attribute \u00b6 name: str outer_port instance-attribute \u00b6 outer_port: Optional[PortPrototype] get the outer port of the delegation connector EcuAbstractionSwComponentType \u00b6 EcuAbstractionSwComponentType(element: Element) The EcuAbstractionSwComponentType is a special AtomicSwComponentType that resides between a software-component that wants to access ECU periphery and the Microcontroller Abstraction Use [ ArPackage::create_ecu_abstraction_sw_component_type ] to create a new ECU abstraction sw component type. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_p_port \u00b6 create_p_port( name: str, port_interface: PortInterface ) -> PPortPrototype create a new provided port with the given name and port interface create_port_group \u00b6 create_port_group(name: str) -> PortGroup create a new port group create_pr_port \u00b6 create_pr_port( name: str, port_interface: PortInterface ) -> PRPortPrototype create a new provided required port with the given name and port interface create_r_port \u00b6 create_r_port( name: str, port_interface: PortInterface ) -> RPortPrototype create a new required port with the given name and port interface create_swc_internal_behavior \u00b6 create_swc_internal_behavior( name: str, ) -> SwcInternalBehavior create an SwcInternalBehavior for the component A component can have only one internal behavior, but since the internal behavior is a variation point, more than one internal behavior can be created. In this case the variation point settings must ensure that only one internal behavior is active. instances \u00b6 instances() -> List[SwComponentPrototype] list all instances of the component type parent_compositions \u00b6 parent_compositions() -> List[CompositionSwComponentType] list all compositions containing instances of the component type ports \u00b6 ports() -> Iterator[PortPrototype] get an iterator over the ports of the component swc_internal_behaviors \u00b6 swc_internal_behaviors() -> Iterator[SwcInternalBehavior] iterate over all swc internal behaviors - typically zero or one ExternalTriggerOccurredEvent \u00b6 ExternalTriggerOccurredEvent(element: Element) A ExternalTriggerOccurredEvent is a subclass of RTEEvent which triggers a RunnableEntity when an external trigger occurs element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event InitEvent \u00b6 InitEvent(element: Element) A InitEvent is a subclass of RTEEvent which triggers a RunnableEntity when the software component is initialized element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event InternalTriggerOccurredEvent \u00b6 InternalTriggerOccurredEvent(element: Element) A InternalTriggerOccurredEvent is a subclass of RTEEvent which triggers a RunnableEntity when an internal trigger occurs element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event ModeAccessPoint \u00b6 ModeAccessPoint(element: Element) A ModeAccessPoint provides the ability to access the current mode of a ModeDeclarationGroup element instance-attribute \u00b6 element: Element mode_group instance-attribute \u00b6 mode_group: Optional[Tuple[ModeGroup, PortPrototype]] name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] Get the RunnableEntity that contains the ModeAccessPoint set_mode_group \u00b6 set_mode_group( mode_group: ModeGroup, context_port: PortPrototype ) -> None Set the mode group and context port of the ModeAccessPoint ModeActivationKind \u00b6 Kind of mode switch condition used for activation of an event OnEntry instance-attribute \u00b6 OnEntry: ModeActivationKind The mode is activated on entry to the mode. OnExit instance-attribute \u00b6 OnExit: ModeActivationKind The mode is activated on exit from the mode. OnTransition instance-attribute \u00b6 OnTransition: ModeActivationKind The mode is activated on transition from the first mode to the second mode. ModeDeclaration \u00b6 ModeDeclaration(element: Element) A ModeDeclaration represents a mode declaration in a ModeDeclarationGroup element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str value instance-attribute \u00b6 value: Optional[int] value of the mode declaration, if any. ModeDeclarationGroup \u00b6 ModeDeclarationGroup(element: Element) A ModeDeclarationGroup is a collection of mode declarations. category instance-attribute \u00b6 category: Optional[ModeDeclarationGroupCategory] category of the mode declaration group element instance-attribute \u00b6 element: Element initial_mode instance-attribute \u00b6 initial_mode: Optional[ModeDeclaration] initial mode of the mode declaration group, if any name instance-attribute \u00b6 name: str on_transition_value instance-attribute \u00b6 on_transition_value: Optional[int] Value to be used when switching to the mode declaration group, if any. This is the onTransitionValue attribute of the mode declaration group. create_mode_declaration \u00b6 create_mode_declaration(name: str) -> ModeDeclaration Create a new mode declaration in the group mode_declarations \u00b6 mode_declarations() -> Iterator[ModeDeclaration] iterate over all mode declarations in the group ModeDeclarationGroupCategory \u00b6 Category of mode declaration groupy, which defines the ordering of the modes in the group AlphabeticOrder instance-attribute \u00b6 AlphabeticOrder: ModeDeclarationGroupCategory Alphabetic order of the modes in the group. ExplicitOrder instance-attribute \u00b6 ExplicitOrder: ModeDeclarationGroupCategory Ordering of modes in the mode declaration group is made explicit by the value, which must be set for each mode. Additonally, the on_transition_value attribute must be set in this case. ModeGroup \u00b6 ModeGroup(element: Element) A ModeGroup represents a mode group in a ModeSwitchInterface element instance-attribute \u00b6 element: Element mode_declaration_group instance-attribute \u00b6 mode_declaration_group: ModeDeclarationGroup Get/Set the mode declaration group of the mode group name instance-attribute \u00b6 name: str ModeSwitchInterface \u00b6 ModeSwitchInterface(element: Element) A ModeSwitchInterface defines a set of modes that can be switched Use [ ArPackage::create_mode_switch_interface ] to create a new mode switch interface element instance-attribute \u00b6 element: Element is_service instance-attribute \u00b6 is_service: Optional[bool] Get/Set if the mode switch interface is a service interface mode_group instance-attribute \u00b6 mode_group: Optional[ModeGroup] Get the mode group of the mode switch interface name instance-attribute \u00b6 name: str create_mode_group \u00b6 create_mode_group( name: str, mode_declaration_group: ModeDeclarationGroup ) -> ModeGroup Create a new mode group in the mode switch interface The ModeSwitchInterface can only contain one mode group ModeSwitchPoint \u00b6 ModeSwitchPoint(element: Element) A ModeSwitchPoint allows a RunnableEntity to switch modes in a ModeDeclarationGroup element instance-attribute \u00b6 element: Element mode_group instance-attribute \u00b6 mode_group: Optional[Tuple[ModeGroup, PortPrototype]] name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] Get the RunnableEntity that contains the ModeSwitchPoint set_mode_group \u00b6 set_mode_group( mode_group: ModeGroup, context_port: PortPrototype ) -> None Set the mode group and context port of the ModeSwitchPoint ModeSwitchedAckEvent \u00b6 ModeSwitchedAckEvent(element: Element) A ModeSwitchedAckEvent is a subclass of RTEEvent which triggers a RunnableEntity when a mode switch is acknowledged element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event NvDataInterface \u00b6 NvDataInterface(element: Element) An NvDataInterface defines non-volatile data that can be accessed through the interface Use [ ArPackage::create_nv_data_interface ] to create a new non-volatile data interface element instance-attribute \u00b6 element: Element is_service instance-attribute \u00b6 is_service: Optional[bool] Get/Set if the Nv-data interface is a service interface name instance-attribute \u00b6 name: str OperationInvokedEvent \u00b6 OperationInvokedEvent(element: Element) A OperationInvokedEvent is a subclass of RTEEvent which triggers a RunnableEntity when an operation is invoked client_server_operation instance-attribute \u00b6 client_server_operation: Tuple[ ClientServerOperation, PPortPrototype ] Get the ClientServerOperation that triggers the OperationInvokedEvent element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the OperationInvokedEvent swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] SwcInternalBehavior that contains the event set_client_server_operation \u00b6 set_client_server_operation( client_server_operation: ClientServerOperation, context_p_port: PPortPrototype, ) -> None Set the ClientServerOperation that is triggers the OperationInvokedEvent OsTaskExecutionEvent \u00b6 OsTaskExecutionEvent(element: Element) A OsTaskExecutionEvent is a subclass of RTEEvent which triggers a RunnableEntity when an OS task is executed element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event PPortPrototype \u00b6 PPortPrototype(element: Element) PPortPrototype represents a provided port prototype component_type instance-attribute \u00b6 component_type: Optional[SwComponentType] component type containing the port prototype element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str port_interface instance-attribute \u00b6 port_interface: Optional[PortInterface] port interface of the port prototype PRPortPrototype \u00b6 PRPortPrototype(element: Element) PRPortPrototype represents a provided and required port prototype component_type instance-attribute \u00b6 component_type: Optional[SwComponentType] component type containing the port prototype element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str port_interface instance-attribute \u00b6 port_interface: Optional[PortInterface] port interface of the port prototype ParameterDataPrototype \u00b6 ParameterDataPrototype(element: Element) A ParameterDataPrototype represents a parameter in a ParameterInterface data_type instance-attribute \u00b6 data_type: Optional[AutosarDataType] data type of the parameter element instance-attribute \u00b6 element: Element init_value instance-attribute \u00b6 init_value: Optional[ValueSpecification] interface instance-attribute \u00b6 interface: Optional[SenderReceiverInterface] Get the interface containing the parameter name instance-attribute \u00b6 name: str ParameterInterface \u00b6 ParameterInterface(element: Element) A ParameterInterface defines a set of parameters that can be accessed Use [ ArPackage::create_parameter_interface ] to create a new parameter interface element instance-attribute \u00b6 element: Element is_service instance-attribute \u00b6 is_service: Optional[bool] Get/Set if the parameter interface is a service interface name instance-attribute \u00b6 name: str create_parameter \u00b6 create_parameter( name: str, data_type: AutosarDataType ) -> ParameterDataPrototype Add a new parameter to the parameter interface parameters \u00b6 parameters() -> Iterator[ParameterDataPrototype] iterate over all parameters PassThroughSwConnector \u00b6 PassThroughSwConnector(element: Element) A PassThroughSwConnector connects two ports of a SwCompositionType . element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str p_port instance-attribute \u00b6 p_port: Optional[PortPrototype] get the provided port of the pass-through connector r_port instance-attribute \u00b6 r_port: Optional[PortPrototype] get the required port of the pass-through connector PortGroup \u00b6 PortGroup(element: Element) PortGroup represents a group of ports element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str RPortPrototype \u00b6 RPortPrototype(element: Element) RPortPrototype represents a required port prototype component_type instance-attribute \u00b6 component_type: Optional[SwComponentType] component type containing the port prototype element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str port_interface instance-attribute \u00b6 port_interface: Optional[PortInterface] port interface of the port prototype RootSwCompositionPrototype \u00b6 RootSwCompositionPrototype(element: Element) The RootSwCompositionPrototype is a special kind of SwComponentPrototype that represents the root of the composition hierarchy composition instance-attribute \u00b6 composition: Optional[CompositionSwComponentType] composition that this root component is based on element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str RunnableEntity \u00b6 RunnableEntity(element: Element) A RunnableEntity is a function that can be executed by the RTE element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] SwcInternalBehavior that contains the RunnableEntity create_data_read_access \u00b6 create_data_read_access( name: str, data_element: VariableDataPrototype, port: PortPrototype, ) -> VariableAccess add implicit read access to a data element of a sender-receiver PortPrototype this results in Rte_IRead_<port>_<data_element> being generated create_data_receive_point_by_argument \u00b6 create_data_receive_point_by_argument( name: str, data_element: VariableDataPrototype, port: PortPrototype, ) -> VariableAccess add explicit read access by argument to a data element of a sender-receiver PortPrototype create_data_receive_point_by_value \u00b6 create_data_receive_point_by_value( name: str, data_element: VariableDataPrototype, port: PortPrototype, ) -> VariableAccess add explicit read access by value to a data element of a sender-receiver PortPrototype create_data_send_point \u00b6 create_data_send_point( name: str, data_element: VariableDataPrototype, port: PortPrototype, ) -> VariableAccess add a data send point to a data element of a sender-receiver PortPrototype create_data_write_access \u00b6 create_data_write_access( name: str, data_element: VariableDataPrototype, port: PortPrototype, ) -> VariableAccess add implicit write access to a data element of a sender-receiver PortPrototype this results in Rte_IWrite_<port>_<data_element> being generated create_mode_access_point \u00b6 create_mode_access_point( name: str, mode_group: ModeGroup, context_port: PortPrototype, ) -> ModeAccessPoint create a mode access point that allows the runnable to access the current mode of a mode group create_mode_switch_point \u00b6 create_mode_switch_point( name: str, mode_group: ModeGroup, context_port: PortPrototype, ) -> ModeSwitchPoint create a mode switch point that allows the runnable to switch modes in a mode group create_synchronous_server_call_point \u00b6 create_synchronous_server_call_point( name: str, operation: ClientServerOperation, port: PPortPrototype, ) -> SynchronousServerCallPoint create a synchronous server call point that allows the runnable to call a server operation data_read_accesses \u00b6 data_read_accesses() -> Iterator[VariableAccess] iterate over all data read accesses of the runnable entity data_receive_points_by_argument \u00b6 data_receive_points_by_argument() -> Iterator[ VariableAccess ] iterate over all data receive points by argument of the runnable entity data_receive_points_by_value \u00b6 data_receive_points_by_value() -> Iterator[VariableAccess] iterate over all data receive points by value of the runnable entity data_send_points \u00b6 data_send_points() -> Iterator[VariableAccess] iterate over all data send points of the runnable entity data_write_accesses \u00b6 data_write_accesses() -> Iterator[VariableAccess] iterate over all data write accesses of the runnable entity events \u00b6 events() -> List[RTEEvent] Iterate over all events that can trigger the RunnableEntity mode_access_points \u00b6 mode_access_points() -> Iterator[ModeAccessPoint] iterate over all mode access points of the runnable entity mode_switch_points \u00b6 mode_switch_points() -> Iterator[ModeSwitchPoint] iterate over all mode switch points of the runnable entity synchronous_server_call_points \u00b6 synchronous_server_call_points() -> Iterator[ SynchronousServerCallPoint ] iterate over all synchronous server call points of the runnable entity SenderReceiverInterface \u00b6 SenderReceiverInterface(element: Element) A SenderReceiverInterface defines a set of data elements that can be sent and received Use [ ArPackage::create_sender_receiver_interface ] to create a new sender receiver interface element instance-attribute \u00b6 element: Element is_service instance-attribute \u00b6 is_service: Optional[bool] Get/Set if the sender/receiver interface is a service interface name instance-attribute \u00b6 name: str create_data_element \u00b6 create_data_element( name: str, data_type: AutosarDataType ) -> VariableDataPrototype Add a new data element to the sender receiver interface data_elements \u00b6 data_elements() -> Iterator[VariableDataPrototype] iterate over all data elements SensorActuatorSwComponentType \u00b6 SensorActuatorSwComponentType(element: Element) SensorActuatorSwComponentType is used to connect sensor/acutator devices to the ECU configuration Use [ ArPackage::create_sensor_actuator_sw_component_type ] to create a new sensor/actuator sw component type. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_p_port \u00b6 create_p_port( name: str, port_interface: PortInterface ) -> PPortPrototype create a new provided port with the given name and port interface create_port_group \u00b6 create_port_group(name: str) -> PortGroup create a new port group create_pr_port \u00b6 create_pr_port( name: str, port_interface: PortInterface ) -> PRPortPrototype create a new provided required port with the given name and port interface create_r_port \u00b6 create_r_port( name: str, port_interface: PortInterface ) -> RPortPrototype create a new required port with the given name and port interface create_swc_internal_behavior \u00b6 create_swc_internal_behavior( name: str, ) -> SwcInternalBehavior create an SwcInternalBehavior for the component A component can have only one internal behavior, but since the internal behavior is a variation point, more than one internal behavior can be created. In this case the variation point settings must ensure that only one internal behavior is active. instances \u00b6 instances() -> List[SwComponentPrototype] list all instances of the component type parent_compositions \u00b6 parent_compositions() -> List[CompositionSwComponentType] list all compositions containing instances of the component type ports \u00b6 ports() -> Iterator[PortPrototype] get an iterator over the ports of the component swc_internal_behaviors \u00b6 swc_internal_behaviors() -> Iterator[SwcInternalBehavior] iterate over all swc internal behaviors - typically zero or one ServiceSwComponentType \u00b6 ServiceSwComponentType(element: Element) ServiceSwComponentType is used for configuring services for a given ECU. Instances of this class should only be created in ECU Configuration phase for the specific purpose of the service configuration. Use [ ArPackage::create_service_sw_component_type ] to create a new service sw component type. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str create_p_port \u00b6 create_p_port( name: str, port_interface: PortInterface ) -> PPortPrototype create a new provided port with the given name and port interface create_port_group \u00b6 create_port_group(name: str) -> PortGroup create a new port group create_pr_port \u00b6 create_pr_port( name: str, port_interface: PortInterface ) -> PRPortPrototype create a new provided required port with the given name and port interface create_r_port \u00b6 create_r_port( name: str, port_interface: PortInterface ) -> RPortPrototype create a new required port with the given name and port interface create_swc_internal_behavior \u00b6 create_swc_internal_behavior( name: str, ) -> SwcInternalBehavior create an SwcInternalBehavior for the component A component can have only one internal behavior, but since the internal behavior is a variation point, more than one internal behavior can be created. In this case the variation point settings must ensure that only one internal behavior is active. instances \u00b6 instances() -> List[SwComponentPrototype] list all instances of the component type parent_compositions \u00b6 parent_compositions() -> List[CompositionSwComponentType] list all compositions containing instances of the component type ports \u00b6 ports() -> Iterator[PortPrototype] get an iterator over the ports of the component swc_internal_behaviors \u00b6 swc_internal_behaviors() -> Iterator[SwcInternalBehavior] iterate over all swc internal behaviors - typically zero or one SwComponentPrototype \u00b6 SwComponentPrototype(element: Element) A SwComponentPrototype is an instance of a software component type element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str SwcInternalBehavior \u00b6 SwcInternalBehavior(element: Element) The SwcInternalBehavior of a software component type describes the details that are needed to generate the RTE. element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str sw_component_type instance-attribute \u00b6 sw_component_type: Optional[SwComponentType] software component type that contains the SwcInternalBehavior add_data_type_mapping_set \u00b6 add_data_type_mapping_set( data_type_mapping_set: DataTypeMappingSet, ) -> None Add a reference to a DataTypeMappingSet to the SwcInternalBehavior create_background_event \u00b6 create_background_event( name: str, runnable: RunnableEntity ) -> BackgroundEvent Create a new BackgroundEvent in the SwcInternalBehavior that triggers a runnable at low priority create_data_received_event \u00b6 create_data_received_event( name: str, runnable: RunnableEntity, variable_data_prototype: VariableDataPrototype, context_port: PortPrototype, ) -> DataReceivedEvent Create a new DataReceivedEvent in the SwcInternalBehavior that triggers a runnable when data is received create_init_event \u00b6 create_init_event( name: str, runnable: RunnableEntity ) -> InitEvent Create a new InitEvent in the SwcInternalBehavior create_mode_switch_event \u00b6 create_mode_switch_event( name: str, runnable: RunnableEntity, activation: ModeActivationKind, context_port: PortPrototype, mode_declaration: ModeDeclaration, /, second_mode_declaration: Optional[ ModeDeclaration ] = None, ) -> SwcModeSwitchEvent create a mode switch event that triggers a runnable in the SwcInternalBehavior when the mode is switched create_operation_invoked_event \u00b6 create_operation_invoked_event( name: str, runnable: RunnableEntity, client_server_operation: ClientServerOperation, context_p_port: PPortPrototype, ) -> OperationInvokedEvent Create a new OperationInvokedEvent in the SwcInternalBehavior create_os_task_execution_event \u00b6 create_os_task_execution_event( name: str, runnable: RunnableEntity ) -> OsTaskExecutionEvent Create a new OsTaskExecutionEvent in the SwcInternalBehavior that triggers a runnable when an OS task is executed create_runnable_entity \u00b6 create_runnable_entity(name: str) -> RunnableEntity Create a new RunnableEntity in the SwcInternalBehavior create_timing_event \u00b6 create_timing_event( name: str, runnable: RunnableEntity, period: float ) -> TimingEvent Create a timing event that triggers a runnable in the SwcInternalBehavior data_type_mapping_sets \u00b6 data_type_mapping_sets() -> Iterator[DataTypeMappingSet] iterator over all DataTypeMappingSet references in the SwcInternalBehavior events \u00b6 events() -> Iterator[RTEEvent] create an iterator over all events in the SwcInternalBehavior runnable_entities \u00b6 runnable_entities() -> Iterator[RunnableEntity] Get an iterator over all RunnableEntities in the SwcInternalBehavior SwcModeManagerErrorEvent \u00b6 SwcModeManagerErrorEvent(element: Element) A SwcModeManagerErrorEvent is a subclass of RTEEvent which triggers a RunnableEntity when a mode manager error occurs element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event SwcModeSwitchEvent \u00b6 SwcModeSwitchEvent(element: Element) A SwcModeSwitchEvent is a subclass of RTEEvent which triggers a RunnableEntity when a mode switch occurs element instance-attribute \u00b6 element: Element mode_activation_kind instance-attribute \u00b6 mode_activation_kind: Optional[ModeActivationKind] Get/Set the mode activation kind of the SwcModeSwitchEvent name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event mode_declarations \u00b6 mode_declarations() -> Optional[List[ModeDeclaration]] Get the mode declarations that trigger the SwcModeSwitchEvent The list contains one or two mode declarations, depending on the activation kind. If the activation kind is OnTransition , the list contains two mode declarations. Otherwise, it contains one mode declaration. set_mode_declaration \u00b6 set_mode_declaration( ontext_port: PortPrototype, mode_declaration: ModeDeclaration, /, second_mode_declaration: Optional[ ModeDeclaration ] = None, ) -> None Set the mode declaration within a context port that triggers the SwcModeSwitchEvent The second mode must be provided if the activation kind OnTransition is configured. In that case only transitions between the two modes trigger the event. SynchronousServerCallPoint \u00b6 SynchronousServerCallPoint(element: Element) A SynchronousServerCallPoint allows a RunnableEntity to call a server operation synchronously client_server_operation instance-attribute \u00b6 client_server_operation: Optional[ Tuple[ClientServerOperation, PPortPrototype] ] Get the ClientServerOperation that is called by the SynchronousServerCallPoint element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that contains the SynchronousServerCallPoint set_client_server_operation \u00b6 set_client_server_operation( client_server_operation: ClientServerOperation, context_p_port: PPortPrototype, ) -> None Set the ClientServerOperation that is called by the SynchronousServerCallPoint TimingEvent \u00b6 TimingEvent(element: Element) A TimingEvent is a subclass of RTEEvent which triggers a RunnableEntity periodically element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str period instance-attribute \u00b6 period: Optional[float] period of the TimingEvent runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event TransformerHardErrorEvent \u00b6 TransformerHardErrorEvent(element: Element) A TransformerHardErrorEvent is a subclass of RTEEvent which triggers a RunnableEntity when a transformer hard error occurs element instance-attribute \u00b6 element: Element element of the TransformerHardErrorEvent name instance-attribute \u00b6 name: str name of the TransformerHardErrorEvent runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted swc_internal_behavior instance-attribute \u00b6 swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event TriggerInterface \u00b6 TriggerInterface(element: Element) A TriggerInterface declares a number of triggers that can be sent by an trigger source Use [ ArPackage::create_trigger_interface ] to create a new trigger interface element instance-attribute \u00b6 element: Element is_service instance-attribute \u00b6 is_service: Optional[bool] Get/Set if the trigger interface is a service interface name instance-attribute \u00b6 name: str VariableAccess \u00b6 VariableAccess(element: Element) A VariableAccess allows a RunnableEntity to access a variable in various contexts accessed_variable instance-attribute \u00b6 accessed_variable: Optional[ Tuple[VariableDataPrototype, PortPrototype] ] Get the variable that is accessed by the VariableAccess element instance-attribute \u00b6 element: Element name instance-attribute \u00b6 name: str runnable_entity instance-attribute \u00b6 runnable_entity: Optional[RunnableEntity] RunnableEntity that contains the VariableAccess set_accessed_variable \u00b6 set_accessed_variable( variable: VariableDataPrototype, context_port: PortPrototype, ) -> None Set the variable that is accessed by the VariableAccess VariableDataPrototype \u00b6 VariableDataPrototype(element: Element) A VariableDataPrototype represents a data element in a SenderReceiverInterface data_type instance-attribute \u00b6 data_type: Optional[AutosarDataType] data type of the data element element instance-attribute \u00b6 element: Element init_value instance-attribute \u00b6 init_value: Optional[ValueSpecification] initial value of the data element, if any interface instance-attribute \u00b6 interface: Optional[SenderReceiverInterface] Get the interface containing the data element name instance-attribute \u00b6 name: str","title":"Software Component"},{"location":"software_component_api/#api-documentation-autosar_dataabstractionsoftware_component","text":"","title":"API Documentation: autosar_data.abstraction.software_component"},{"location":"software_component_api/#example","text":"from autosar_data.abstraction import * from autosar_data.abstraction.datatype import * from autosar_data.abstraction.software_component import * model = AutosarModelAbstraction.create(\"swc.arxml\") package = model.get_or_create_package(\"/Package\") # create some software components composition_type = package.create_composition_sw_component_type(\"CompositionType\") app_swc1_type = package.create_application_sw_component_type(\"AppSwc1Type\") app_swc1 = composition_type.create_component(\"AppSwc1\", app_swc1_type) app_swc2_type = package.create_application_sw_component_type(\"AppSwc2Type\") app_swc2 = composition_type.create_component(\"AppSwc2\", app_swc2_type) # create a data type sw_base_type = package.create_sw_base_type( \"SwBaseType\", 16, BaseTypeEncoding.TwosComplement ) sr_data_type = package.create_implementation_data_type( ImplementationDataTypeSettings.Value(\"ImplValue\", base_type=sw_base_type) ) # create interfaces and ports cs_interface = package.create_client_server_interface(\"CsInterface\") cs_operation = cs_interface.create_operation(\"CsOp\") sr_interface = package.create_sender_receiver_interface(\"SrInterface\") sr_data = sr_interface.create_data_element(\"SrData\", sr_data_type) # app1 provides the server interface, app2 requires it app1_cs_p_port = app_swc1_type.create_p_port(\"P_CS\", cs_interface) app2_cs_r_port = app_swc2_type.create_r_port(\"R_CS\", cs_interface) # connect the ports composition_type.create_assembly_connector( \"CS_Assembly\", app1_cs_p_port, app_swc1, app2_cs_r_port, app_swc2 ) # app1 receives data from app2 using the sender-receiver interface app1_sr_r_port = app_swc1_type.create_r_port(\"R_Sr\", sr_interface) app2_sr_p_port = app_swc2_type.create_p_port(\"P_Sr\", sr_interface) # connect the ports composition_type.create_assembly_connector( \"Sr_Assembly\", app1_sr_r_port, app_swc1, app2_sr_p_port, app_swc2 ) # create internal behavior for app1 app1_behavior = app_swc1_type.create_swc_internal_behavior(\"InternalBehavior\") # app1 needs a server runnable to process calls to its cs_operation server_runnable = app1_behavior.create_runnable_entity(\"ServerRunnable\") app1_behavior.create_operation_invoked_event( \"CsOperationEvent\", server_runnable, cs_operation, app1_cs_p_port ) # create a cyclically triggered runnable for app1 cyclic_runnable = app1_behavior.create_runnable_entity(\"CyclicRunnable\") app1_behavior.create_timing_event(\"CyclicEvent\", cyclic_runnable, 0.01) # allow the cyclic runnable to read data from the sender-receiver port cyclic_runnable.create_data_receive_point_by_argument( \"ReceiveData\", sr_data, app1_sr_r_port ) # create internal behavior for app2 app2_behavior = app_swc2_type.create_swc_internal_behavior(\"InternalBehavior\") # app2 has a cyclic runnable that sends data to app1 and calls the server operation cyclic_runnable = app2_behavior.create_runnable_entity(\"CyclicRunnable\") app2_behavior.create_timing_event(\"CyclicEvent\", cyclic_runnable, 0.01) # allow the cyclic runnable to send data to app1 cyclic_runnable.create_data_send_point(\"SendData\", sr_data, app2_sr_p_port) # allow the cyclic runnable to call the server operation on app1 cyclic_runnable.create_synchronous_server_call_point( \"ServerCall\", cs_operation, app2_cs_r_port )","title":"Example"},{"location":"software_component_api/#api","text":"","title":"API"},{"location":"software_component_api/#autosar_data.abstraction.software_component","text":"","title":"software_component"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PortInterface","text":"PortInterface: TypeAlias = Union[ SenderReceiverInterface, ClientServerInterface, ModeSwitchInterface, NvDataInterface, ParameterInterface, TriggerInterface, ]","title":"PortInterface"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PortPrototype","text":"PortPrototype: TypeAlias = Union[ PPortPrototype, PRPortPrototype, RPortPrototype ]","title":"PortPrototype"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RTEEvent","text":"RTEEvent: TypeAlias = Union[ AsynchronousServerCallReturnsEvent, BackgroundEvent, DataReceiveErrorEvent, DataReceivedEvent, DataSendCompletedEvent, DataWriteCompletedEvent, ExternalTriggerOccurredEvent, InitEvent, InternalTriggerOccurredEvent, ModeSwitchedAckEvent, OperationInvokedEvent, OsTaskExecutionEvent, SwcModeManagerErrorEvent, SwcModeSwitchEvent, TimingEvent, TransformerHardErrorEvent, ]","title":"RTEEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwComponentType","text":"SwComponentType: TypeAlias = Union[ ApplicationSwComponentType, ComplexDeviceDriverSwComponentType, CompositionSwComponentType, EcuAbstractionSwComponentType, SensorActuatorSwComponentType, ServiceSwComponentType, ]","title":"SwComponentType"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationError","text":"ApplicationError(element: Element) An ApplicationError represents an error that can be returned by a client server operation","title":"ApplicationError"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationError.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationError.error_code","text":"error_code: int the error code of the application error","title":"error_code"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationError.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationSwComponentType","text":"ApplicationSwComponentType(element: Element) An ApplicationSwComponentType is a software component that provides application functionality Use [ ArPackage::create_application_sw_component_type ] to create a new application sw component type.","title":"ApplicationSwComponentType"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationSwComponentType.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationSwComponentType.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationSwComponentType.create_p_port","text":"create_p_port( name: str, port_interface: PortInterface ) -> PPortPrototype create a new provided port with the given name and port interface","title":"create_p_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationSwComponentType.create_port_group","text":"create_port_group(name: str) -> PortGroup create a new port group","title":"create_port_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationSwComponentType.create_pr_port","text":"create_pr_port( name: str, port_interface: PortInterface ) -> PRPortPrototype create a new provided required port with the given name and port interface","title":"create_pr_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationSwComponentType.create_r_port","text":"create_r_port( name: str, port_interface: PortInterface ) -> RPortPrototype create a new required port with the given name and port interface","title":"create_r_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationSwComponentType.create_swc_internal_behavior","text":"create_swc_internal_behavior( name: str, ) -> SwcInternalBehavior create an SwcInternalBehavior for the component A component can have only one internal behavior, but since the internal behavior is a variation point, more than one internal behavior can be created. In this case the variation point settings must ensure that only one internal behavior is active.","title":"create_swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationSwComponentType.instances","text":"instances() -> List[SwComponentPrototype] list all instances of the component type","title":"instances"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationSwComponentType.parent_compositions","text":"parent_compositions() -> List[CompositionSwComponentType] list all compositions containing instances of the component type","title":"parent_compositions"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationSwComponentType.ports","text":"ports() -> Iterator[PortPrototype] get an iterator over the ports of the component","title":"ports"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ApplicationSwComponentType.swc_internal_behaviors","text":"swc_internal_behaviors() -> Iterator[SwcInternalBehavior] iterate over all swc internal behaviors - typically zero or one","title":"swc_internal_behaviors"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ArgumentDataPrototype","text":"ArgumentDataPrototype(element: Element) An ArgumentDataPrototype represents an argument in a ClientServerOperation","title":"ArgumentDataPrototype"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ArgumentDataPrototype.data_type","text":"data_type: Optional[AutosarDataType] data type of the argument","title":"data_type"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ArgumentDataPrototype.direction","text":"direction: Optional[ArgumentDirection] direction of the argument","title":"direction"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ArgumentDataPrototype.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ArgumentDataPrototype.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ArgumentDirection","text":"The ArgumentDirection defines the direction of an argument in a ClientServerOperation Input arguments are used to pass data from the client to the server and are usualy passed by value. Output arguments are used to pass data from the server to the client and are usually passed by reference. In/Out arguments are used to pass data in both directions and are usually passed by reference.","title":"ArgumentDirection"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ArgumentDirection.In","text":"In: ArgumentDirection","title":"In"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ArgumentDirection.InOut","text":"InOut: ArgumentDirection","title":"InOut"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ArgumentDirection.Out","text":"Out: ArgumentDirection","title":"Out"},{"location":"software_component_api/#autosar_data.abstraction.software_component.AssemblySwConnector","text":"AssemblySwConnector(element: Element) An AssemblySwConnector connects ports of two SwCompositionType s.","title":"AssemblySwConnector"},{"location":"software_component_api/#autosar_data.abstraction.software_component.AssemblySwConnector.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.AssemblySwConnector.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.AssemblySwConnector.p_port","text":"p_port: Optional[PortPrototype] get the provided port of the assembly connector","title":"p_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.AssemblySwConnector.p_sw_component","text":"p_sw_component: Optional[SwComponentPrototype] get the software component that contains the provided port of the assembly connector","title":"p_sw_component"},{"location":"software_component_api/#autosar_data.abstraction.software_component.AssemblySwConnector.r_port","text":"r_port: Optional[PortPrototype] get the required port of the assembly connector","title":"r_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.AssemblySwConnector.r_sw_component","text":"r_sw_component: Optional[SwComponentPrototype] get the software component that contains the required port of the assembly connector","title":"r_sw_component"},{"location":"software_component_api/#autosar_data.abstraction.software_component.AsynchronousServerCallReturnsEvent","text":"AsynchronousServerCallReturnsEvent(element: Element) an asynchronous server call completed","title":"AsynchronousServerCallReturnsEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.AsynchronousServerCallReturnsEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.AsynchronousServerCallReturnsEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.AsynchronousServerCallReturnsEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.AsynchronousServerCallReturnsEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.BackgroundEvent","text":"BackgroundEvent(element: Element) starts a runnable for background processing at low priority","title":"BackgroundEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.BackgroundEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.BackgroundEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.BackgroundEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.BackgroundEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerInterface","text":"ClientServerInterface(element: Element) A ClientServerInterface defines a set of operations that can be implemented by a server and called by a client Use [ ArPackage::create_client_server_interface ] to create a new client server interface","title":"ClientServerInterface"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerInterface.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerInterface.is_service","text":"is_service: Optional[bool] Get/Set if the client server interface is a service interface","title":"is_service"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerInterface.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerInterface.create_operation","text":"create_operation(name: str) -> ClientServerOperation add an operation to the client server interface","title":"create_operation"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerInterface.create_possible_error","text":"create_possible_error( name: str, error_code: int ) -> ApplicationError Create a new ClientServerInterface Add a possible error to the client server interface","title":"create_possible_error"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerInterface.operations","text":"operations() -> Iterator[ClientServerOperation] iterate over all operations","title":"operations"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerInterface.possible_errors","text":"possible_errors() -> Iterator[ApplicationError] iterate over all application errors","title":"possible_errors"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerOperation","text":"ClientServerOperation(element: Element) A ClientServerOperation defines an operation in a ClientServerInterface","title":"ClientServerOperation"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerOperation.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerOperation.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerOperation.add_possible_error","text":"add_possible_error(error: ApplicationError) -> None add a reference to possible error to the operation","title":"add_possible_error"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerOperation.arguments","text":"arguments() -> Iterator[ArgumentDataPrototype] iterate over all arguments","title":"arguments"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerOperation.create_argument","text":"create_argument( name: str, data_type: AutosarDataType, direction: ArgumentDirection, ) -> ArgumentDataPrototype Create a new ClientServerOperation Add an argument to the operation","title":"create_argument"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ClientServerOperation.possible_errors","text":"possible_errors() -> Iterator[ApplicationError] Get the possible errors of the operation","title":"possible_errors"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ComplexDeviceDriverSwComponentType","text":"ComplexDeviceDriverSwComponentType(element: Element) A ComplexDeviceDriverSwComponentType is a software component that provides complex device driver functionality Use [ ArPackage::create_complex_device_driver_sw_component_type ] to create a new complex device driver sw component type.","title":"ComplexDeviceDriverSwComponentType"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ComplexDeviceDriverSwComponentType.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ComplexDeviceDriverSwComponentType.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ComplexDeviceDriverSwComponentType.create_p_port","text":"create_p_port( name: str, port_interface: PortInterface ) -> PPortPrototype create a new provided port with the given name and port interface","title":"create_p_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ComplexDeviceDriverSwComponentType.create_port_group","text":"create_port_group(name: str) -> PortGroup create a new port group","title":"create_port_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ComplexDeviceDriverSwComponentType.create_pr_port","text":"create_pr_port( name: str, port_interface: PortInterface ) -> PRPortPrototype create a new provided required port with the given name and port interface","title":"create_pr_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ComplexDeviceDriverSwComponentType.create_r_port","text":"create_r_port( name: str, port_interface: PortInterface ) -> RPortPrototype create a new required port with the given name and port interface","title":"create_r_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ComplexDeviceDriverSwComponentType.create_swc_internal_behavior","text":"create_swc_internal_behavior( name: str, ) -> SwcInternalBehavior create an SwcInternalBehavior for the component A component can have only one internal behavior, but since the internal behavior is a variation point, more than one internal behavior can be created. In this case the variation point settings must ensure that only one internal behavior is active.","title":"create_swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ComplexDeviceDriverSwComponentType.instances","text":"instances() -> List[SwComponentPrototype] list of all instances of the component type","title":"instances"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ComplexDeviceDriverSwComponentType.parent_compositions","text":"parent_compositions() -> List[CompositionSwComponentType] list all compositions containing instances of the component type","title":"parent_compositions"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ComplexDeviceDriverSwComponentType.ports","text":"ports() -> Iterator[PortPrototype] get an iterator over the ports of the component","title":"ports"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ComplexDeviceDriverSwComponentType.swc_internal_behaviors","text":"swc_internal_behaviors() -> Iterator[SwcInternalBehavior] iterate over all swc internal behaviors - typically zero or one","title":"swc_internal_behaviors"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType","text":"CompositionSwComponentType(element: Element) A CompositionSwComponentType is a software component that contains other software components Use [ ArPackage::create_composition_sw_component_type ] to create a new composition sw component type.","title":"CompositionSwComponentType"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.components","text":"components() -> Iterator[SwComponentPrototype] get an iterator over the components of the composition","title":"components"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.connectors","text":"connectors() -> Iterator[AssemblySwConnector] iterate over all connectors","title":"connectors"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.create_assembly_connector","text":"create_assembly_connector( name: str, port_1: PortPrototype, sw_prototype_1: SwComponentPrototype, port_2: PortPrototype, sw_prototype_2: SwComponentPrototype, ) -> AssemblySwConnector create a new delegation connector between an inner port and an outer port this is the actual implementation of the public method, but without the generic parameters create a new assembly connector between two ports of contained software components The two ports must be compatible.","title":"create_assembly_connector"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.create_component","text":"create_component( name: str, component_type: SwComponentType ) -> SwComponentPrototype create a component of type component_type in the composition It is not allowed to form cycles in the composition hierarchy, and this will return an error","title":"create_component"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.create_delegation_connector","text":"create_delegation_connector( name: str, inner_port: PortPrototype, inner_sw_prototype: SwComponentPrototype, outer_port: PortPrototype, ) -> DelegationSwConnector create a new delegation connector between an inner port and an outer port The two ports must be compatible.","title":"create_delegation_connector"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.create_p_port","text":"create_p_port( name: str, port_interface: PortInterface ) -> PPortPrototype create a new provided port with the given name and port interface","title":"create_p_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.create_pass_through_connector","text":"create_pass_through_connector( name: str, port_1: PortPrototype, port_2: PortPrototype ) -> PassThroughSwConnector create a new passthrough connector between two outer ports of the composition The two ports must be compatible.","title":"create_pass_through_connector"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.create_port_group","text":"create_port_group(name: str) -> PortGroup create a new port group","title":"create_port_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.create_pr_port","text":"create_pr_port( name: str, port_interface: PortInterface ) -> PRPortPrototype create a new provided required port with the given name and port interface","title":"create_pr_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.create_r_port","text":"create_r_port( name: str, port_interface: PortInterface ) -> RPortPrototype create a new required port with the given name and port interface","title":"create_r_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.instances","text":"instances() -> List[SwComponentPrototype] list of all instances of the component type","title":"instances"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.is_parent_of","text":"is_parent_of(other: SwComponentType) -> bool check if the composition is a parent (or grand-parent, etc.) of the component","title":"is_parent_of"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.parent_compositions","text":"parent_compositions() -> Iterator[ CompositionSwComponentType ] iterator over all compositions containing instances of the component type","title":"parent_compositions"},{"location":"software_component_api/#autosar_data.abstraction.software_component.CompositionSwComponentType.ports","text":"ports() -> Iterator[PortPrototype] get an iterator over the ports of the component","title":"ports"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataReceiveErrorEvent","text":"DataReceiveErrorEvent(element: Element) A DataReceiveErrorEvent is a subclass of RTEEvent which triggers a RunnableEntity when a data receive error occurs","title":"DataReceiveErrorEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataReceiveErrorEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataReceiveErrorEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataReceiveErrorEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataReceiveErrorEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataReceivedEvent","text":"DataReceivedEvent(element: Element) A DataReceivedEvent is a subclass of RTEEvent which triggers a RunnableEntity when data is received","title":"DataReceivedEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataReceivedEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataReceivedEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataReceivedEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataReceivedEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataReceivedEvent.variable_data_prototype","text":"variable_data_prototype: Optional[ Tuple[VariableDataPrototype, PortPrototype] ] Get the VariableDataPrototype that triggers the DataReceivedEvent","title":"variable_data_prototype"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataReceivedEvent.set_variable_data_prototype","text":"set_variable_data_prototype( variable_data_prototype: VariableDataPrototype, context_port: PPortPrototype, ) -> None Set the VariableDataPrototype that triggers the DataReceivedEvent","title":"set_variable_data_prototype"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataSendCompletedEvent","text":"DataSendCompletedEvent(element: Element) A DataSendCompletedEvent is a subclass of RTEEvent which triggers a RunnableEntity when data is sent","title":"DataSendCompletedEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataSendCompletedEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataSendCompletedEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataSendCompletedEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataSendCompletedEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataWriteCompletedEvent","text":"DataWriteCompletedEvent(element: Element) A DataWriteCompletedEvent is a subclass of RTEEvent which triggers a RunnableEntity when data is written","title":"DataWriteCompletedEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataWriteCompletedEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataWriteCompletedEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataWriteCompletedEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DataWriteCompletedEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DelegationSwConnector","text":"DelegationSwConnector(element: Element) A DelegationSwConnector connects a port of a software component that is contained inside a SwCompositionType with a port of the SwCompositionType .","title":"DelegationSwConnector"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DelegationSwConnector.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DelegationSwConnector.inner_port","text":"inner_port: Optional[PortPrototype] get the inner port of the delegation connector","title":"inner_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DelegationSwConnector.inner_sw_component","text":"inner_sw_component: Optional[SwComponentPrototype] get the software component that contains the inner port of the delegation connector","title":"inner_sw_component"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DelegationSwConnector.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.DelegationSwConnector.outer_port","text":"outer_port: Optional[PortPrototype] get the outer port of the delegation connector","title":"outer_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.EcuAbstractionSwComponentType","text":"EcuAbstractionSwComponentType(element: Element) The EcuAbstractionSwComponentType is a special AtomicSwComponentType that resides between a software-component that wants to access ECU periphery and the Microcontroller Abstraction Use [ ArPackage::create_ecu_abstraction_sw_component_type ] to create a new ECU abstraction sw component type.","title":"EcuAbstractionSwComponentType"},{"location":"software_component_api/#autosar_data.abstraction.software_component.EcuAbstractionSwComponentType.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.EcuAbstractionSwComponentType.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.EcuAbstractionSwComponentType.create_p_port","text":"create_p_port( name: str, port_interface: PortInterface ) -> PPortPrototype create a new provided port with the given name and port interface","title":"create_p_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.EcuAbstractionSwComponentType.create_port_group","text":"create_port_group(name: str) -> PortGroup create a new port group","title":"create_port_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.EcuAbstractionSwComponentType.create_pr_port","text":"create_pr_port( name: str, port_interface: PortInterface ) -> PRPortPrototype create a new provided required port with the given name and port interface","title":"create_pr_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.EcuAbstractionSwComponentType.create_r_port","text":"create_r_port( name: str, port_interface: PortInterface ) -> RPortPrototype create a new required port with the given name and port interface","title":"create_r_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.EcuAbstractionSwComponentType.create_swc_internal_behavior","text":"create_swc_internal_behavior( name: str, ) -> SwcInternalBehavior create an SwcInternalBehavior for the component A component can have only one internal behavior, but since the internal behavior is a variation point, more than one internal behavior can be created. In this case the variation point settings must ensure that only one internal behavior is active.","title":"create_swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.EcuAbstractionSwComponentType.instances","text":"instances() -> List[SwComponentPrototype] list all instances of the component type","title":"instances"},{"location":"software_component_api/#autosar_data.abstraction.software_component.EcuAbstractionSwComponentType.parent_compositions","text":"parent_compositions() -> List[CompositionSwComponentType] list all compositions containing instances of the component type","title":"parent_compositions"},{"location":"software_component_api/#autosar_data.abstraction.software_component.EcuAbstractionSwComponentType.ports","text":"ports() -> Iterator[PortPrototype] get an iterator over the ports of the component","title":"ports"},{"location":"software_component_api/#autosar_data.abstraction.software_component.EcuAbstractionSwComponentType.swc_internal_behaviors","text":"swc_internal_behaviors() -> Iterator[SwcInternalBehavior] iterate over all swc internal behaviors - typically zero or one","title":"swc_internal_behaviors"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ExternalTriggerOccurredEvent","text":"ExternalTriggerOccurredEvent(element: Element) A ExternalTriggerOccurredEvent is a subclass of RTEEvent which triggers a RunnableEntity when an external trigger occurs","title":"ExternalTriggerOccurredEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ExternalTriggerOccurredEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ExternalTriggerOccurredEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ExternalTriggerOccurredEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ExternalTriggerOccurredEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.InitEvent","text":"InitEvent(element: Element) A InitEvent is a subclass of RTEEvent which triggers a RunnableEntity when the software component is initialized","title":"InitEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.InitEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.InitEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.InitEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.InitEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.InternalTriggerOccurredEvent","text":"InternalTriggerOccurredEvent(element: Element) A InternalTriggerOccurredEvent is a subclass of RTEEvent which triggers a RunnableEntity when an internal trigger occurs","title":"InternalTriggerOccurredEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.InternalTriggerOccurredEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.InternalTriggerOccurredEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.InternalTriggerOccurredEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.InternalTriggerOccurredEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeAccessPoint","text":"ModeAccessPoint(element: Element) A ModeAccessPoint provides the ability to access the current mode of a ModeDeclarationGroup","title":"ModeAccessPoint"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeAccessPoint.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeAccessPoint.mode_group","text":"mode_group: Optional[Tuple[ModeGroup, PortPrototype]]","title":"mode_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeAccessPoint.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeAccessPoint.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] Get the RunnableEntity that contains the ModeAccessPoint","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeAccessPoint.set_mode_group","text":"set_mode_group( mode_group: ModeGroup, context_port: PortPrototype ) -> None Set the mode group and context port of the ModeAccessPoint","title":"set_mode_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeActivationKind","text":"Kind of mode switch condition used for activation of an event","title":"ModeActivationKind"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeActivationKind.OnEntry","text":"OnEntry: ModeActivationKind The mode is activated on entry to the mode.","title":"OnEntry"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeActivationKind.OnExit","text":"OnExit: ModeActivationKind The mode is activated on exit from the mode.","title":"OnExit"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeActivationKind.OnTransition","text":"OnTransition: ModeActivationKind The mode is activated on transition from the first mode to the second mode.","title":"OnTransition"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclaration","text":"ModeDeclaration(element: Element) A ModeDeclaration represents a mode declaration in a ModeDeclarationGroup","title":"ModeDeclaration"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclaration.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclaration.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclaration.value","text":"value: Optional[int] value of the mode declaration, if any.","title":"value"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclarationGroup","text":"ModeDeclarationGroup(element: Element) A ModeDeclarationGroup is a collection of mode declarations.","title":"ModeDeclarationGroup"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclarationGroup.category","text":"category: Optional[ModeDeclarationGroupCategory] category of the mode declaration group","title":"category"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclarationGroup.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclarationGroup.initial_mode","text":"initial_mode: Optional[ModeDeclaration] initial mode of the mode declaration group, if any","title":"initial_mode"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclarationGroup.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclarationGroup.on_transition_value","text":"on_transition_value: Optional[int] Value to be used when switching to the mode declaration group, if any. This is the onTransitionValue attribute of the mode declaration group.","title":"on_transition_value"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclarationGroup.create_mode_declaration","text":"create_mode_declaration(name: str) -> ModeDeclaration Create a new mode declaration in the group","title":"create_mode_declaration"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclarationGroup.mode_declarations","text":"mode_declarations() -> Iterator[ModeDeclaration] iterate over all mode declarations in the group","title":"mode_declarations"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclarationGroupCategory","text":"Category of mode declaration groupy, which defines the ordering of the modes in the group","title":"ModeDeclarationGroupCategory"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclarationGroupCategory.AlphabeticOrder","text":"AlphabeticOrder: ModeDeclarationGroupCategory Alphabetic order of the modes in the group.","title":"AlphabeticOrder"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeDeclarationGroupCategory.ExplicitOrder","text":"ExplicitOrder: ModeDeclarationGroupCategory Ordering of modes in the mode declaration group is made explicit by the value, which must be set for each mode. Additonally, the on_transition_value attribute must be set in this case.","title":"ExplicitOrder"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeGroup","text":"ModeGroup(element: Element) A ModeGroup represents a mode group in a ModeSwitchInterface","title":"ModeGroup"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeGroup.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeGroup.mode_declaration_group","text":"mode_declaration_group: ModeDeclarationGroup Get/Set the mode declaration group of the mode group","title":"mode_declaration_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeGroup.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchInterface","text":"ModeSwitchInterface(element: Element) A ModeSwitchInterface defines a set of modes that can be switched Use [ ArPackage::create_mode_switch_interface ] to create a new mode switch interface","title":"ModeSwitchInterface"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchInterface.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchInterface.is_service","text":"is_service: Optional[bool] Get/Set if the mode switch interface is a service interface","title":"is_service"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchInterface.mode_group","text":"mode_group: Optional[ModeGroup] Get the mode group of the mode switch interface","title":"mode_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchInterface.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchInterface.create_mode_group","text":"create_mode_group( name: str, mode_declaration_group: ModeDeclarationGroup ) -> ModeGroup Create a new mode group in the mode switch interface The ModeSwitchInterface can only contain one mode group","title":"create_mode_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchPoint","text":"ModeSwitchPoint(element: Element) A ModeSwitchPoint allows a RunnableEntity to switch modes in a ModeDeclarationGroup","title":"ModeSwitchPoint"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchPoint.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchPoint.mode_group","text":"mode_group: Optional[Tuple[ModeGroup, PortPrototype]]","title":"mode_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchPoint.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchPoint.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] Get the RunnableEntity that contains the ModeSwitchPoint","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchPoint.set_mode_group","text":"set_mode_group( mode_group: ModeGroup, context_port: PortPrototype ) -> None Set the mode group and context port of the ModeSwitchPoint","title":"set_mode_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchedAckEvent","text":"ModeSwitchedAckEvent(element: Element) A ModeSwitchedAckEvent is a subclass of RTEEvent which triggers a RunnableEntity when a mode switch is acknowledged","title":"ModeSwitchedAckEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchedAckEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchedAckEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchedAckEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ModeSwitchedAckEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.NvDataInterface","text":"NvDataInterface(element: Element) An NvDataInterface defines non-volatile data that can be accessed through the interface Use [ ArPackage::create_nv_data_interface ] to create a new non-volatile data interface","title":"NvDataInterface"},{"location":"software_component_api/#autosar_data.abstraction.software_component.NvDataInterface.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.NvDataInterface.is_service","text":"is_service: Optional[bool] Get/Set if the Nv-data interface is a service interface","title":"is_service"},{"location":"software_component_api/#autosar_data.abstraction.software_component.NvDataInterface.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.OperationInvokedEvent","text":"OperationInvokedEvent(element: Element) A OperationInvokedEvent is a subclass of RTEEvent which triggers a RunnableEntity when an operation is invoked","title":"OperationInvokedEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.OperationInvokedEvent.client_server_operation","text":"client_server_operation: Tuple[ ClientServerOperation, PPortPrototype ] Get the ClientServerOperation that triggers the OperationInvokedEvent","title":"client_server_operation"},{"location":"software_component_api/#autosar_data.abstraction.software_component.OperationInvokedEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.OperationInvokedEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.OperationInvokedEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the OperationInvokedEvent","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.OperationInvokedEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.OperationInvokedEvent.set_client_server_operation","text":"set_client_server_operation( client_server_operation: ClientServerOperation, context_p_port: PPortPrototype, ) -> None Set the ClientServerOperation that is triggers the OperationInvokedEvent","title":"set_client_server_operation"},{"location":"software_component_api/#autosar_data.abstraction.software_component.OsTaskExecutionEvent","text":"OsTaskExecutionEvent(element: Element) A OsTaskExecutionEvent is a subclass of RTEEvent which triggers a RunnableEntity when an OS task is executed","title":"OsTaskExecutionEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.OsTaskExecutionEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.OsTaskExecutionEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.OsTaskExecutionEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.OsTaskExecutionEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PPortPrototype","text":"PPortPrototype(element: Element) PPortPrototype represents a provided port prototype","title":"PPortPrototype"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PPortPrototype.component_type","text":"component_type: Optional[SwComponentType] component type containing the port prototype","title":"component_type"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PPortPrototype.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PPortPrototype.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PPortPrototype.port_interface","text":"port_interface: Optional[PortInterface] port interface of the port prototype","title":"port_interface"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PRPortPrototype","text":"PRPortPrototype(element: Element) PRPortPrototype represents a provided and required port prototype","title":"PRPortPrototype"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PRPortPrototype.component_type","text":"component_type: Optional[SwComponentType] component type containing the port prototype","title":"component_type"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PRPortPrototype.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PRPortPrototype.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PRPortPrototype.port_interface","text":"port_interface: Optional[PortInterface] port interface of the port prototype","title":"port_interface"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ParameterDataPrototype","text":"ParameterDataPrototype(element: Element) A ParameterDataPrototype represents a parameter in a ParameterInterface","title":"ParameterDataPrototype"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ParameterDataPrototype.data_type","text":"data_type: Optional[AutosarDataType] data type of the parameter","title":"data_type"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ParameterDataPrototype.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ParameterDataPrototype.init_value","text":"init_value: Optional[ValueSpecification]","title":"init_value"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ParameterDataPrototype.interface","text":"interface: Optional[SenderReceiverInterface] Get the interface containing the parameter","title":"interface"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ParameterDataPrototype.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ParameterInterface","text":"ParameterInterface(element: Element) A ParameterInterface defines a set of parameters that can be accessed Use [ ArPackage::create_parameter_interface ] to create a new parameter interface","title":"ParameterInterface"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ParameterInterface.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ParameterInterface.is_service","text":"is_service: Optional[bool] Get/Set if the parameter interface is a service interface","title":"is_service"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ParameterInterface.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ParameterInterface.create_parameter","text":"create_parameter( name: str, data_type: AutosarDataType ) -> ParameterDataPrototype Add a new parameter to the parameter interface","title":"create_parameter"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ParameterInterface.parameters","text":"parameters() -> Iterator[ParameterDataPrototype] iterate over all parameters","title":"parameters"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PassThroughSwConnector","text":"PassThroughSwConnector(element: Element) A PassThroughSwConnector connects two ports of a SwCompositionType .","title":"PassThroughSwConnector"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PassThroughSwConnector.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PassThroughSwConnector.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PassThroughSwConnector.p_port","text":"p_port: Optional[PortPrototype] get the provided port of the pass-through connector","title":"p_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PassThroughSwConnector.r_port","text":"r_port: Optional[PortPrototype] get the required port of the pass-through connector","title":"r_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PortGroup","text":"PortGroup(element: Element) PortGroup represents a group of ports","title":"PortGroup"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PortGroup.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.PortGroup.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RPortPrototype","text":"RPortPrototype(element: Element) RPortPrototype represents a required port prototype","title":"RPortPrototype"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RPortPrototype.component_type","text":"component_type: Optional[SwComponentType] component type containing the port prototype","title":"component_type"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RPortPrototype.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RPortPrototype.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RPortPrototype.port_interface","text":"port_interface: Optional[PortInterface] port interface of the port prototype","title":"port_interface"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RootSwCompositionPrototype","text":"RootSwCompositionPrototype(element: Element) The RootSwCompositionPrototype is a special kind of SwComponentPrototype that represents the root of the composition hierarchy","title":"RootSwCompositionPrototype"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RootSwCompositionPrototype.composition","text":"composition: Optional[CompositionSwComponentType] composition that this root component is based on","title":"composition"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RootSwCompositionPrototype.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RootSwCompositionPrototype.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity","text":"RunnableEntity(element: Element) A RunnableEntity is a function that can be executed by the RTE","title":"RunnableEntity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] SwcInternalBehavior that contains the RunnableEntity","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.create_data_read_access","text":"create_data_read_access( name: str, data_element: VariableDataPrototype, port: PortPrototype, ) -> VariableAccess add implicit read access to a data element of a sender-receiver PortPrototype this results in Rte_IRead_<port>_<data_element> being generated","title":"create_data_read_access"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.create_data_receive_point_by_argument","text":"create_data_receive_point_by_argument( name: str, data_element: VariableDataPrototype, port: PortPrototype, ) -> VariableAccess add explicit read access by argument to a data element of a sender-receiver PortPrototype","title":"create_data_receive_point_by_argument"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.create_data_receive_point_by_value","text":"create_data_receive_point_by_value( name: str, data_element: VariableDataPrototype, port: PortPrototype, ) -> VariableAccess add explicit read access by value to a data element of a sender-receiver PortPrototype","title":"create_data_receive_point_by_value"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.create_data_send_point","text":"create_data_send_point( name: str, data_element: VariableDataPrototype, port: PortPrototype, ) -> VariableAccess add a data send point to a data element of a sender-receiver PortPrototype","title":"create_data_send_point"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.create_data_write_access","text":"create_data_write_access( name: str, data_element: VariableDataPrototype, port: PortPrototype, ) -> VariableAccess add implicit write access to a data element of a sender-receiver PortPrototype this results in Rte_IWrite_<port>_<data_element> being generated","title":"create_data_write_access"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.create_mode_access_point","text":"create_mode_access_point( name: str, mode_group: ModeGroup, context_port: PortPrototype, ) -> ModeAccessPoint create a mode access point that allows the runnable to access the current mode of a mode group","title":"create_mode_access_point"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.create_mode_switch_point","text":"create_mode_switch_point( name: str, mode_group: ModeGroup, context_port: PortPrototype, ) -> ModeSwitchPoint create a mode switch point that allows the runnable to switch modes in a mode group","title":"create_mode_switch_point"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.create_synchronous_server_call_point","text":"create_synchronous_server_call_point( name: str, operation: ClientServerOperation, port: PPortPrototype, ) -> SynchronousServerCallPoint create a synchronous server call point that allows the runnable to call a server operation","title":"create_synchronous_server_call_point"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.data_read_accesses","text":"data_read_accesses() -> Iterator[VariableAccess] iterate over all data read accesses of the runnable entity","title":"data_read_accesses"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.data_receive_points_by_argument","text":"data_receive_points_by_argument() -> Iterator[ VariableAccess ] iterate over all data receive points by argument of the runnable entity","title":"data_receive_points_by_argument"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.data_receive_points_by_value","text":"data_receive_points_by_value() -> Iterator[VariableAccess] iterate over all data receive points by value of the runnable entity","title":"data_receive_points_by_value"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.data_send_points","text":"data_send_points() -> Iterator[VariableAccess] iterate over all data send points of the runnable entity","title":"data_send_points"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.data_write_accesses","text":"data_write_accesses() -> Iterator[VariableAccess] iterate over all data write accesses of the runnable entity","title":"data_write_accesses"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.events","text":"events() -> List[RTEEvent] Iterate over all events that can trigger the RunnableEntity","title":"events"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.mode_access_points","text":"mode_access_points() -> Iterator[ModeAccessPoint] iterate over all mode access points of the runnable entity","title":"mode_access_points"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.mode_switch_points","text":"mode_switch_points() -> Iterator[ModeSwitchPoint] iterate over all mode switch points of the runnable entity","title":"mode_switch_points"},{"location":"software_component_api/#autosar_data.abstraction.software_component.RunnableEntity.synchronous_server_call_points","text":"synchronous_server_call_points() -> Iterator[ SynchronousServerCallPoint ] iterate over all synchronous server call points of the runnable entity","title":"synchronous_server_call_points"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SenderReceiverInterface","text":"SenderReceiverInterface(element: Element) A SenderReceiverInterface defines a set of data elements that can be sent and received Use [ ArPackage::create_sender_receiver_interface ] to create a new sender receiver interface","title":"SenderReceiverInterface"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SenderReceiverInterface.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SenderReceiverInterface.is_service","text":"is_service: Optional[bool] Get/Set if the sender/receiver interface is a service interface","title":"is_service"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SenderReceiverInterface.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SenderReceiverInterface.create_data_element","text":"create_data_element( name: str, data_type: AutosarDataType ) -> VariableDataPrototype Add a new data element to the sender receiver interface","title":"create_data_element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SenderReceiverInterface.data_elements","text":"data_elements() -> Iterator[VariableDataPrototype] iterate over all data elements","title":"data_elements"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SensorActuatorSwComponentType","text":"SensorActuatorSwComponentType(element: Element) SensorActuatorSwComponentType is used to connect sensor/acutator devices to the ECU configuration Use [ ArPackage::create_sensor_actuator_sw_component_type ] to create a new sensor/actuator sw component type.","title":"SensorActuatorSwComponentType"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SensorActuatorSwComponentType.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SensorActuatorSwComponentType.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SensorActuatorSwComponentType.create_p_port","text":"create_p_port( name: str, port_interface: PortInterface ) -> PPortPrototype create a new provided port with the given name and port interface","title":"create_p_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SensorActuatorSwComponentType.create_port_group","text":"create_port_group(name: str) -> PortGroup create a new port group","title":"create_port_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SensorActuatorSwComponentType.create_pr_port","text":"create_pr_port( name: str, port_interface: PortInterface ) -> PRPortPrototype create a new provided required port with the given name and port interface","title":"create_pr_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SensorActuatorSwComponentType.create_r_port","text":"create_r_port( name: str, port_interface: PortInterface ) -> RPortPrototype create a new required port with the given name and port interface","title":"create_r_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SensorActuatorSwComponentType.create_swc_internal_behavior","text":"create_swc_internal_behavior( name: str, ) -> SwcInternalBehavior create an SwcInternalBehavior for the component A component can have only one internal behavior, but since the internal behavior is a variation point, more than one internal behavior can be created. In this case the variation point settings must ensure that only one internal behavior is active.","title":"create_swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SensorActuatorSwComponentType.instances","text":"instances() -> List[SwComponentPrototype] list all instances of the component type","title":"instances"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SensorActuatorSwComponentType.parent_compositions","text":"parent_compositions() -> List[CompositionSwComponentType] list all compositions containing instances of the component type","title":"parent_compositions"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SensorActuatorSwComponentType.ports","text":"ports() -> Iterator[PortPrototype] get an iterator over the ports of the component","title":"ports"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SensorActuatorSwComponentType.swc_internal_behaviors","text":"swc_internal_behaviors() -> Iterator[SwcInternalBehavior] iterate over all swc internal behaviors - typically zero or one","title":"swc_internal_behaviors"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ServiceSwComponentType","text":"ServiceSwComponentType(element: Element) ServiceSwComponentType is used for configuring services for a given ECU. Instances of this class should only be created in ECU Configuration phase for the specific purpose of the service configuration. Use [ ArPackage::create_service_sw_component_type ] to create a new service sw component type.","title":"ServiceSwComponentType"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ServiceSwComponentType.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ServiceSwComponentType.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ServiceSwComponentType.create_p_port","text":"create_p_port( name: str, port_interface: PortInterface ) -> PPortPrototype create a new provided port with the given name and port interface","title":"create_p_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ServiceSwComponentType.create_port_group","text":"create_port_group(name: str) -> PortGroup create a new port group","title":"create_port_group"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ServiceSwComponentType.create_pr_port","text":"create_pr_port( name: str, port_interface: PortInterface ) -> PRPortPrototype create a new provided required port with the given name and port interface","title":"create_pr_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ServiceSwComponentType.create_r_port","text":"create_r_port( name: str, port_interface: PortInterface ) -> RPortPrototype create a new required port with the given name and port interface","title":"create_r_port"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ServiceSwComponentType.create_swc_internal_behavior","text":"create_swc_internal_behavior( name: str, ) -> SwcInternalBehavior create an SwcInternalBehavior for the component A component can have only one internal behavior, but since the internal behavior is a variation point, more than one internal behavior can be created. In this case the variation point settings must ensure that only one internal behavior is active.","title":"create_swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ServiceSwComponentType.instances","text":"instances() -> List[SwComponentPrototype] list all instances of the component type","title":"instances"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ServiceSwComponentType.parent_compositions","text":"parent_compositions() -> List[CompositionSwComponentType] list all compositions containing instances of the component type","title":"parent_compositions"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ServiceSwComponentType.ports","text":"ports() -> Iterator[PortPrototype] get an iterator over the ports of the component","title":"ports"},{"location":"software_component_api/#autosar_data.abstraction.software_component.ServiceSwComponentType.swc_internal_behaviors","text":"swc_internal_behaviors() -> Iterator[SwcInternalBehavior] iterate over all swc internal behaviors - typically zero or one","title":"swc_internal_behaviors"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwComponentPrototype","text":"SwComponentPrototype(element: Element) A SwComponentPrototype is an instance of a software component type","title":"SwComponentPrototype"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwComponentPrototype.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwComponentPrototype.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior","text":"SwcInternalBehavior(element: Element) The SwcInternalBehavior of a software component type describes the details that are needed to generate the RTE.","title":"SwcInternalBehavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.sw_component_type","text":"sw_component_type: Optional[SwComponentType] software component type that contains the SwcInternalBehavior","title":"sw_component_type"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.add_data_type_mapping_set","text":"add_data_type_mapping_set( data_type_mapping_set: DataTypeMappingSet, ) -> None Add a reference to a DataTypeMappingSet to the SwcInternalBehavior","title":"add_data_type_mapping_set"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.create_background_event","text":"create_background_event( name: str, runnable: RunnableEntity ) -> BackgroundEvent Create a new BackgroundEvent in the SwcInternalBehavior that triggers a runnable at low priority","title":"create_background_event"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.create_data_received_event","text":"create_data_received_event( name: str, runnable: RunnableEntity, variable_data_prototype: VariableDataPrototype, context_port: PortPrototype, ) -> DataReceivedEvent Create a new DataReceivedEvent in the SwcInternalBehavior that triggers a runnable when data is received","title":"create_data_received_event"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.create_init_event","text":"create_init_event( name: str, runnable: RunnableEntity ) -> InitEvent Create a new InitEvent in the SwcInternalBehavior","title":"create_init_event"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.create_mode_switch_event","text":"create_mode_switch_event( name: str, runnable: RunnableEntity, activation: ModeActivationKind, context_port: PortPrototype, mode_declaration: ModeDeclaration, /, second_mode_declaration: Optional[ ModeDeclaration ] = None, ) -> SwcModeSwitchEvent create a mode switch event that triggers a runnable in the SwcInternalBehavior when the mode is switched","title":"create_mode_switch_event"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.create_operation_invoked_event","text":"create_operation_invoked_event( name: str, runnable: RunnableEntity, client_server_operation: ClientServerOperation, context_p_port: PPortPrototype, ) -> OperationInvokedEvent Create a new OperationInvokedEvent in the SwcInternalBehavior","title":"create_operation_invoked_event"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.create_os_task_execution_event","text":"create_os_task_execution_event( name: str, runnable: RunnableEntity ) -> OsTaskExecutionEvent Create a new OsTaskExecutionEvent in the SwcInternalBehavior that triggers a runnable when an OS task is executed","title":"create_os_task_execution_event"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.create_runnable_entity","text":"create_runnable_entity(name: str) -> RunnableEntity Create a new RunnableEntity in the SwcInternalBehavior","title":"create_runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.create_timing_event","text":"create_timing_event( name: str, runnable: RunnableEntity, period: float ) -> TimingEvent Create a timing event that triggers a runnable in the SwcInternalBehavior","title":"create_timing_event"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.data_type_mapping_sets","text":"data_type_mapping_sets() -> Iterator[DataTypeMappingSet] iterator over all DataTypeMappingSet references in the SwcInternalBehavior","title":"data_type_mapping_sets"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.events","text":"events() -> Iterator[RTEEvent] create an iterator over all events in the SwcInternalBehavior","title":"events"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcInternalBehavior.runnable_entities","text":"runnable_entities() -> Iterator[RunnableEntity] Get an iterator over all RunnableEntities in the SwcInternalBehavior","title":"runnable_entities"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeManagerErrorEvent","text":"SwcModeManagerErrorEvent(element: Element) A SwcModeManagerErrorEvent is a subclass of RTEEvent which triggers a RunnableEntity when a mode manager error occurs","title":"SwcModeManagerErrorEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeManagerErrorEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeManagerErrorEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeManagerErrorEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeManagerErrorEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeSwitchEvent","text":"SwcModeSwitchEvent(element: Element) A SwcModeSwitchEvent is a subclass of RTEEvent which triggers a RunnableEntity when a mode switch occurs","title":"SwcModeSwitchEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeSwitchEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeSwitchEvent.mode_activation_kind","text":"mode_activation_kind: Optional[ModeActivationKind] Get/Set the mode activation kind of the SwcModeSwitchEvent","title":"mode_activation_kind"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeSwitchEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeSwitchEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeSwitchEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeSwitchEvent.mode_declarations","text":"mode_declarations() -> Optional[List[ModeDeclaration]] Get the mode declarations that trigger the SwcModeSwitchEvent The list contains one or two mode declarations, depending on the activation kind. If the activation kind is OnTransition , the list contains two mode declarations. Otherwise, it contains one mode declaration.","title":"mode_declarations"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SwcModeSwitchEvent.set_mode_declaration","text":"set_mode_declaration( ontext_port: PortPrototype, mode_declaration: ModeDeclaration, /, second_mode_declaration: Optional[ ModeDeclaration ] = None, ) -> None Set the mode declaration within a context port that triggers the SwcModeSwitchEvent The second mode must be provided if the activation kind OnTransition is configured. In that case only transitions between the two modes trigger the event.","title":"set_mode_declaration"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SynchronousServerCallPoint","text":"SynchronousServerCallPoint(element: Element) A SynchronousServerCallPoint allows a RunnableEntity to call a server operation synchronously","title":"SynchronousServerCallPoint"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SynchronousServerCallPoint.client_server_operation","text":"client_server_operation: Optional[ Tuple[ClientServerOperation, PPortPrototype] ] Get the ClientServerOperation that is called by the SynchronousServerCallPoint","title":"client_server_operation"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SynchronousServerCallPoint.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SynchronousServerCallPoint.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SynchronousServerCallPoint.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that contains the SynchronousServerCallPoint","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.SynchronousServerCallPoint.set_client_server_operation","text":"set_client_server_operation( client_server_operation: ClientServerOperation, context_p_port: PPortPrototype, ) -> None Set the ClientServerOperation that is called by the SynchronousServerCallPoint","title":"set_client_server_operation"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TimingEvent","text":"TimingEvent(element: Element) A TimingEvent is a subclass of RTEEvent which triggers a RunnableEntity periodically","title":"TimingEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TimingEvent.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TimingEvent.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TimingEvent.period","text":"period: Optional[float] period of the TimingEvent","title":"period"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TimingEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TimingEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TransformerHardErrorEvent","text":"TransformerHardErrorEvent(element: Element) A TransformerHardErrorEvent is a subclass of RTEEvent which triggers a RunnableEntity when a transformer hard error occurs","title":"TransformerHardErrorEvent"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TransformerHardErrorEvent.element","text":"element: Element element of the TransformerHardErrorEvent","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TransformerHardErrorEvent.name","text":"name: str name of the TransformerHardErrorEvent","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TransformerHardErrorEvent.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that is triggered by the AsynchronousServerCallCompleted","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TransformerHardErrorEvent.swc_internal_behavior","text":"swc_internal_behavior: Optional[SwcInternalBehavior] Get the SwcInternalBehavior that contains the event","title":"swc_internal_behavior"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TriggerInterface","text":"TriggerInterface(element: Element) A TriggerInterface declares a number of triggers that can be sent by an trigger source Use [ ArPackage::create_trigger_interface ] to create a new trigger interface","title":"TriggerInterface"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TriggerInterface.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TriggerInterface.is_service","text":"is_service: Optional[bool] Get/Set if the trigger interface is a service interface","title":"is_service"},{"location":"software_component_api/#autosar_data.abstraction.software_component.TriggerInterface.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.VariableAccess","text":"VariableAccess(element: Element) A VariableAccess allows a RunnableEntity to access a variable in various contexts","title":"VariableAccess"},{"location":"software_component_api/#autosar_data.abstraction.software_component.VariableAccess.accessed_variable","text":"accessed_variable: Optional[ Tuple[VariableDataPrototype, PortPrototype] ] Get the variable that is accessed by the VariableAccess","title":"accessed_variable"},{"location":"software_component_api/#autosar_data.abstraction.software_component.VariableAccess.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.VariableAccess.name","text":"name: str","title":"name"},{"location":"software_component_api/#autosar_data.abstraction.software_component.VariableAccess.runnable_entity","text":"runnable_entity: Optional[RunnableEntity] RunnableEntity that contains the VariableAccess","title":"runnable_entity"},{"location":"software_component_api/#autosar_data.abstraction.software_component.VariableAccess.set_accessed_variable","text":"set_accessed_variable( variable: VariableDataPrototype, context_port: PortPrototype, ) -> None Set the variable that is accessed by the VariableAccess","title":"set_accessed_variable"},{"location":"software_component_api/#autosar_data.abstraction.software_component.VariableDataPrototype","text":"VariableDataPrototype(element: Element) A VariableDataPrototype represents a data element in a SenderReceiverInterface","title":"VariableDataPrototype"},{"location":"software_component_api/#autosar_data.abstraction.software_component.VariableDataPrototype.data_type","text":"data_type: Optional[AutosarDataType] data type of the data element","title":"data_type"},{"location":"software_component_api/#autosar_data.abstraction.software_component.VariableDataPrototype.element","text":"element: Element","title":"element"},{"location":"software_component_api/#autosar_data.abstraction.software_component.VariableDataPrototype.init_value","text":"init_value: Optional[ValueSpecification] initial value of the data element, if any","title":"init_value"},{"location":"software_component_api/#autosar_data.abstraction.software_component.VariableDataPrototype.interface","text":"interface: Optional[SenderReceiverInterface] Get the interface containing the data element","title":"interface"},{"location":"software_component_api/#autosar_data.abstraction.software_component.VariableDataPrototype.name","text":"name: str","title":"name"}]}