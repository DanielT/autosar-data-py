from .autosar_data import *
from typing import Dict, List, FrozenSet, Literal, TypeAlias, Tuple, Union

IncompatibleItemError: TypeAlias = Union[IncompatibleAttributeError, IncompatibleAttributeValueError, IncompatibleElementError]
ElementName: TypeAlias = str # ~5900 variants is too many to list here
AttributeName: TypeAlias = Literal["ACCESSKEY", "ALIGN", "ALLOW-BREAK", "ALT", "BASE", "BGCOLOR", "BINDING-TIME", "BLUEPRINT-VALUE", "BREAK", "CLASS", "COLNAME", "COLNUM", "COLOR", "COLS", "COLSEP", "COLWIDTH", "COORDS", "DEST", "EDIT-HEIGHT", "EDIT-WIDTH", "EDITFIT", "EDITSCALE", "ENUM-TABLE", "FILENAME", "FIT", "FLOAT", "FONT", "FRAME", "GENERATOR", "GID", "HEIGHT", "HELP-ENTRY", "HREF", "HTML-FIT", "HTML-HEIGHT", "HTML-SCALE", "HTML-WIDTH", "INDEX", "INTERVAL-TYPE", "ITEM-LABEL-POS", "KEEP-WITH-PREVIOUS", "L", "LEVEL", "MIME-TYPE", "MOREROWS", "NAME", "NAME-PATTERN", "NAMEEND", "NAMEST", "NOHREF", "NOTATION", "NOTE-TYPE", "ONBLUR", "ONCLICK", "ONDBLCLICK", "ONFOCUS", "ONKEYDOWN", "ONKEYPRESS", "ONKEYUP", "ONMOUSEDOWN", "ONMOUSEMOVE", "ONMOUSEOUT", "ONMOUSEOVER", "ONMOUSEUP", "ORIENT", "PGWIDE", "RESOLUTION-POLICY", "ROTATE", "ROWSEP", "S", "SCALE", "SD", "SHAPE", "SHORT-LABEL", "SHOW-CONTENT", "SHOW-RESOURCE-ALIAS-NAME", "SHOW-RESOURCE-CATEGORY", "SHOW-RESOURCE-LONG-NAME", "SHOW-RESOURCE-NUMBER", "SHOW-RESOURCE-PAGE", "SHOW-RESOURCE-SHORT-NAME", "SHOW-RESOURCE-TYPE", "SHOW-SEE", "SI", "SPANNAME", "STYLE", "T", "TABINDEX", "TABSTYLE", "TEX-RENDER", "TITLE", "TYPE", "UUID", "VALIDITY", "VALIGN", "VIEW", "WIDTH", "xml:space", "xmlns", "xmlns:xsi", "xsi:schemaLocation"]
EnumItem: TypeAlias = str # ~2500 variants is too many to list here
CharacterData: TypeAlias = Union[EnumItem, str, int, float]
ElementContent: TypeAlias = Union[Element, CharacterData]

class ArxmlFile:
    filename: str
    version: AutosarVersion
    def check_version_compatibility(self, version: AutosarVersion) -> List[IncompatibleItemError]: ...
    model: AutosarModel
    elements_dfs: ArxmlFileElementsDfsIterator
    def serialize(self) -> str: ...
    xml_standalone: bool

class ArxmlFileElementsDfsIterator:
    def __iter__(self) -> ArxmlFileElementsDfsIterator: ...
    def __next__(self) -> Tuple[int, Element]: ...

class Attribute:
    attrname: AttributeName
    content: CharacterData

class AttributeIterator:
    def __iter__(self) -> AttributeIterator: ...
    def __next__(self) -> Attribute : ...

class AutosarDataError(Exception):
    pass

class AutosarModel:
    def create_file(self, filename: str, version: AutosarVersion) -> ArxmlFile: ...
    def load_buffer(self, buffer: str, filename: str, strict: bool) -> Tuple[ArxmlFile, List[str]]: ...
    def load_file(self, filename: str, strict: bool) -> Tuple[ArxmlFile, List[str]]: ...
    def remove_file(self, arxmlfile: ArxmlFile) -> None: ...
    def serialize_files(self) -> Dict[str, str]: ...
    def write(self) -> None: ...
    files: List[ArxmlFile]
    root_element: Element
    def get_element_by_path(self, autosar_path: str) -> Element: ...
    elements_dfs: ElementsDfsIterator
    def sort(self) -> None: ...
    identifiable_elements: List[str]
    def get_references_to(self, target_path: str) -> List[Element]: ...
    def check_references(self) -> List[Element]: ...

class AutosarVersion:
    def __new__(cls, verstring: str) -> AutosarVersion: ...
    # this is the stupid result of method used by PyO3 to translate Rust enums
    Autosar_4_0_1: AutosarVersion
    Autosar_4_0_2: AutosarVersion
    Autosar_4_0_3: AutosarVersion
    Autosar_4_1_1: AutosarVersion
    Autosar_4_1_2: AutosarVersion
    Autosar_4_1_3: AutosarVersion
    Autosar_4_2_1: AutosarVersion
    Autosar_4_2_2: AutosarVersion
    Autosar_4_3_0: AutosarVersion
    Autosar_00042: AutosarVersion
    Autosar_00043: AutosarVersion
    Autosar_00044: AutosarVersion
    Autosar_00045: AutosarVersion
    Autosar_00046: AutosarVersion
    Autosar_00047: AutosarVersion
    Autosar_00048: AutosarVersion
    Autosar_00049: AutosarVersion
    Autosar_00050: AutosarVersion
    Autosar_00051: AutosarVersion

class ContentType:
    # this is the stupid result of method used by PyO3 to translate Rust enums
    Elements: ContentType
    CharacterData: ContentType
    Mixed: ContentType

class Element:
    def serialize(self) -> str: ...
    parent: Element
    element_name: ElementName
    element_type: ElementType
    item_name: str
    is_identifiable: bool
    is_reference: bool
    path: str
    model: AutosarModel
    content_type: ContentType
    def create_sub_element(self, element_name: ElementName) -> Element: ...
    def create_sub_element_at(self, element_name: ElementName, position: int) -> Element: ...
    def create_named_sub_element(self, element_name: ElementName, item_name: str) -> Element: ...
    def create_named_sub_element_at(self, element_name: ElementName, item_name: str, position: int) -> Element: ...
    def create_copied_sub_element(self, other: Element) -> Element: ...
    def create_copied_sub_element_at(self, other: Element, position: int) -> Element: ...
    def move_element_here(self, move_element: Element) -> Element: ...
    def move_element_here_at(self, move_element: Element, position: int) -> Element: ...
    def remove_sub_element(self, element: Element) -> None: ...
    reference_target: Element
    def get_sub_element(self, name_str: str) -> Element: ...
    def get_sub_element_at(self, position: int) -> Element: ...
    position: int
    sub_elements: ElementsIterator
    elements_dfs: ElementsDfsIterator
    character_data: CharacterData
    def remove_character_data(self) -> None: ...
    def insert_character_content_item(self, chardata: str, position: int) -> None: ...
    def remove_character_content_item(self, position: int) -> None: ...
    content_item_count: int
    content: ElementContentIterator
    attributes: AttributeIterator
    def attribute_value(self, attrname: AttributeName) -> CharacterData: ...
    def set_attribute(self, attrname: AttributeName, chardata: CharacterData) -> None: ...
    def set_attribute_string(self, attrname: AttributeName, value: str) -> None: ...
    def remove_attribute(self, attrname: AttributeName) -> None: ...
    def sort(self) -> None: ...
    def list_valid_sub_elements(self) -> List[ValidSubElementInfo]: ...
    file_membership: Tuple[bool, FrozenSet[ArxmlFile]]
    def add_to_file(self, file: ArxmlFile) -> None: ...
    def remove_from_file(self, file: ArxmlFile) -> None: ...
    xml_path: str

class ElementContentIterator:
    def __iter__(self) -> ElementContentIterator: ...
    def __next__(self) -> ElementContent: ...

class ElementType:
    is_named: bool
    is_ref: bool
    is_ordered: bool
    splittable: int
    def splittable_in(self, version: AutosarVersion) -> bool: ...
    def reference_dest_value(self, target: ElementType) -> EnumItem: ...
    def find_sub_element(self, target_name: ElementName, version: int) -> ElementType: ...

class ElementsDfsIterator:
    def __iter__(self) -> ElementsDfsIterator: ...
    def __next__(self) -> Tuple[int, Element]: ...

class ElementsIterator:
    def __iter__(self) -> ElementsIterator: ...
    def __next__(self) -> Element: ...

class IncompatibleAttributeError:
    element: Element
    attribute: AttributeName

class IncompatibleAttributeValueError:
    element: Element
    attribute: AttributeName
    attribute_value: str

class IncompatibleElementError:
    element: Element

class ValidSubElementInfo:
    element_name: str
    is_named: bool
    is_allowed: bool

version: str
